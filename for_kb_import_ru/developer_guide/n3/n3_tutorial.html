<div class="md-body" data-md-color-accent="indigo" data-md-color-primary="indigo" data-md-color-scheme="comindware" dir="ltr" kb-id="5132" kb-tags="Notation 3,N3,тройки,триплеты,онтологии" kb-title="Учебник по N3">
<div class="md-container" data-md-component="container">
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<nav aria-label="Содержание" class="md-nav md-nav--secondary">
<div class="mce-toc">
<h2 class="toc-heading">
      Содержание
      </h2>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#о-курсе">
<span class="md-ellipsis">
      О курсе
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#типы-синтаксиса-запросов-в-comindware-platform">
<span class="md-ellipsis">
      Типы синтаксиса запросов в Comindware Platform
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#хранение-данных">
<span class="md-ellipsis">
      Хранение данных
    </span>
</a>
<nav aria-label="Хранение данных" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#пример-триплета">
<span class="md-ellipsis">
      Пример триплета
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#структура-данных-в-comindware-platform">
<span class="md-ellipsis">
      Структура данных в Comindware Platform
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#цели-использования-языка-n3">
<span class="md-ellipsis">
      Цели использования языка N3
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#урок-1">
<span class="md-ellipsis">
      Урок 1
    </span>
</a>
<nav aria-label="Урок 1" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#чему-научимся">
<span class="md-ellipsis">
      Чему научимся
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#триплеты">
<span class="md-ellipsis">
      Триплеты
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#переменные">
<span class="md-ellipsis">
      Переменные
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#входные-и-выходные-параметры-item-и-value">
<span class="md-ellipsis">
      Входные и выходные параметры ?item и ?value
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#задачи">
<span class="md-ellipsis">
      Задачи
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#итог">
<span class="md-ellipsis">
      Итог
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#задачи_1">
<span class="md-ellipsis">
      Задачи
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</div>
</nav>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h2 id="о-курсе">О курсе</h2>
<p>Основная цель курса — научить пользователя ориентироваться в написанных выражениях и самостоятельно писать запросы средней сложности на языке <strong>N3</strong>. В уроках освещены базовые принципы работы триплетов, интерпретатора, приведены реальные примеры использования. В конце каждого урока представлены задания для самостоятельной работы.</p>
<div class="notice notice-warning">
<p class="admonition-title">Внимание!</p>
<p>Так как это вводный курс, некоторые понятия в нём упрощены, чтобы облегчить понимание работы RDF и Notation 3, без ущерба для точности представленной информации.</p>
</div>
<p><strong>Предусловие:</strong> хорошее понимание принципов работы и настройки <strong>Comindware Platform</strong>.</p>
<h2 id="типы-синтаксиса-запросов-в-comindware-platform">Типы синтаксиса запросов в Comindware Platform</h2>
<p>В <strong>Comindware Platform</strong> предусмотрено два типа синтаксиса запросов:</p>
<ol class="colored_numbers_list">
<li>
<p><strong>Формулы</strong> — фирменный язык выражений <strong>Comindware</strong>, похожий на формулы Excel. Является простым для восприятия и представляет собой надстройку над <strong>N3</strong>. Для базовой настройки системы его зачастую достаточно. Типовые примеры использования формул:</p>
<ul>
<li>выборка данных из связанных шаблонов записей;</li>
<li>подсчёт количества объектов;</li>
<li>простые математические операции типа умножения и деления;</li>
<li>конкатенация и преобразования строк.</li>
</ul>
<p>Полный перечень функций, используемых в <strong>формулах</strong>, представлен в <a class="mkdocs_imported_link" href="https://kb.comindware.ru/category.php?id=880">справочнике функций</a>.</p>
</li>
<li>
<p><strong>Notation 3</strong> (<strong>N3</strong>, <strong>триплеты</strong>) — более сложный в прочтении и написании, но более функциональный и основополагающий язык. Стандарт этого языка определён международным консорциумом W3C.</p>
<p>Здесь мы рассмотрим базовые принципы использования языка <strong>N3</strong>.</p>
</li>
</ol>
<h2 id="хранение-данных">Хранение данных</h2>
<p><strong>Comindware Platform</strong> использует графовую базу данных, основанную на модели RDF.</p>
<p>Общая идея графовой модели заключается в том, что любой объект материального и нематериального мира имеет свойства, а эти свойства содержат определённые значения. Следовательно, любую сущность можно описать с помощью простых выражений, которые называют свойствами и их значениями.</p>
<p>Описание сущностей с помощью графовой модели строится по определённым правилам.</p>
<p>Основным синтаксическим элементом языка N3 является <strong>триплет</strong>.</p>
<p><strong>Триплет</strong> состоит из трёх связанных сущностей: <strong>Субъект — предикат — объект</strong>.</p>
<p>Эти термины необходимо запомнить, так как они часто используются в курсе.</p>
<h3 id="пример-триплета">Пример триплета</h3>
<p>Триплет можно соотнести с простым предложением вида: <em>Подлежащее — Сказуемое — Дополнение</em>.</p>
<p>Например, утверждение <em>"Книга написана Пушкиным"</em> в RDF-терминологии можно представить следующим образом:</p>
<ul>
<li><strong>субъект</strong> — Книга</li>
<li><strong>предикат</strong> — написана</li>
<li><strong>объект</strong> — Пушкин</li>
</ul>
<p>Теперь построим сам граф. Субъект и объект представлены как узлы. В нашем примере это книга и Пушкин. Свойство, указывающее, кем написана книга, представлено соединительной линией со стрелкой от субъекта к объекту.</p>
<p><img alt="Триплет RDF" src="/platform/v5.0/developer_guide/n3/img/n3_tutorial_triple.png"/></p>
<h3 id="структура-данных-в-comindware-platform">Структура данных в Comindware Platform</h3>
<p>По такому же принципу можно описать структуру данных в шаблоне записи:</p>
<ul>
<li><strong>Субъект</strong> — запись в шаблоне записи.</li>
<li><strong>Предикат</strong> — атрибут записи.</li>
<li><strong>Объект</strong> — значение атрибута.</li>
</ul>
<p>Например, имеется шаблон записи «Книги». В шаблоне имеются атрибуты <em>«Название»</em> и <em>«Автор»</em>. В шаблоне имеются две записи.</p>
<p>Данные этих записей хранятся в триплетах. В упрощённом виде эти триплеты можно представить следующим образом:</p>
<div class="highlight"><code><pre><span></span><code>    <span class="s">"id_8036"</span> <span class="s">"Название "</span><span class="err">Война</span> <span class="err">и</span> <span class="err">мир</span><span class="s">".</span></code> <br/><code>    <span class="s">"id_8036"</span> <span class="s">"Автор"</span> <span class="s">"Толстой Л.Н."</span><span class="p">.</span></code> <br/><code>    <span class="s">"id_8037"</span> <span class="s">"Название"</span> <span class="s">"Медный всадник"</span><span class="p">.</span></code> <br/><code>    <span class="s">"id_8037"</span> <span class="s">"Автор"</span> <span class="s">"Пушкин А.С."</span><span class="p">.</span></code> <br/></pre></code></div>
<p>Пример записей в шаблоне <em>«Книги»</em>:</p>
<table style="width: 100%;">
<thead>
<tr>
<th>ID</th>
<th>Название</th>
<th>Автор</th>
</tr>
</thead>
<tbody>
<tr>
<td>8036</td>
<td>Война и мир</td>
<td>Толстой Л.Н.</td>
</tr>
<tr>
<td>8037</td>
<td>Медный всадник</td>
<td>Пушкин А.С.</td>
</tr>
</tbody>
</table>
<p>Аналогичным образом хранится вся метаинформация (описания шаблонов записи, форм, объектов, типов и т. д.), а также атрибуты окружения (текущий пользователь, текущее время, текущий контекст и т. д.).</p>
<p>Такая структура обеспечивает единообразие и простоту доступа к данным через запросы к базе.</p>
<p>Ключевые преимущества использования триплетов для описания и хранения данных:</p>
<ol class="colored_numbers_list">
<li><strong>Простота понимания модели данных.</strong> Создание шаблонов записи и связей между ними быстро усваивается даже неподготовленным пользователем.</li>
<li><strong>Мгновенное добавление новых шаблонов записи и атрибутов,</strong> которые сразу доступны к работе.</li>
<li><strong>Неограниченная ширина и глубина связей между сущностями.</strong> В <strong>Comindware Platform</strong> нет ограничений по количеству атрибутов и связей между ними.</li>
<li><strong>Простота и неограниченность навигации по связям.</strong> Переход из одного справочника в другой через ссылочное поле осуществляется единообразно.</li>
</ol>
<p>Для лучшего понимания принципов описания и хранения данных без использования жёсткой структуры (такой, как таблицы в SQL), ознакомьтесь со статьёй <em><a class="mkdocs_imported_link" href="https://kb.comindware.ru/article.php?id=4856">«Онтология»</a></em>.</p>
<div class="notice notice-success">
<p class="admonition-title">Внутренняя логика обработки N3 в Comindware Platform</p>
<p>К примеру, при создании вычисляемого атрибута используется формула.</p>
<p>Что происходит под «капотом» после написания формулы?</p>
<p>Компилятор переводит её в запрос N3, который уже однозначно понятен системе.</p>
<p>Можно сделать вывод: если есть желание облегчить работу компилятора, пишите запрос сразу на N3.</p>
</div>
<h2 id="цели-использования-языка-n3">Цели использования языка N3</h2>
<ul>
<li><strong>Продвинутое использование Comindware Platform.</strong></li>
<li><strong>Доступ ко всем созданным и системным атрибутам.</strong> В интерфейсе <strong>Comindware Platform</strong> представлены не все системные атрибуты, а только те, которые используются чаще всего в типовых сценариях. N3 предоставляет доступ ко большему количеству атрибутов и сущностей, чем формулы.</li>
<li><strong>Расширенные возможности работы с данными.</strong> Дополнительные математические функции, функции для работы со списками, приведения данных к одному типу, расчётов времени и т.д. См. <em><a class="mkdocs_imported_link" href="https://kb.comindware.ru/category.php?id=877">руководство по написанию выражений на N3</a></em>.</li>
</ul>
<h2 id="урок-1">Урок 1</h2>
<h3 id="чему-научимся">Чему научимся</h3>
<ul>
<li>Триплеты, синтаксис, переменные, параметры <code>?item</code> и <code>?value</code>.</li>
</ul>
<h3 id="триплеты">Триплеты</h3>
<p>Тело запроса состоит из триплетов вида <code>субъект – предикат – объект</code>, которые мы рассмотрели во введении.</p>
<p><strong>Пример запроса:</strong></p>
<div class="highlight"><code><pre><span></span><code><span class="p">{</span></code> <br/><code>    <span class="err">?item</span> <span class="err">?company</span> <span class="err">?customer</span><span class="p">.</span></code> <br/><code>    <span class="err">?customer</span> <span class="err">?resolutionTimeAttribute</span> <span class="err">?resolutionTime</span><span class="p">.</span></code> <br/><code>    <span class="err">?resolutionTime</span> <span class="err">?requestTypeAttribute</span> <span class="err">?value</span><span class="p">.</span></code> <br/><code><span class="p">}</span></code> <br/></pre></code></div>
<p>С помощью такого запроса мы указываем, какая строка из БД необходима, чтобы получить требуемые данные из графа.</p>
<p>Например, в контексте записи заявки:</p>
<ul>
<li>Первым триплетом находим ссылку на клиента.</li>
<li>Вторым триплетом определяем время ответа на заявку.</li>
<li>Третьим триплетом указываем тип времени ответа.</li>
</ul>
<p>В синтаксисе языка N3 существуют определённые правила, без соблюдения которых запрос не будет сохранён и выполнен корректно.</p>
<p>Вот основные основные правила:</p>
<ol class="colored_numbers_list">
<li>Каждый триплет начинается с новой строки.</li>
<li>Объявление переменных производится с префиксом <code>?</code> (например, <code>?variable</code>).</li>
<li>Весь запрос помещается в фигурные скобки (<code>{}</code>).</li>
<li>В конце каждого триплета ставится точка (<code>.</code>).</li>
<li>Интерпретатор учитывает регистр символов, то есть <code>?variable</code> и <code>?Variable</code> — это две разных переменных.</li>
</ol>
<h3 id="переменные">Переменные</h3>
<p>При формировании запроса используются переменные.</p>
<p>Переменная — это именованное хранилище данных, обозначаемое в N3 символом <code>?</code>.</p>
<p>В приведённом примере используются переменные <code>?customer</code> и <code>?resolutionTime</code>, которые содержат ссылки на шаблоны записи.</p>
<p>Имена переменных следует задавать так, чтобы они отражалиь суть хранимых данных.</p>
<div class="notice notice-info">
<p class="admonition-title">Примечание</p>
<p>В приведённом выше примере переменными являются все объекты из триплета после символа «?». Это сделано для наглядности.</p>
<p>В следующих уроках мы научимся определять предикат через переменную.</p>
</div>
<h3 id="входные-и-выходные-параметры-item-и-value">Входные и выходные параметры <code>?item</code> и <code>?value</code></h3>
<p>Наш пример начинается и заканчивается использованием двух переменных: <code>?item</code> и <code>?value</code>. Это особые зарезервированные системные переменные:</p>
<ul>
<li><code>?item</code> — входной параметр запроса. Его значение определяется контекстом, в котором выполняется запрос. Например, при вычислении значения атрибута <code>?item</code> содержит ID текущей записи. Подробные сведения см. в [Справочнике по языку N3][n3_guide]/</li>
<li><code>?value</code> — выходной параметр. В него помещается результат запроса. Обратите внимание: тип данных, помещённых в <code>?value</code>, должен совпадать с типом данных атрибута, в который записывается результат, например, логическим или числовым.</li>
</ul>
<p><strong>Итого:</strong> мы разобрались с телом запроса, основными правилами синтаксиса,</p>
<h3 id="задачи">Задачи</h3>
<p>Модель данных: у нас имеется шаблоны записи <em>«Договоры»</em>, <em>«Контрагенты»</em> и <em>«Статусы контрагента»</em>. У договора есть ссылка на контрагента, а у контрагента есть ссылочное поле на статус.</p>
<p>Мы находимся в контексте договоров. Нам нужно вывести статус контрагента.</p>
<p>Предикаты:</p>
<p><code>?agentAttribute</code> - предикат контрагента</p>
<p><code>?statusAttribute</code> - предикат ссылки на статус у контрагента</p>
<p>Требуется написать запрос и получить значение статуса контрагента.</p>
<p>Разберём общую модель написания запроса на N3.</p>
<p>В общем виде запрос состоит из следующих компонентов:</p>
<ul>
<li>Подключаемые библиотеки пространств имен — префиксы</li>
<li>Объявление переменных</li>
<li>Триплеты</li>
</ul>
<h3 id="итог">Итог</h3>
<p>В итоге, мы научились использовать библиотеку <code>object</code> и входящую в неё функцию записи URI предиката в переменную.</p>
<p>Познакомились со структурой триплетов.</p>
<p>Разобрали входные и выходные параметры запроса (<code>item</code> и <code>value</code>)</p>
<p>Познакомились с основными правилами синтаксиса запроса.</p>
<h3 id="задачи_1">Задачи</h3>
<p>Создаём модель данных:</p>
<p>Три шаблона записи. Первый шаблон имеет числовой атрибут <em>«Calculation»</em> и атрибут ссылку на второй шаблон. Второй ШЗ имеет ссылку на третий. В третьем ШЗ создаем атрибут <em>«Number»</em>. У шаблонов создаём по одной записи и устанавливаем ссылочные поля. В атрибут <em>«Number»</em> пишем число.</p>
<p>Задача: присвоить атрибуту <em>Calculation</em> значение атрибута <em>Number</em>.</p>
<h1 id="урок-2">Урок 2</h1>
<h2 id="чему-научимся_1">Чему научимся</h2>
<p>Библиотеки пространств имен, присвоение переменных, применение системных атрибутов, built-in предикаты, конструкция from.</p>
<p>Итак, начнем разбор первого полноценного запроса.  Для  ее анализа нужно знать модель данных, в которой мы его пишем.</p>
<p>Пример:</p>
<p>Напишем запрос, который пройдет по ссылке в IssueType, возьмет значение текстового атрибута Title и выведет его.</p>
<p><strong>Модель данных:</strong></p>
<p>Два шаблона записи – <em>Issue</em> и <em>Type</em>.</p>
<p>В ШЗ Issue имеется ссылка на ШЗ <em>Type</em>. Имя: <code>IssueType</code>.</p>
<p>В ШЗ Issue есть текстовый атрибут <code>TitleCalc</code>. В нем пишем текущий запрос.</p>
<p>В ШЗ Type создан текстовой атрибут <code>Title</code>.</p>
<div class="highlight"><code><pre><span></span><code><span class="k">@prefix</span><span class="w"> </span><span class="nn">object:</span><span class="w"> </span><span class="nv">&lt;http://comindware.com/ontology/object#&gt;</span></code> <br/><code><span class="p">{</span></code> <br/><code>    <span class="p">(</span><span class="s">"Issue"</span> <span class="s">"IssueTYpe"</span><span class="p">)</span> <span class="nn">object</span><span class="p">:</span><span class="nt">findProperty</span> <span class="err">?issueTypeAttribute</span><span class="p">.</span></code> <br/><code>    <span class="p">(</span><span class="s">"Type"</span> <span class="s">"Title"</span><span class="p">)</span> <span class="nn">object</span><span class="p">:</span><span class="nt">findProperty</span> <span class="err">?titleAttribute</span><span class="p">.</span></code> <br/><code></code> <br/><code>    <span class="err">?item</span> <span class="err">issueTypeAttribute</span><span class="p">.</span> <span class="err">?issueTypeValue</span><span class="p">.</span></code> <br/><code>    <span class="err">?issueTypeValue</span> <span class="err">?titleAttribute</span> <span class="err">?value</span></code> <br/><code><span class="p">}</span></code> <br/></pre></code></div>
<p>Соответствующая формула выглядела бы так:</p>
<div class="highlight"><code><pre><span></span><code><span class="err">$</span><span class="n">IssueTypeRef</span><span class="o">-&gt;</span><span class="n">Title</span></code> <br/></pre></code></div>
<p>Пример формулы приведён лишь для наглядности. В дальнейшем не следует пытаться представлять выражения N3 в виде формул, так как это может сбить с верного понимания.</p>
<p>Начнем разбор построчно:</p>
<p>Первая строка — это библиотека пространства имен — префикс.</p>
<div class="highlight"><code><pre><span></span><code><span class="k">@prefix</span><span class="w"> </span><span class="nn">object:</span><span class="w"> </span><span class="nv">&lt;http://comindware.com/ontology/object#&gt;</span><span class="p">.</span></code> <br/></pre></code></div>
<h3 id="библиотеки-пространств-имён">Библиотеки пространств имён</h3>
<p><strong>Библиотеки (префиксы)</strong> — это подключаемые модули (области), где лежат знания об объектах, функциях и разных правилах. С их помощью мы можем обращаться с системным и прикладным атрибутам и брать их значения. Также, при объявлении библиотек может появляться доступ к различным функциям по работе с датами, списками, числами и т.д. См. [справочник по языку N3][n3_guide].</p>
<p>С помощью этой библиотеки у нас появляется доступ к функции <code>object:findProperty</code> из строки 3 и 4 нашего примера. Данная функция позволяет брать URI атрибутов, записывать в переменные и использовать их внутри запроса.</p>
<p>Так как модель описания данных — RDF, для неё определены некоторые стандарты. Так, один из стандартов — хранение в виде URI.</p>
<p>URI — последовательность символов, идентифицирующая абстрактный или физический ресурс. URI выглядит следующим образом:</p>
<div class="highlight"><code><pre><span></span><code>https://www.w3.org/1999/02/22-rdf-syntax-ns#type</code> <br/></pre></code></div>
<p>По сути каждая сущность из триплета является либо URI, либо литералом. При использовании полной нотации RDF выражений, происходит появление в записи длинных строк вида:</p>
<p><em><a class="mkdocs_imported_link" href="img/n3_tutorial_rdf_triple.png">RDF-триплет</a></em></p>
<p>Префикс <code>http://comindware.com/ontology/object#</code> и функция <code>object:findProperty</code> являются базовыми и в дальнейшем будет часто использоваться в написании запросов. Она содержит в себе функцию поиска id атрибута по его системному имени.</p>
<p>Перейдём к строкам 3 и 4.</p>
<p>В предыдущем уроке мы не касались темы предикатов в триплете. Они были даны изначально. Но по сути каждая часть триплета находится в переменных, в том числе и искомые атрибуты. Чтобы их определить и записать в переменную пишем выражение вида:</p>
<div class="highlight"><code><pre><span></span><code><span class="p">(</span><span class="s">"TemplateSystemName"</span> <span class="s">"AttributeSystemName"</span><span class="p">)</span> <span class="nn">object</span><span class="p">:</span><span class="nt">findProperty</span> <span class="err">?variable</span><span class="p">.</span></code> <br/></pre></code></div>
<p>Эта функция подходит только для определения прикладных атрибутов (созданных вручную). Системные атрибуты лежат в других библиотеках.</p>
<p>Теперь, вместо длинных URI предикатов, мы можем использовать переменные.</p>
<p>Берем атрибуты нужных предикатов для запроса и присваиваем их в переменные <code>IssueTypeAttribute</code> и <code>titleAttribute</code>.</p>
<p>Где, имя переменной определяем сами.</p>
<h3 id="триплет">Триплет</h3>
<p>С первыми тремя строчками разобрались. Начинаем писать сам триплет.</p>
<div class="highlight"><code><pre><span></span><code>  <span class="mi">1</span>             <span class="mi">2</span>             <span class="mi">3</span></code> <br/><code><span class="err">?item</span> <span class="err">?IssueTypeAttribute</span> <span class="err">?IssueType</span><span class="p">.</span></code> <br/></pre></code></div>
<ol class="colored_numbers_list">
<li>Каждый запрос имеет входной параметр <code>?item</code>. Он вычисляется по умолчанию и служит для определения текущей записи, к которой относится атрибут.</li>
<li>Указываем предикат. Мы его уже определили выше.</li>
<li>Создаем переменную, в которую будет помещено значение. Имя этой переменной придумываем сами. Интерпретатор видит, какой части не хватает для триплета и автоматически присваивает в него некое значение.</li>
</ol>
<p>Данной строкой мы добились того, что смогли определить ссылку, чье значение требуется для дальнейшего нахождения поля <code>title</code>.</p>
<p>Важное правило работы интерпретатора:</p>
<p>Если результат триплета будет <code>false</code> — а именно он не найдет такого предиката, либо вместо объекта мы впишем уже определенное значение и интерпретатор не найдет такую строку в базе, тогда он останавливается и вниз дальше не идет.</p>
<p>Разбираем строку 7.</p>
<div class="highlight"><code><pre><span></span><code><span class="err">?IssueType</span> <span class="err">?TitleAttribute</span> <span class="err">?value</span><span class="p">.</span></code> <br/></pre></code></div>
<p>Берем переменную, которую определили выше. Так как, мы переместились по ссылке и находимся в контексте ШЗ <code>IssueType</code>, у него имеется предикат <code>TitleAttribute</code>. Указываем его.</p>
<p>И третьим аргументом идет обязательная переменная <code>value</code>. <code>value</code> - является выходным параметром запроса. То что мы поместим в нее, то и будет отображаться в вычисляемом атрибуте. Тип данных, помещенный в <code>value</code> должно быть согласован с типом атрибута. Например: если вычисления в атрибуте логического типа, в <code>value</code> нужно получить логическое значение. И такое же правило существует для остальных типов данных.</p>
<h2 id="присвоение-переменных">Присвоение переменных</h2>
<p>В предыдущем примере мы использовали ситуацию, где в триплетах субъект и предикат были определены. Неизвестным являлся объект.</p>
<p>Интерпретатор понимает какая сущность из триплета неизвестна и тут же присваивает в нее недостающее значение.</p>
<p>Но это не единственный возможный случай присваивания. Всего существует три основных варианта присвоения значений в переменные с помощью работы триплета.</p>
<ol class="colored_numbers_list">
<li>
<p>Первый способ, используемый в примере 1 урока.  Субъект и предикат определен, значит искомое значение - это объект.</p>
<figure class="screenshot_with_caption" markdown=""><img alt="" src="/platform/v5.0/developer_guide/n3/img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.008.png"/><figcaption class="caption"></figcaption></figure>
</li>
<li>
<p>Триплет позволяет идти и от обратного, если известен объект и предикат, то мы находим субъект</p>
<figure class="screenshot_with_caption" markdown=""><img alt="" src="/platform/v5.0/developer_guide/n3/img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.009.png"/><figcaption class="caption"></figcaption></figure>
</li>
<li>
<p>Это так называемое точное совпадение. В случае, где известны все три части, происходит проверка на полное совпадение. Здесь получаем уточненное значение субъекта.</p>
</li>
</ol>
<figure class="screenshot_with_caption" markdown="block">![](img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.010.png)&lt;figcaption&gt;&lt;/figcaption&gt;</figure>
<p>Рассмотрим еще один пример с новым типом присвоения значения переменным:</p>
<p>Задача: в некоторых случаях администратор приложения хочет быстро и наглядно увидеть есть ли среди заявок те, у которых в запущенном процессе имеется ошибка.</p>
<p>Суть вычисления - если у текущей записи имеется процесс с ошибкой, вывести true в логический атрибут.</p>
<p>Модель данных:</p>
<p>У нас имеется процесс и связанный шаблон записи. В связанном шаблоне записи создаем логический вычисляемый атрибут. В вычислениях пишем:</p>
<div class="highlight"><code><pre><span></span><code><span class="k">@prefix</span><span class="w"> </span><span class="nn">process:</span><span class="w"> </span><span class="nv">&lt;http://comindware.com/ontology/process#&gt;</span><span class="p">.</span></code> <br/><code><span class="p">{</span></code> <br/><code>    <span class="err">?proc</span> <span class="nn">process</span><span class="p">:</span><span class="nt">businessObject</span> <span class="err">?item</span><span class="p">.</span></code> <br/><code>    <span class="err">?proc</span> <span class="nn">process</span><span class="p">:</span><span class="nt">hasTokenError</span> <span class="err">?value</span><span class="p">.</span></code> <br/><code><span class="p">}</span></code> <br/></pre></code></div>
<p>Начнем разбор построчно:</p>
<p>1 строка - подключаем библиотеку пространств имен процесса. После данного подключения становятся доступны системные предикаты процесса.</p>
<h2 id="системные-атрибуты">Системные атрибуты</h2>
<p>В платформе предусмотрено два вида атрибутов: системные и прикладные. К прикладным мы относим, те сущности, которые были вручную созданы для нашей онтологии.</p>
<p>Но также, у каждого объекта в платформе (Процессы, шаблоны записи, группы, глобальные настройки и т.д.) есть ряд системных атрибутов, которые не всегда видны в интерфейсе программы, но они существуют и как правило логика наполнения данными таких атрибутов уже предопределена и автоматически заполняется системой.</p>
<p>3 строка - тут мы имеем ситуацию с переменными, когда неизвестен один субъект (2 случай).  Мы знаем что у процесса есть предикат <code>businessObject</code>, который связывает запись с процессом. +Этот атрибут является системным.  Поэтому, первым пишем переменную, затем ее предикат и объект. По итогу в переменной «proc» у нас появился текущий, связанный с записью, процесс.</p>
<p>4 строка - здесь имеем уже первый вид присваивания. Предикат в этой строке тоже системный. Он является логическим типом и его значение становиться true, если запущенный процесс имеет ошибку. Соответственно его значение мы и передаем в выходной параметр value.</p>
<p>Так мы выведем в атрибут екгу, если есть ошибка в процессе.</p>
<h2 id="встроенные-предикаты">Встроенные предикаты</h2>
<p>Помимо, обычных предикатов, которые описывают свойства сущностей в платформе мы имеем также Встроенные предикаты. Это сложные предикаты, которые носят в себе какие-либо функции по работе со строками, датами и т.д. Список таких предикатов описан в документе основы N3.</p>
<p>Рассмотрим пример:</p>
<p>Задача: У нас есть ШЗ TemplateOne. У ШЗ есть коллекция.  У коллекции имеется числовой атрибут. Требуется вывести сумму записей коллекции этого числового поля в вычисляемый числовой атрибут ШЗ.</p>
<p>Пример:</p>
<div class="highlight"><code><pre><span></span><code><span class="k">@prefix</span><span class="w"> </span><span class="nn">object:</span><span class="w"> </span><span class="nv">&lt;http://comindware.com/ontology/object#&gt;</span><span class="p">.</span></code> <br/><code><span class="k">@prefix</span><span class="w"> </span><span class="nn">cmwmath:</span><span class="w"> </span><span class="nv">&lt;http://comindware.com/logics/math#&gt;</span><span class="p">.</span></code> <br/><code><span class="p">{</span></code> <br/><code>    <span class="p">(</span><span class="s">"TemplateOne"</span> <span class="s">"Collection"</span><span class="p">)</span> <span class="nn">object</span><span class="p">:</span><span class="nt">findProperty</span> <span class="err">?collectionAttribute</span><span class="p">.</span></code> <br/><code>    <span class="p">(</span><span class="s">"TemplateTwo"</span> <span class="s">"Number"</span><span class="p">)</span> <span class="nn">object</span><span class="p">:</span><span class="nt">findProperty</span> <span class="err">?numberAttribute</span><span class="p">.</span></code> <br/><code></code> <br/><code>    <span class="err">from</span> <span class="p">{</span></code> <br/><code>        <span class="err">?item</span> <span class="err">?collectionAttribute</span> <span class="err">?coll</span><span class="p">.</span></code> <br/><code>        <span class="err">?coll</span> <span class="err">?numberAttribute</span> <span class="err">?collNumbers</span><span class="p">.</span></code> <br/><code>    <span class="p">}</span> <span class="err">select</span> <span class="err">?collNumbers</span> <span class="err">-&gt;</span> <span class="err">?numbersList</span><span class="p">.</span></code> <br/><code>    <span class="err">?numbersList</span> <span class="nn">cmwmath</span><span class="p">:</span><span class="nt">sum</span> <span class="err">?value</span><span class="p">.</span></code> <br/><code><span class="p">}</span></code> <br/></pre></code></div>
<p>2 строка - добавляем библиотеку, содержащую в себе ряд математических функций.</p>
<h2 id="конструкция-from-">Конструкция <code>from {}</code></h2>
<p>7 строка - добавляем конструкцию <code>from {}</code>. Так как мы используем математическую функцию суммирования, ей требуется получить на вход такой тип данных, как «list». Если бы мы просто нашли переменную collnumbers и попытались бы ее применить к функции без преобразования в list, тогда бы ничего не вышло. В collnumbers хранятся uri к значениям записей, а данная функция не работает с uri. Ей нужен понятный для нее тип данных. Какой тип данных требуется на вход разным функциям описано в документе N3.</p>
<p>Структура конструкции: <code>from {триплеты} select ?переменная -&gt; ?лист.</code></p>
<p>11 строка - пишем наш built-in предикат «cmwmath:sum». В переменную value запишется получившаяся сумма из списка чисел numbersList.</p>
<h3 id="итог_1">Итог</h3>
<p>Теперь мы умеем применять разные типы присвоения значений в переменные, используем системные атрибуты в наших запросах, производим вычисления с помощью встроенных предикатов.</p>
<p>Задачи:</p>
<h2 id="урок-3">Урок 3</h2>
<h3 id="чему-научимся_2">Чему научимся</h3>
<p>Итератор,  <code>assert</code>, <code>if</code>, <code>or</code>, контейнеры.</p>
<p>В данном уроке мы будем знакомиться с работой итератора, от которого зависит быстродействие выполнения запроса. Также, познакомимся с отдельными частоиспользуемыми функциями.</p>
<h3 id="итератор">Итератор</h3>
<p>Еще одна важная особенность при работе с с запросами —  это итератор.</p>
<p>Итератор — это перечислитель, который поддерживает простой перебор по группе ссылок. К группе ссылок относятся коллекции и ссылки со множественными значениями в них.</p>
<p>Под перебором мы имеем в виду,  что итератор в порядке случайной очереди берет первый объект из коллекции и проверяет его на верность выполнения условий по всем нижестоящим триплетам.  Пример:</p>
<div class="highlight"><code><pre><span></span><code><span class="err">?item</span> <span class="err">?collectionAttribute</span> <span class="err">?coll</span><span class="p">.</span></code> <br/><code><span class="err">?coll</span> <span class="err">?numberAttribute</span> <span class="mi">15</span><span class="p">.</span></code> <br/><code><span class="err">?coll</span> <span class="err">?textfield</span> <span class="err">?text</span><span class="p">.</span></code> <br/></pre></code></div>
<p>В переменную <code>coll</code> мы получили коллекцию.  Итератор взял первую запись из коллекции и пошел на 10 строчку. В этой строке мы выполняем проверку на точное совпадение (3 тип присваивания). Мы проверяем что у этой записи в атрибуте Number значение <code>15</code>.</p>
<p>Если у этой записи значение не 15, тогда результат триплета равен <code>false</code>, и эта запись выбрасывается из результата и мы возвращаемся обратно на строку 1 и берем следующую запись коллекции.</p>
<p>Если результат следующей записи <code>true</code>, тогда запись двинулась дальше на строку 3 и так до конца тела запроса. Таким образом, он повторяет свои действия пока не закончатся уникальные записи.</p>
<p>Важное примечание: итератор работает всегда. Он пытается вернуться и к верхней строчке и проверить есть ли значения, который он не проверял. Возвращается наверх, сверяет значение с записанным хэшем. Если это значение уже было, он останавливается.</p>
<p>Из этого следует правило, что вверху запроса следует указывать</p>
<p>В случае, если мы точно знаем, что итератор должен пройти один раз по телу запроса (нету ссылок со множественным значением или коллекций), тогда внутри тела, триплеты можно обернуть в конструкцию once {}. Она сделает запрос быстрее.</p>
<h2 id="логическое-и">Логическое И</h2>
<p>Распространены ситуации, где нужно объединить два условия выборки «логическим и». В N3 нам не нужны специальные функции, так как между строками триплетов по умолчанию используется конъюнкция.</p>
<p>Предположим, что мы пишем какое то условие применения в правила на форме. Мы должны получить значение truе, если атрибуты PlannedStartDate и PlannedEndDate пустые.</p>
<figure class="screenshot_with_caption">
<p><img alt="" src="/platform/v5.0/developer_guide/n3/img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.014.png"/></p><figcaption class="caption"></figcaption>
</figure>
<p>6 строка — проверяем чтобы атрибут PlannedStartDate был пуст.</p>
<p>Проверка на пустоту происходит подобным синтаксисом:</p>
<div class="highlight"><code><pre><span></span><code><span class="err">not</span> <span class="p">{</span><span class="err">?субъект</span> <span class="err">?предикат</span> <span class="err">?</span><span class="p">.}.</span></code> <br/></pre></code></div>
<p>Знак-точка вместо объекта означает, что в нем есть данные. Соответственно, мы добавляем not и у нас получается проверка на пустоту.</p>
<p>Предположим, что 6 строка выдала true(атрибут пустой) , тогда интерпретатор перешел 7 строке.</p>
<p>Если в 7 строке интерпертатор выдаст false, то он заканчивает работу и не запишет в value значение true.</p>
<p>Таким образом, ему требуется, чтобы в 6 и 7 выполнились условия.</p>
<h2 id="логическое-или">Логическое ИЛИ</h2>
<p>Если же мы хотим изменить наше условие, и хотим выводить true, если хоть один атрибутов пуст, тогда условие будет следующее:</p>
<figure class="screenshot_with_caption">
<p><img alt="" src="/platform/v5.0/developer_guide/n3/img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.015.png"/></p><figcaption class="caption"></figcaption>
</figure>
<p>Такое правило уже является «логическим или». Синтаксис условия or:</p>
<p>or {триплеты}</p>
<p>or{триплеты}.</p>
<p>Прим — в конце перечислений or обязательно должна стоять точка.</p>
<p>or-ов может быть несколько.</p>
<h2 id="условный-оператор-if">Условный оператор IF</h2>
<p>If -- условный оператор позволяет проверить некоторое условие и в зависимости от результатов проверки выполнить то или иное действие.</p>
<p>Пример:</p>
<figure class="screenshot_with_caption">
<p><img alt="" src="/platform/v5.0/developer_guide/n3/img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.016.png"/></p><figcaption class="caption"></figcaption>
</figure>
<p>Синтаксис: if {условие}</p>
<p>then {выполняется, если условие - true}</p>
<p>else {выполняется, если условие - false}</p>
<h2 id="assertunion">Assert:union</h2>
<p>Еще одна часто используемая функция для работы с запросами — это вызов assert: union true.</p>
<p>Данная функция требуется, когда в запросе нужно объединить несколько результатов выполнения в одну переменную.</p>
<p>Пример:</p>
<p>Предположим, в заявке имеется поле с выбором Руководителя (User1) и заместителя руководителя (User2). Нам требуется объединить эти два значения в вычисляемом атрибуте:</p>
<figure class="screenshot_with_caption">
<p><img alt="" src="/platform/v5.0/developer_guide/n3/img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.017.png"/></p><figcaption class="caption"></figcaption>
</figure>
<p>В строке 8 и 9 мы использовали одноименную переменную для того, чтобы и в нее записалось объединенное значение.</p>
<p>Синтаксис функции:</p>
<div class="highlight"><code><pre><span></span><code><span class="p">(</span></code> <br/><code></code> <br/><code><span class="p">{</span><span class="err">триплет</span><span class="p">}</span></code> <br/><code></code> <br/><code><span class="p">{</span><span class="err">триплет</span><span class="p">}</span></code> <br/><code></code> <br/><code><span class="p">)</span> <span class="nn">assert</span><span class="p">:</span><span class="nt">union</span> <span class="l">true</span><span class="p">.</span></code> <br/></pre></code></div>
<h3 id="итого">Итого</h3>
<p>Мы разобрались в работе Итератора. Умеем применять логические условия для фильтров и так же объединять результаты запросов в одну переменную.</p>
<p>Данные функции являются самыми часто используемыми в запросах.</p>
</article>
</div>
</div>
<a class="md-top md-icon mkdocs_imported_link" data-md-component="top" href="#">
<i class="fa-light fa-arrow-up">&zwnj;<!--icon--></i>
            К началу
          </a>
</main>
</div>
<script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": true, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(()=>{ lightbox.reload(); });
</script></div>