<div class="md-body" data-md-color-accent="indigo" data-md-color-primary="indigo" data-md-color-scheme="comindware" dir="ltr" kb-id="" kb-tags="" kb-title="">
<div class="md-container" data-md-component="container">
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<nav aria-label="Содержание" class="md-nav md-nav--secondary">
<div class="mce-toc">
<h2 class="toc-heading">
      Содержание
      </h2>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#краткое-содержание">
<span class="md-ellipsis">
      Краткое содержание
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#транскрипция">
<span class="md-ellipsis">
      Транскрипция
    </span>
</a>
</li>
</ul>
</div>
</nav>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h3 id="краткое-содержание">Краткое содержание</h3>
<p>В этом подкасте обсуждается переход от традиционных методов хранения данных к более гибким и семантически богатым подходам, таким как онтологии и графовые базы данных, с фокусом на языке запросов N3.</p>
<ul>
<li><strong>Проблема:</strong> Информационная перегрузка и сложность извлечения значимых связей из разрозненных данных (отчеты о продажах, отзывы клиентов, инвентарные списки) с помощью традиционных баз данных.</li>
<li><strong>Онтология:</strong><ul>
<li><strong>Определение:</strong> В IT — это формальная, машиночитаемая «карта» определенной области знаний.</li>
<li><strong>Компоненты:</strong> Онтология описывает:<ol class="colored_numbers_list">
<li><strong>Объекты/Сущности</strong> (существительные, например, "карандаш", "пенал").</li>
<li><strong>Атрибуты/Свойства</strong> (прилагательные, например, цвет, материал, вместимость).</li>
<li><strong>Отношения</strong> (глаголы, например, "содержит").</li>
</ol>
</li>
</ul>
</li>
<li><strong>Графовые базы данных:</strong><ul>
<li><strong>Структура:</strong> Хранят данные в виде <strong>узлов</strong> (сущностей) и <strong>ребер</strong> (отношений между ними), что является естественным представлением онтологических моделей.</li>
<li><strong>Преимущество:</strong> Идеально подходят для семантических запросов, то есть запросов о значении и связях, а не просто о совпадении ключевых слов.</li>
</ul>
</li>
<li><strong>Триплет (SPO):</strong><ul>
<li><strong>Определение:</strong> Фундаментальная, атомарная единица информации в системах, использующих RDF и N3.</li>
<li><strong>Структура:</strong> Состоит из трех частей: <strong>Субъект</strong>, <strong>Предикат</strong>, <strong>Объект</strong>.</li>
<li><strong>Направленность:</strong> Направление отношения (например, "человек владеет машиной", а не наоборот) имеет решающее значение.</li>
</ul>
</li>
<li><strong>Запросы на N3:</strong><ul>
<li><strong>Типы операций:</strong><ol class="colored_numbers_list">
<li><strong>Поиск (Search):</strong> Используется, когда в триплете есть переменные (отмечены знаком <code>?</code>). Возвращает «итератор» — поток всех возможных результатов.</li>
<li><strong>Сопоставление (Match):</strong> Используется, когда все части триплета известны. Проверяет наличие точного факта и возвращает <code>true</code> или <code>false</code>.</li>
</ol>
</li>
<li><strong>Модель выполнения:</strong> Запросы выполняются последовательно, строка за строкой. Если строка возвращает итератор с несколькими значениями, следующая строка выполняется для каждого из этих значений, создавая вложенный цикл.</li>
<li><strong>Золотое правило производительности:</strong> Начинайте запрос с самых строгих и ограничивающих условий, чтобы минимизировать размер первоначального итератора.</li>
</ul>
</li>
<li><strong>Практическое применение N3:</strong><ul>
<li><strong>Вычисляемые атрибуты:</strong> Динамический расчет значений (например, цена с налогом) на лету, без хранения конечного результата.</li>
<li><strong>Фильтры списков:</strong> Динамическое отображение подмножеств данных (например, только активные клиенты).</li>
<li><strong>Управление видимостью UI:</strong> Отображение или скрытие элементов интерфейса в зависимости от состояния данных.</li>
<li><strong>Бизнес-правила и триггеры:</strong> Автоматизация действий в ответ на определенные события или условия в данных.</li>
</ul>
</li>
</ul>
<hr/>
<h3 id="транскрипция">Транскрипция</h3>
<p><strong>00:00</strong> М: Знаешь это чувство, когда ты просто тонешь в статьях, исследовательских заметках, пытаясь...</p>
<p><strong>00:04</strong> ...пытаясь как следует разобраться в информации, но, честно говоря, просто увязаешь во всех этих данных.</p>
<p><strong>00:09</strong> Ж: Да, информационная перегрузка, это реально.</p>
<p><strong>00:11</strong> М: Именно.</p>
<p><strong>00:12</strong> Ж: Да.</p>
<p><strong>00:12</strong> М: Так что сегодня мы предлагаем своего рода короткий путь. Представьте данные о продуктах вашей компании, возможно, они разбросаны повсюду — отчеты о продажах здесь, отзывы клиентов там, списки инвентаря где-то еще.</p>
<p><strong>00:23</strong> Ж: Угу, обычная проблема.</p>
<p><strong>00:25</strong> М: И вы хотите понять не просто, что вы продали, а, возможно, почему продукт популярен в одном месте, а в другом нет. Или как ощущения от одной функции влияют на продажи, скажем, связанных продуктов.</p>
<p><strong>00:36</strong> Ж: Верно, эти сложные, взаимосвязанные вопросы. Традиционные базы данных часто с трудом справляются с подобными вещами.</p>
<p><strong>00:41</strong> М: Это именно то, что мы сегодня будем исследовать.</p>
<p><strong>00:44</strong> Ж: Это точно. И для этого глубокого погружения мы рассмотрели, ну, смесь разных вещей. Несколько фундаментальных текстов по графовым базам данных, исследования по онтологиям, практические руководства по запросам на N3 и несколько действительно проницательных обсуждений тоже. Мы постарались извлечь из всего этого самое важное, вытащить самые ценные самородки для вас.</p>
<p><strong>01:02</strong> М: Абсолютно. Наша миссия на самом деле — это разобраться, как данные структурируются, хранятся...</p>
<p><strong>01:06</strong> Ж: Да.</p>
<p><strong>01:07</strong> М: ...и запрашиваются таким образом, чтобы это отражало те самые реальные взаимосвязи.</p>
<p><strong>01:11</strong> Ж: Чтобы у вас случались те самые моменты "ага!".</p>
<p><strong>01:13</strong> М: Именно, те самые моменты "ага!" о том, как информация связана, даже, знаете, с вашими собственными сложными бизнес-данными.</p>
<p><strong>01:19</strong> Ж: Так с чего начнем?</p>
<p><strong>01:21</strong> М: Хорошо, давай оттолкнемся от идеи определения того, что существует и как вещи связаны между собой. Нам нужно ввести понятие, которое является своего рода основополагающим, как с философской, так и с технологической точки зрения.</p>
<p><strong>01:31</strong> М: Онтология.</p>
<p><strong>01:32</strong> Ж: А, онтология, серьезное слово.</p>
<p><strong>01:34</strong> М: Оно такое. Но оно критически важно для создания интеллектуальных систем. С философской точки зрения, это, знаете ли, учение о бытии, существовании, о том, какие категории реальности существуют, и все в таком духе.</p>
<p><strong>01:43</strong> Ж: И в мире IT мы заимствуем это. В информационных технологиях онтология — это, по сути, формальная карта, карта определенной области или, может быть, даже всего реального мира иногда.</p>
<p><strong>01:53</strong> М: Карта, окей.</p>
<p><strong>01:53</strong> Ж: Да, она описывает вещи в этом мире, их характеристики и, что важно, как они соотносятся друг с другом. Главная цель — получить структурированное, машиночитаемое представление этих знаний.</p>
<p><strong>02:03</strong> М: Машиночитаемое, верно.</p>
<p><strong>02:05</strong> Ж: И в своей основе она обычно распадается на три основные части. Во-первых, сами вещи, мы их называем объектами или сущностями, думайте о них как о существительных.</p>
<p><strong>02:11</strong> М: Окей.</p>
<p><strong>02:13</strong> Ж: Во-вторых, у этих вещей есть характеристики или свойства, атрибуты, как прилагательные, описывающие существительные.</p>
<p><strong>02:18</strong> М: Понял.</p>
<p><strong>02:20</strong> Ж: И, наконец, взаимодействия или отношения, связывающие эти вещи, — глаголы, если хотите.</p>
<p><strong>02:25</strong> М: Существительные, прилагательные, глаголы. Окей. Чтобы сделать это совсем конкретным, давай используем простой пример. Представь карандаш и пенал. Как бы онтология описала это?</p>
<p><strong>02:34</strong> Ж: Отлично. Просто, но работает. Итак, "пенал" и "карандаш" были бы нашими основными классами, нашими типами сущностей. Затем свойства. У пенала может быть, скажем, "материал" — пластик, ткань, и "вместимость" — сколько карандашей он вмещает.</p>
<p><strong>02:46</strong> М: Окей.</p>
<p><strong>02:47</strong> Ж: У карандаша были бы свойства, такие как "цвет", "состояние" — заточен он или тупой, и, возможно, "твердость", знаете, HB, 2B.</p>
<p><strong>02:55</strong> М: Верно, верно.</p>
<p><strong>02:56</strong> Ж: И самая важная часть — это отношение. "Пенал" "содержит" "карандаш".</p>
<p><strong>03:00</strong> М: "Содержит". Глагол.</p>
<p><strong>03:02</strong> Ж: Именно. И что здесь ключевое, это часто отношение "один ко многим", верно? Ваш пенал вмещает много карандашей, но один карандаш обычно находится только в одном пенале в данный момент времени.</p>
<p><strong>03:09</strong> М: Обычно, да.</p>
<p><strong>03:10</strong> Ж: И направление имеет значение. "Пенал" "содержит" "карандаш". Не наоборот. Это кажется очевидным, но правильное определение этого направления жизненно важно, когда вы моделируете вещи формально.</p>
<p><strong>03:22</strong> М: Итак, у нас есть этот концептуальный способ определения отношений с помощью онтологии. Но как мы на самом деле храним это в цифровом виде? Как мы делаем эти связи реальными в компьютерной системе, выходя за рамки простых таблиц?</p>
<p><strong>03:34</strong> М: Здесь все становится по-настоящему интересным для меня.</p>
<p><strong>03:36</strong> Ж: Именно. Вот где на сцену выходят графовые базы данных. Вместо жестких строк и столбцов, как, знаете, в электронной таблице...</p>
<p><strong>03:42</strong> М: Да.</p>
<p><strong>03:43</strong> Ж: ...графовая база данных хранит данные, используя графовые структуры. Узлы и ребра.</p>
<p><strong>03:46</strong> М: Узлы и ребра, верно. Как точки и линии, соединяющие их.</p>
<p><strong>03:49</strong> Ж: Именно. И эта структура естественным образом подходит для того, что мы называем семантическими запросами, — когда мы спрашиваем о значении и отношениях, а не просто ищем совпадение ключевых слов.</p>
<p><strong>03:58</strong> М: Семантические запросы. Окей.</p>
<p><strong>04:00</strong> Ж: У этих баз данных есть два основных компонента. Во-первых, узлы, также называемые вершинами. Это вещи, сущности.</p>
<p><strong>04:06</strong> М: Как продукт или клиент.</p>
<p><strong>04:08</strong> Ж: Это могут быть абстрактные понятия, вроде этих, да. Или конкретные экземпляры, например, "подкаст Deep Dive" или "клиент с ID 12345".</p>
<p><strong>04:15</strong> М: Окей.</p>
<p><strong>04:16</strong> Ж: Во-вторых, у вас есть ребра или отношения. Это связи между узлами.</p>
<p><strong>04:20</strong> М: Линии. Отношения.</p>
<p><strong>04:21</strong> Ж: Верно. И они могут быть направленными, показывая определенный поток, например, "клиент купил продукт", или ненаправленными, если отношение взаимное.</p>
<p><strong>04:28</strong> М: Так что это улавливает ту направленность, о которой мы говорили с пеналом.</p>
<p><strong>04:31</strong> Ж: В совершенстве. Графовые базы данных естественным образом представляют эти онтологические модели. Узлы соответствуют вашим объектам или сущностям, ребра — вашим отношениям.</p>
<p><strong>04:39</strong> М: Звучит очень гибко.</p>
<p><strong>04:41</strong> Ж: Так и есть. Вы можете смоделировать практически любое сложное отношение: социальные сети, цепи поставок, зависимости продуктов, научные данные — вещи, которые являются кошмаром в традиционных таблицах, становятся гораздо более интуитивно понятными.</p>
<p><strong>04:54</strong> М: Я понимаю. Пытаться нарисовать сложные зависимости в электронной таблице звучит ужасно.</p>
<p><strong>04:58</strong> Ж: Так и есть. Графовые базы данных делают эту структуру осмысленной и позволяют делать по ней запросы.</p>
<p><strong>05:02</strong> М: Окей, так графовые базы данных — это большая структура, узлы и ребра. Но что является абсолютно наименьшей частью информации внутри этой структуры? Атом, если хотите.</p>
<p><strong>05:12</strong> Ж: А, хороший вопрос. Фундаментальная единица, особенно в системах, использующих N3 или RDF, — это триплет.</p>
<p><strong>05:17</strong> М: Триплет. Три части.</p>
<p><strong>05:19</strong> Ж: Именно. Это простейшее утверждение факта, которое вы можете сделать. Всегда три существенные части. Субъект — это ресурс, который описывается. Отправная точка отношения, источник стрелки на диаграмме.</p>
<p><strong>05:31</strong> М: Окей, "кто" или "что".</p>
<p><strong>05:32</strong> Ж: Затем предикат. Это свойство или само отношение. Стрелка.</p>
<p><strong>05:36</strong> М: "Как" или "действие".</p>
<p><strong>05:37</strong> Ж: И, наконец, объект. Это значение или ресурс, с которым связан субъект. Пункт назначения стрелки.</p>
<p><strong>05:45</strong> М: Субъект, предикат, объект. SPO.</p>
<p><strong>05:49</strong> Ж: Это он. И, как мы уже говорили, направленность абсолютно критична. "Человек владеет машиной" хранится иначе и означает нечто иное, чем "машина владеет человеком".</p>
<p><strong>05:56</strong> М: Верно. Стрелка указывает в одну сторону.</p>
<p><strong>05:58</strong> Ж: И это диктует, какая часть является субъектом, какая — объектом, и это напрямую влияет на то, как вы должны задавать вопросы, как вы делаете запросы.</p>
<p><strong>06:06</strong> М: Окей, ты упомянула N3 и...</p>
<p><strong>06:07</strong> Ж: Да. RDF. N3, или Notation 3, — это просто способ записи этих триплетов, который довольно компактен и удобочитаем для человека. Это синтаксис для RDF.</p>
<p><strong>06:15</strong> М: RDF — это...</p>
<p><strong>06:16</strong> Ж: Resource Description Framework (Среда Описания Ресурсов). Думайте об этом как о стандартном способе описания информации и связывания ее воедино, особенно в вебе, чтобы машины могли лучше ее понимать. В этих системах все данные, будь то системные вещи, метаданные или фактические данные, которые вы вводите, — все это фундаментально хранится в виде этих триплетов. Это базовый язык. Даже если под капотом может быть стандартный движок базы данных, помогающий с транзакциями и поддержанием порядка.</p>
<p><strong>06:43</strong> М: Окей, так триплет — это атом. Субъект, предикат, объект. Означает ли это, что все сводится к этому? Можно ли представить что-то сложное таким образом?</p>
<p><strong>06:52</strong> Ж: Это очень хороший вопрос. В основном, да. Вам может понадобиться несколько триплетов, чтобы выразить сложную идею, разбив ее на простые факты. Но сама структура триплета может содержать разные виды данных.</p>
<p><strong>07:02</strong> М: Например?</p>
<p><strong>07:03</strong> Ж: Ну, субъект, предикат или объект могут быть квалифицированными именами, QNames. Думайте о них как о сокращениях или указателях на другие концепции или ресурсы, определенные где-то еще в вашей системе, например <code>product.model_number</code>. Они связывают вещи воедино.</p>
<p><strong>07:16</strong> М: Окей, как внутренние ссылки.</p>
<p><strong>07:18</strong> Ж: Именно. Затем у вас есть простые литералы. Это просто прямые значения. Кусок текста, как "синий", число, как "5", истина или ложь, дата, продолжительность. Прямые значения.</p>
<p><strong>07:29</strong> М: Фактические точки данных.</p>
<p><strong>07:30</strong> Ж: Верно. И затем у вас могут быть сложные литералы. Они группируют факты вместе, что полезно для более продвинутых запросов. Здесь есть два основных типа. Формулы, которые вы пишете внутри фигурных скобок. Это набор триплетов, рассматриваемый как единое целое.</p>
<p><strong>07:43</strong> М: Блок фактов.</p>
<p><strong>07:44</strong> Ж: Да. И списки, внутри круглых скобок. Просто упорядоченная последовательность значений или переменных.</p>
<p><strong>07:50</strong> М: Окей, так можно группировать вещи или перечислять их внутри самой структуры триплета.</p>
<p><strong>07:53</strong> Ж: Верно. И это приводит к важному различию: аксиомы против выводимых фактов.</p>
<p><strong>07:58</strong> М: Окей, в чем разница?</p>
<p><strong>07:59</strong> Ж: Аксиомы — это факты, непосредственно хранящиеся в виде триплетов в базе данных. Ваша сырая, записанная информация. "Этот карандаш синий". "Этот пенал вмещает 10 карандашей". Хранится.</p>
<p><strong>08:09</strong> М: Понял. Базовые истины.</p>
<p><strong>08:10</strong> Ж: Выводимые факты, однако, вычисляются на лету. Они используют аксиомы и, возможно, текущую ситуацию, контекст, чтобы вычислить значение. Но это значение не хранится постоянно в базе данных.</p>
<p><strong>08:20</strong> М: А. Так если я изменю какие-то сырые данные, аксиому, выводимый факт обновится мгновенно?</p>
<p><strong>08:26</strong> Ж: Да. Потому что он пересчитывается. Он не сохранен как таковой.</p>
<p><strong>08:29</strong> М: В этом вся сила, их значения вычисляются в тот момент, когда вы их запрашиваете, так что они всегда отражают последние базовые аксиомы.</p>
<p><strong>08:36</strong> М: Это звучит невероятно полезно. Но не вызывает ли это когда-нибудь проблем с производительностью? Если у вас есть очень сложные вычисления для этих выводимых фактов, и базовые данные меняются часто, каков компромисс?</p>
<p><strong>08:46</strong> Ж: Ты затронул критический момент. Да, абсолютно. Хотя это мощно, чрезмерно сложные выводимые факты могут повлиять на производительность, если не быть осторожным.</p>
<p><strong>08:55</strong> М: Верно.</p>
<p><strong>08:56</strong> Ж: Компромисс в том, чтобы либо всегда иметь идеально актуальные, динамически вычисляемые данные, либо, возможно, скорость, которую вы бы получили от предварительного вычисления и хранения значений. Хороший дизайн здесь ключ, делая выводимые факты эффективными, может быть, находя способы пересчитывать только то, что необходимо.</p>
<p><strong>09:11</strong> М: Вероятно, это включает в себя то, как вы их запрашиваете, верно?</p>
<p><strong>09:12</strong> Ж: Точно. Что плавно подводит нас к тому, как на самом деле работают запросы N3.</p>
<p><strong>09:16</strong> М: Окей, да. Мы поняли структуру, триплеты, аксиомы, выводимые факты. Как мы задаем вопросы базе данных? Как работает запрос на N3?</p>
<p><strong>09:25</strong> Ж: Итак, запросы N3 работают непосредственно с теми структурами триплетов, о которых мы говорили. И есть, по сути, два основных типа операций запроса: поиск и сопоставление.</p>
<p><strong>09:34</strong> М: Поиск и сопоставление. Окей.</p>
<p><strong>09:35</strong> Ж: Если одна или несколько частей вашего триплета в запросе являются переменными — вы помечаете переменные вопросительным знаком, например, "субъект, предикат, ?объект" — тогда система выполняет поиск.</p>
<p><strong>09:45</strong> М: Ищет вещи, которые соответствуют шаблону.</p>
<p><strong>09:47</strong> Ж: Именно. Она ищет в базе данных все сохраненные триплеты, которые соответствуют этому шаблону. И что важно, она заполняет эти переменные итераторами.</p>
<p><strong>09:56</strong> М: Итераторы. Что это такое?</p>
<p><strong>09:57</strong> Ж: Думай об итераторе как о потоке результатов. Или, может быть, как о стопке совпадающих файлов или записей. Он не просто дает тебе один ответ. Он дает тебе способ получить доступ ко всем ответам, которые совпали, один за другим.</p>
<p><strong>10:08</strong> М: Окей, так поиск дает потенциально много результатов через итератор. А что такое сопоставление?</p>
<p><strong>10:13</strong> Ж: Сопоставление проще. Это когда все три части вашего триплета в запросе — известные значения, без переменных. Вы спрашиваете: "Существует ли этот конкретный факт?". "Карандаш1, цвет, синий?".</p>
<p><strong>10:23</strong> М: Да или нет.</p>
<p><strong>10:24</strong> Ж: Именно. Система просто проверяет, есть ли этот конкретный триплет в базе данных, и возвращает "истина" или "ложь". Она не возвращает итератор, простое подтверждение.</p>
<p><strong>10:33</strong> М: Понял. Поиск находит вещи, сопоставление подтверждает вещи.</p>
<p><strong>10:37</strong> Ж: В общих чертах, да. Теперь, способ выполнения этих запросов, модель выполнения, действительно важен для понимания производительности. Запросы N3 выполняются последовательно. Сверху вниз, строка за строкой, по вашему скрипту запроса.</p>
<p><strong>10:49</strong> М: Окей, одна строка за другой.</p>
<p><strong>10:50</strong> Ж: Но вот что самое интересное: итеративная обработка. Если строка, триплетный запрос, возвращает итератор с несколькими значениями...</p>
<p><strong>10:58</strong> М: Как из операции поиска.</p>
<p><strong>11:00</strong> Ж: Верно. Тогда следующая строка в вашем скрипте запроса выполняется для каждого значения в этом итераторе.</p>
<p><strong>11:07</strong> М: О, окей, так это... это как бы создает цикл.</p>
<p><strong>11:08</strong> Ж: Это, по сути, создает эффект вложенного цикла. И это оказывает огромное влияние на производительность. Подумай об этом: если твоя первая строка совпадает с миллионом вещей...</p>
<p><strong>11:16</strong> М: ...тогда следующая строка выполняется миллион раз.</p>
<p><strong>11:18</strong> Ж: Именно. Вот почему порядок триплетов в твоем запросе так важен.</p>
<p><strong>11:22</strong> М: А, окей. Так что не стоит начинать с широкого запроса.</p>
<p><strong>11:24</strong> Ж: Абсолютно нет. Ты хочешь начать с самых ограничивающих условий. Сначала найти наименьший возможный набор результатов. Затем выполнить последующие строки для этого меньшего набора.</p>
<p><strong>11:34</strong> М: Так это отличается от SQL, может быть, где оптимизатор мог бы сам определить лучший порядок. Здесь ты контролируешь порядок, и это диктует поток выполнения.</p>
<p><strong>11:42</strong> Ж: Именно. Мы видели проекты, которые испытывали трудности, потому что запрос начинался слишком широко, подтягивая массу ненужных вещей перед фильтрацией. Научиться переворачивать свое мышление о запросах, начинать с узкого, может быть разницей между минутами ожидания и миллисекундами ответа.</p>
<p><strong>11:56</strong> М: Так что запрос на N3 — это буквально хождение по графу, следование по связям.</p>
<p><strong>12:01</strong> Ж: Это отличный способ выразить это, именно так. Он движется от узла к узлу через ребра, предикаты, чтобы извлечь или проверить информацию, которую вы запросили. Он перемещается по тем отношениям, которые мы определили ранее.</p>
<p><strong>12:12</strong> М: Это логично. И ты упоминала какой-то синтаксис.</p>
<p><strong>12:14</strong> Ж: Да, просто для контекста, вы увидите такие вещи, как комментарии, начинающиеся с решетки, префиксы, вроде <code>@prefix</code>, которые являются сокращениями для длинных URI, уникальных идентификаторов. Переменные всегда начинаются с вопросительного знака. Каждое утверждение триплета заканчивается точкой. Блоки формул используют фигурные скобки, а списки — круглые. Это основы.</p>
<p><strong>12:34</strong> М: Окей. Это звучит очень мощно для навигации по сложным структурам данных. Где эти запросы N3 действительно проявляют себя, ну, в практических, повседневных приложениях?</p>
<p><strong>12:43</strong> Ж: О, они используются во многих критически важных местах, особенно там, где данные должны быть динамичными или задействована логика. Огромное применение — это вычисляемые атрибуты.</p>
<p><strong>12:51</strong> М: Как те выводимые факты, о которых мы говорили.</p>
<p><strong>12:53</strong> Ж: Точно так же. Представь снова свой каталог продуктов. Ты хочешь показать общую цену, включая налог. Но налоговые ставки меняются...</p>
<p><strong>12:59</strong> М: Постоянно, да.</p>
<p><strong>13:00</strong> Ж: ...постоянно. Так что вместо того, чтобы хранить общую цену, которая устареет, ты пишешь запрос на N3 как вычисляемый атрибут. Каждый раз, когда кто-то просматривает продукт, этот запрос выполняется, получает базовую цену, получает текущую налоговую ставку, делает расчет и показывает результат.</p>
<p><strong>13:13</strong> М: На лету, никогда не сохраняется.</p>
<p><strong>13:15</strong> Ж: Никогда не сохраняется, всегда актуально. Суперэффективно для вещей, которые меняются, вроде уровней запасов, вычисляемых оценок, финансовых сводок.</p>
<p><strong>13:23</strong> М: Окей, что еще?</p>
<p><strong>13:24</strong> Ж: Фильтры списков. Скажем, у тебя огромный список клиентов, но ты хочешь отобразить только активных на определенном экране. Запрос на N3 действует как фильтр, выясняя, какие ID клиентов соответствуют критерию "активный", и возвращает только эти ID для отображения.</p>
<p><strong>13:39</strong> М: Динамическая фильтрация списков, это логично.</p>
<p><strong>13:41</strong> Ж: Затем есть операции, особенно для управления видимостью. Например, должна ли отображаться кнопка "завершить задачу"? Может быть, только если все ее подзадачи помечены как выполненные. Запрос на N3 проверяет это условие. Если он возвращает "истина", кнопка появляется. Если "ложь", она остается скрытой.</p>
<p><strong>13:57</strong> М: Условные элементы интерфейса на основе состояния данных.</p>
<p><strong>14:00</strong> Ж: Очень умно. Они активно используются в бизнес-правилах, иногда называемых триггерами или сценариями, определяя автоматические действия на основе событий.</p>
<p><strong>14:07</strong> М: Например, если поступает жалоба от клиента, автоматически назначить ее кому-то.</p>
<p><strong>14:11</strong> Ж: Именно. Или, если вычисленный балл удовлетворенности клиента падает ниже трех, автоматически создать задачу для его аккаунт-менеджера, чтобы тот позвонил ему. Запрос на N3 определяет, выполнено ли условие (балл &lt; 3), и может даже извлечь некоторые значения, необходимые для последующих действий.</p>
<p><strong>14:26</strong> М: То есть, для управления автоматизированными рабочими процессами.</p>
<p><strong>14:28</strong> Ж: Верно. И еще одно. Они могут взаимодействовать с глобальными функциями. Это куски кода, возможно, написанные на C# или другом языке, которые живут вне системы N3.</p>
<p><strong>14:37</strong> М: Окей.</p>
<p><strong>14:38</strong> Ж: Запрос на N3 может вызвать одну из этих функций, может быть, для выполнения действительно сложного вычисления, которое неудобно делать на чистом N3, или, может быть, для обращения к внешнему веб-сервису, получения каких-то данных и возвращения их в логику запроса. Это связывает ваши графовые данные с более широкой экосистемой программного обеспечения.</p>
<p><strong>14:54</strong> М: Вау, окей. Это значительно расширяет возможности.</p>
<p><strong>14:57</strong> Ж: Так и есть. И просто к слову, есть пара встроенных предикатов N3, которые вы будете часто видеть, потому что они очень полезны. Один из них — <code>object.find_property</code>.</p>
<p><strong>15:04</strong> М: <code>find_property</code>.</p>
<p><strong>15:05</strong> Ж: Это высокооптимизированный способ получить внутренний ID конкретного атрибута, когда вы знаете его имя или псевдоним. Например, найти "номер_модели" для шаблона продукта. Очень быстрый поиск для элементов схемы.</p>
<p><strong>15:16</strong> М: Верно.</p>
<p><strong>15:17</strong> Ж: Другой — <code>assert.union</code>. Он просто берет результаты из нескольких итераторов, нескольких потоков данных, и объединяет их в один единый поток.</p>
<p><strong>15:25</strong> М: Объединение результатов.</p>
<p><strong>15:26</strong> Ж: Да. И вы можете указать ему, сохранять ли дубликаты (true для union all) или давать только уникальные результаты. Удобно для объединения разных путей поиска.</p>
<p><strong>15:35</strong> М: Окей, это дает очень хорошее представление о том, насколько центральными являются эти запросы N3 для фактического использования графовых данных. Итак, давайте подведем итоги. Вы только что совершили глубокое погружение в моделирование, хранение и запросы к данным, ну, принципиально иным способом.</p>
<p><strong>15:50</strong> М: Мы начали с онтологии, философских корней, но, что более практично, с IT-определения — составления карты объектов, свойств, отношений.</p>
<p><strong>16:00</strong> Ж: Создания этой концептуальной карты.</p>
<p><strong>16:01</strong> М: Затем мы увидели, как графовые базы данных воплощают эту карту в жизнь с помощью узлов и ребер, представляя сущности и их связи напрямую.</p>
<p><strong>16:08</strong> Ж: Естественное соответствие для такого рода моделей.</p>
<p><strong>16:10</strong> М: И затем мы углубились в атомарную единицу — триплет. Субъект-предикат-объект, простейшее утверждение факта.</p>
<p><strong>16:15</strong> Ж: И важность направленности.</p>
<p><strong>16:17</strong> М: Абсолютно. И, наконец, мы разобрали логику запросов N3, поиск против сопоставления, критически важное последовательное и итеративное выполнение, и как они питают все, от вычисляемых значений до бизнес-правил.</p>
<p><strong>16:29</strong> Ж: Вы действительно, я думаю, получили твердое понимание того, как этот подход позволяет вам структурировать и получать доступ к информации уникальным образом. Выходя за рамки традиционных таблиц, чтобы по-настоящему уловить и навигировать по сложным отношениям гораздо более интуитивно.</p>
<p><strong>16:45</strong> М: Это определенно кажется более связанным с тем, как вещи работают в реальном мире, иногда. Что приводит к последней мысли для вас, слушатель. Как мышление в терминах субъектов, предикатов и объектов, этих простых фактов SPO, может изменить ваш подход к решению проблем?</p>
<p><strong>16:58</strong> Ж: Интересный вопрос.</p>
<p><strong>16:59</strong> М: Не только в технологиях, верно? Но и в организации любого сложного набора отношений, может быть, в вашей работе, ваших проектах, даже просто в вашей личной жизни. Подумайте об этом. Как явное определение этих связей, этих предикатов, может открыть новые инсайты для вас?</p>
<p><strong>17:12</strong> Ж: Это может быть ваше семейное древо, планирование проекта...</p>
<p><strong>17:15</strong> М: ...или даже просто организация ваших заметок или цифровых файлов. Сделать эти связи явными — что это может раскрыть?</p>
<p><strong>17:20</strong> Ж: Пища для размышлений.</p>
<p><strong>17:20</strong> М: Определенно. Продолжайте исследовать, продолжайте задавать вопросы и продолжайте совершать эти глубокие погружения в увлекательный мир знаний.</p>
</article>
</div>
</div>
<a class="md-top md-icon mkdocs_imported_link" data-md-component="top" href="#">
<i class="fa-light fa-arrow-up">&zwnj;<!--icon--></i>
            К началу
          </a>
</main>
</div>
<script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": true, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></div>