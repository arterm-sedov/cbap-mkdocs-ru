<div class="md-body" data-md-color-accent="indigo" data-md-color-primary="indigo" data-md-color-scheme="comindware" dir="ltr" kb-id="" kb-tags="" kb-title="">
<div class="md-container" data-md-component="container">
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<nav aria-label="Содержание" class="md-nav md-nav--secondary">
</nav>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<ul>
<li><strong>Цель занятия:</strong> практическое применение конструкций N‑Triples/N3 для реальных сценариев в <strong>Comindware Platform</strong>: проверка существования, фильтрация, агрегирование, объединение данных, работа с процессами/статусами, вызов глобальных функций и экспорт.</li>
<li><strong>Ключевые конструкции и built‑in:</strong></li>
<li><code>once { ... }</code> — ранний выход после первого совпадения (эффективная проверка существования).</li>
<li><code>or { ... }</code> — логическое ИЛИ (возвращает первую успешную ветку, не объединяет множества).</li>
<li><code>if {cond} then {A} else {B}</code> — ветвление; без <code>else</code> дальнейшее выполнение прерывается.</li>
<li><code>from { ... } select ?x -&gt; ?list</code> — сбор значений в список; затем, напр., <code>?list math:sum ?sum</code>.</li>
<li><code>{ ... } assert:count ?n</code> — количество результатов формулы; <code>{ ... } assert:distinct ?v</code> — уникальные значения; <code>{ ... } assert:union true</code> — объединение результатов формул в один итератор.</li>
<li><strong>Типовые примеры:</strong></li>
<li>Проверка наличия магазина в регионе (возврат <code>true</code>/<code>null</code>) — <code>once</code> на первой находке.</li>
<li>Непросроченные задачи — сравнение <code>dueDate</code> с «сейчас»; альтернативно, отрицание и без <code>if</code>.</li>
<li>Накладная: суммы по позициям — <code>from</code> → список → <code>math:sum</code>; счётчик позиций — <code>assert:count</code>.</li>
<li>Уникальные товары в позициях — <code>assert:distinct</code> + <code>assert:count</code>.</li>
<li>Контрагенты накладной (отправитель/получатель и др.) — независимые формулы + <code>assert:union</code>.</li>
<li><strong>Переменные <code>?item</code> и <code>?value</code> по контекстам:</strong></li>
<li>Вычисляемый атрибут: вход <code>?item</code> (ID записи), выход <code>?value</code> (значение).</li>
<li>Фильтр списка: вход отсутствует, выход — <code>?item</code> (ID записей для списка).</li>
<li>Условие операции: вход <code>?item</code>, выход <code>?value</code> (<code>true/false</code>).</li>
<li>Выражение для роли: вход <code>?value</code> (текущий пользователь), выход <code>?item</code> (ID доступных записей).</li>
<li><strong>Итераторы и формулы:</strong> каждый паттерн возвращает перечислитель; внутри формулы происходит перебор с возвратами, снаружи формула даёт единый результат. Для производительности ставьте самые селективные условия выше и используйте <code>once</code> для раннего выхода.</li>
<li><strong>Вычисляемые атрибуты и коллекции:</strong> не хранятся в базе; вычисляются при обращении. Подписываться нужно на изменения исходных данных (триггеры/сценарии), а не на вычисляемые поля.</li>
<li><strong>Глобальные функции и внешние сервисы:</strong> вызов глобальных функций из N‑Triples возможен (в т.ч. C# и обращения к веб‑сервисам). Пример: «сумма прописью» и корректный пересчёт при изменении ставки.</li>
<li><strong>Процессы и статусы:</strong> поиск процесса по записи (через предикаты связи «запись → процесс»), чтение статуса <code>process:status</code> и сравнение с перечислением (напр., <code>process:ActiveStatus</code>). Доступен <code>cmw:parent</code> для родительского процесса; в low‑code могут сохранять <code>processID</code> в поле для дальнейшего использования.</li>
<li><strong>Экспорт:</strong></li>
<li>Лоу‑код смарт‑теги — быстрые подстановки полей.</li>
<li>C#‑скрипт — формирование объекта‑модели и наполнение данными (в т.ч. из справочников); сложные кейсы выполняются через API. Смешение подходов ограничено: смарт‑теги — для лоу‑кода, сложная логика — в C#.</li>
<li><strong>Уведомления и автоматизация:</strong> базовый подход через таймеры в процессах неудобен для изменений задним числом; нужен отдельный механизм онлайн‑настроек событий. Поддержка/«боковые» процессы могут реализовывать напоминания и сбор статистики.</li>
<li><strong>Визуализация и планы:</strong> развитие дашбордов (таблицы и графики), расширение редактора выражений (включая DMN‑таблицы); уточнение терминологии по кейсам/CMMN в публичных материалах.</li>
<li><strong>Практические рекомендации:</strong></li>
<li>Ставьте селективные условия первыми; применяйте <code>once</code> для проверок существования.</li>
<li>Для подсчёта уникальных значений используйте <code>assert:distinct</code> + <code>assert:count</code>.</li>
<li>Внимательно учитывайте контексты <code>?item</code>/<code>?value</code> в разных точках применения.</li>
<li>Объявляйте корректные префиксы (<code>@prefix</code>) и используйте единые алиасы/системные имена.</li>
<li>Для строковых результатов собирайте через <code>from</code> + <code>join</code>/<code>concat</code>.</li>
</ul>
<p>00:00:06
Введение и примеры операторов
• Начало записи и продолжение обсуждения.
• Приведены примеры использования различных операторов.</p>
<p>00:00:35
Проверка наличия магазина в регионе
• Проверка наличия хотя бы одного магазина в заданном регионе.
• Использование итератора для проверки наличия магазина.
• Возврат значения true или false в зависимости от результата проверки.</p>
<p>00:01:34
Работа с переменными и итераторами
• Объяснение работы с переменными, такими как «чек».
• Получение текущего региона и магазинов по нему.
• Проверка совпадения идентификаторов объектов.</p>
<p>00:02:45
Обработка множественных регионов
• Возможность наличия нескольких регионов.
• Итератор переключается на первый найденный магазин.
• Если магазинов нет, итератор переходит к следующему региону.</p>
<p>00:03:40
Выходные значения
• Получение значения true или false в зависимости от наличия магазинов.
• Объяснение работы оператора присваивания.</p>
<p>00:06:15
Пример с задачами
• Сравнение дюдейта задач с текущим временем.
• Возврат непросроченных задач.
• Упрощение кода путём исключения использования if-else.</p>
<p>00:07:58
Работа с накладными и позициями
• Получение позиций накладной и атрибута суммы.
• Сбор суммы в массив.
• Применение функции mass для суммирования массива.</p>
<p>00:10:21
Поиск значений по атрибутам
• Использование идентификаторов объектов и атрибутов для поиска значений.
• Пример поиска значений по системному имени шаблона и атрибута.</p>
<p>00:14:12
Роль зарезервированных слов
• Объяснение использования зарезервированных слов «атом» и «валю».
• Зависимость использования этих слов от точки входа в систему.
• Примеры использования в ролях и на форумах.</p>
<p>00:14:29
Введение в вычисляемые атрибуты
• Вычисляемые атрибуты могут принимать различные значения: true, false, объекты или литералы.
• Пример использования: вычисление количества уникальных продуктов в позициях заказа.</p>
<p>00:14:55
Пример с нефтяной компанией
• Нефтяная компания использует корзину продуктов для разных регионов.
• Один и тот же продукт может быть добавлен в разные позиции заказа.
• Формула извлекает номенклатуру из позиций и формирует итератор.</p>
<p>00:15:55
Применение функции distinct
• Функция distinct удаляет повторяющиеся значения из итератора.
• На выходе итератор содержит только уникальные значения.
• Формула account подсчитывает количество уникальных значений.</p>
<p>00:17:25
Пример с заказом товаров
• Заказ товаров на следующий год: ручки, блокноты, картриджи.
• Группировка заказов по подразделениям.
• Возможность дальнейших вычислений и суммирования.</p>
<p>00:19:01
Работа итератора в формуле
• Итератор работает внутри формулы, переключаясь между строками.
• После выхода за пределы формулы итератор формирует общий результат.
• Пример с подразделением: итератор подсчитывает количество для каждого подразделения.</p>
<p>00:22:13
Формирование строки результатов
• Формирование строки с количеством по подразделениям.
• Использование функций from, join и concat для объединения данных.
• Объединение переменных итератора в одну строку.</p>
<p>00:25:28
Объединение контрагентов
• Объединение грузополучателей, грузоотправителей и получателей в один итератор.
• Формула shift contract объединяет результаты итераций.
• Контрагент используется как переменная для накопления значений.</p>
<p>00:27:13
Задание на сравнение
• Задание: написать запрос, который показывает количество уникальных контрагентов.
• Обсуждение использования платформы для выполнения задания.
• Разъяснение входов и выходов в вычисляемых атрибутах.</p>
<p>00:28:59
Условия отображения операций
• Условия отображения операций зависят от состояния текущей записи.
• Операция «завершить задачу» должна отображаться только для открытых задач.
• Для закрытых задач операция должна быть скрыта.</p>
<p>00:29:49
Ограничения текущих функций
• Текущие функции позволяют выполнять простые операции, аналогичные Excel.
• Необходимы более сложные функции для автоматизации процессов.</p>
<p>00:30:32
Пример автоматизации
• Пример процесса: поиск невыполненных задач и отправка напоминаний пользователям.
• Если напоминания не помогают, копия задачи отправляется руководителю подразделения.</p>
<p>00:31:33
Проблемы с уведомлениями
• Функционал уведомлений требует компромисса между сложностью настройки и удобством использования.
• Текущие решения с таймерами требуют изменения модели процесса при каждом изменении уведомлений.</p>
<p>00:32:56
Необходимость нового механизма
• Требуется отдельный механизм для онлайн-настройки уведомлений без изменения модели процесса.
• Этот механизм должен позволять бизнес-аналитикам и поддержке настраивать события в реальном времени.</p>
<p>00:33:49
Роль поддержки
• Поддержка должна создавать боковые процессы для автоматизации напоминаний и других задач.
• Боковые процессы могут анализировать существующие процессы и выдавать статистику.</p>
<p>00:35:42
Статистика процессов
• Возможность получения статистики по процессам, подразделениям и задержкам.
• Отдельный функционал для сбора и анализа такой статистики.</p>
<p>00:36:37
Проверка статуса процесса
• Проблема проверки статуса процесса: как правильно написать проверку на активность процесса.
• Использование предикатов для сравнения статуса процесса.</p>
<p>00:37:52
Поиск статуса процесса в коде
• Поиск статуса процесса через анализ кода C#.
• Переменная «процесс статус» и её назначение в коде.</p>
<p>00:40:48
Идентификация процесса по шаблону записи
• Идентификация процесса по шаблону записи.
• Связь идентификатора процесса с конкретной записью.
• Использование префикса для идентификации процесса.</p>
<p>00:43:06
Работа с процессами и статусами
• Нахождение ID процесса по заданному объекту.
• Итерация по статусам процессов и вывод активных процессов.
• Возможность использования списка процессов на форуме.</p>
<p>00:44:03
Атрибуты и повторно исполняемые процессы
• Обсуждение атрибутов шаблона записи, связанных с процессом приёма на работу.
• Передача ID процесса в повторно исполняемый процесс.
• Запись ID в поле для использования в лоу-коде.</p>
<p>00:46:50
Префиксы и пространство имён
• Объяснение использования префикса «цмв» для процессов.
• Упоминание пространства доменных имён.</p>
<p>00:47:52
Завершение обсуждения и задания
• Предложение завершить обсуждение.
• Просьба прислать задания и документы для дальнейшего обсуждения.</p>
<p>00:48:59
Аналогия с революционной алгеброй
• Сравнение с революционной алгеброй.
• Вопрос о возможности вызова глобальных функций через NTRI.</p>
<p>00:50:13
Вычисление сумм и глобальные функции
• Пример вычисления сумм прописью.
• Проблема с автоматическим пересчётом вычисляемых полей при изменении ставки.</p>
<p>00:53:07
Вызов глобальных функций
• Возможность вызова глобальных функций через NTRI.
• Примеры использования внешних сервисов.</p>
<p>00:55:17
Подписка на события и вычисляемые атрибуты
• Использование триггеров для подписки на изменения исходных объектов.
• Вычисляемые атрибуты не хранятся в базе данных, их значения вычисляются динамически.</p>
<p>00:57:32
Пересчёт вычисляемых коллекций
• Автопересчёт вычисляемых коллекций при изменении исходных данных.
• Пример с изменением ставки и пересчётом коллекции.</p>
<p>00:58:01
Вычисляемая коллекция и её поля
• Коллекция состоит из полей, которые вытаскивают константы, например, значение оклада и надбавок.
• Вычисляемые поля используются для умножения значений на ставку.
• При выводе на экран или в шаблон вычисляемые поля должны пересчитываться автоматически.</p>
<p>00:58:43
Проблемы с вычисляемыми полями
• При изменении ставки в записи вычисляемые поля не пересчитываются корректно.
• Изменение ставки должно автоматически обновлять все связанные записи.
• Необходимо понять, как правильно вызвать глобальную функцию для пересчёта полей.</p>
<p>01:00:40
Работа с глобальными функциями
• Глобальная функция должна пересчитывать значения при изменении ставки.
• Функция принимает числовой параметр и возвращает строковое значение.
• Для корректного пересчёта нужно настроить вторичное вычисляемое поле с выражением, вызывающим глобальную функцию.</p>
<p>01:04:56
Передача объекта в шаблон
• Вопрос о простом способе передачи существующего объекта в шаблон экспорта.
• Шаблон экспорта должен работать с конкретной записью, а не со списком.
• Необходимо добавить дополнительные поля в шаблон для корректного экспорта.</p>
<p>01:07:19
Механизмы работы с шаблонами
• Существуют два механизма работы с шаблонами: низкокодовый и через C#.
• В C# нужно создать класс для передачи в шаблон, который будет содержать необходимые поля.
• Важно не дублировать все атрибуты шаблона записи, а только необходимые.</p>
<p>01:11:08
Привязка класса к записи
• Класс наполняется значениями из шаблона записи.
• Необходимо правильно привязать класс к записи, чтобы использовать только нужные поля.
• Проблемы с именами полей могут усложнить реализацию задачи.</p>
<p>01:12:19
Обсуждение механизмов работы
• Упоминание о двух механизмах: низкоуровневом и через C#.
• Обсуждение использования скобок и точек в C#.
• Пример использования фигурных скобок в C#.</p>
<p>01:13:48
Проблемы с фигурными скобками
• Сомнения в эффективности использования фигурных скобок в C#.
• Фигурными скобками пользуются для низкоуровневого кода.
• Смарт-теги используются как C#-обрамление для скриптов.</p>
<p>01:14:34
Работа с объектами и мапированием
• Необходимость поиска записей из справочника для мапирования.
• Возможность дополнения объектов и обращения к ним в шаблоне экспорта.
• Сложности в объединении объектов без копирования.</p>
<p>01:16:09
Ограничения низкоуровневого кода
• В C# недоступны некоторые возможности низкоуровневого кода.
• Отключение медленной функции из-за её неэффективности.</p>
<p>01:17:03
Завершение обсуждения
• Предложение провести отдельную сессию для Анатолия.
• Рекомендация задавать вопросы через сайт поддержки.</p>
<p>01:20:16
Состояние документации
• Отставание документации в разработке больших софтовых продуктов.
• Работа над приведением терминологии в порядок перед написанием документации.</p>
<p>01:22:10
Планы по визуализации данных
• Расширение возможностей визуализации данных.
• Добавление таблиц и графиков в дашборды.
• Доработка компонентов для улучшения функциональности.</p>
<p>01:23:10
Аналог DNN
• Разработка аналога DNN без DDI.
• Добавление редактора выражений для работы с таблицами.
• Важность параметров для определения стечения процесса.</p>
<p>01:25:07
Поддержка кейс-менеджмента
• Обсуждение поддержки кейс-менеджмента.
• Различие между кейс-менеджментом и SMMM.
• Необходимость уточнения поддержки кейс-менеджмента в маркетинге.</p>
<p>01:26:04
Завершение встречи
• Тестирование данных перед финальной активацией.
• Проблемы с организацией и генерацией ключей.
• Благодарность участникам и прощание.</p>
</article>
</div>
</div>
<a class="md-top md-icon mkdocs_imported_link" data-md-component="top" href="#">
<i class="fa-light fa-arrow-up">&zwnj;<!--icon--></i>
            К началу
          </a>
</main>
</div>
<script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": true, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></div>