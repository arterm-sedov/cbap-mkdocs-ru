<div class="md-body" data-md-color-accent="indigo" data-md-color-primary="indigo" data-md-color-scheme="comindware" dir="ltr" kb-id="" kb-tags="" kb-title="">
<div class="md-container" data-md-component="container">
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<nav aria-label="Содержание" class="md-nav md-nav--secondary">
<div class="mce-toc">
<h2 class="toc-heading">
      Содержание
      </h2>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#сущности-в-n3-и-графовых-базах-данных">
<span class="md-ellipsis">
      Сущности в N3 и графовых базах данных
    </span>
</a>
</li>
</ul>
</div>
</nav>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<p>--------------------------------------------------------------------------------</p>
<p>N3 Querying and Ontology: A Study Guide</p>
<p>Advanced N3 Querying and Ontology: A Comprehensive Study Guide</p>
<p>This study guide is designed to review your understanding of N3 (Notation3) querying and its underlying ontological concepts, as discussed in the provided source material.</p>
<p>--------------------------------------------------------------------------------</p>
<p>I. Core Concepts of Ontology and Graph Databases</p>
<p>A. Ontology and its Application</p>
<p>- <strong>Definition:</strong> The study of being, existence, and the fundamental categories of reality. In IT, it describes a set of objects, their properties, and relationships.</p>
<p>- <strong>Components:</strong> Objects (entities), Characteristics/Properties (attributes), and Interactions/Relationships (connections).</p>
<p>- <strong>Real-world Analogy:</strong> Explaining concepts like "pencil in a pencil case" using object-oriented principles (classes, properties, relationships).</p>
<p>- <strong>Classes:</strong> Pencil Case, Pencil</p>
<p>- <strong>Properties:</strong> Pencil Case has Material, Capacity; Pencil has Color, Condition (sharp, dull), Hardness.</p>
<p>- <strong>Relationship:</strong> Pencil Case contains Pencil (one-to-many, Pencil can be in 0 or 1 pencil case).</p>
<p>B. Graph Databases</p>
<p>- <strong>Definition:</strong> A database that uses graph structures for semantic queries with nodes, edges, and properties to represent and store data.</p>
<p>- <strong>Components:</strong></p>
<p>- <strong>Nodes (Vertices):</strong> Represent entities or values (e.g., classes, instances, literal values).</p>
<p>- <strong>Edges (Relations):</strong> Represent relationships between nodes (can be directed or undirected).</p>
<p>- <strong>Types of Graphs:</strong> Connected, Isolated, Directed, Undirected, Complete, Planar, Tree-like.</p>
<p>- <strong>Application to Ontology:</strong> Graphs naturally represent ontological models where nodes are objects/classes/instances and edges are relationships.</p>
<p>C. Triplets (N3 and RDF)</p>
<p>- <strong>Definition:</strong> The fundamental unit of data storage in an N3/RDF graph. A triplet consists of three parts: Subject, Predicate, and Object.</p>
<p>- <strong>RDF (Resource Description Framework):</strong> A W3C standard for describing resources, often represented in XML or N3.</p>
<p>- <strong>N3 (Notation3):</strong> A compact and human-readable syntax for RDF, supporting logical expressions.</p>
<p>- <strong>Components of a Triplet:</strong></p>
<p>- <strong>Subject:</strong> The resource being described (the source of the arrow in a graph).</p>
<p>- <strong>Predicate:</strong> The property or relationship (the arrow itself).</p>
<p>- <strong>Object:</strong> The value or resource that the subject is related to (the destination of the arrow).</p>
<p>- <strong>Directionality:</strong> Triplets are inherently directed. The chosen direction (e.g., Person owns Car vs. Car owned_by Person) dictates the subject and object. This is crucial for querying.</p>
<p>- <strong>System and Custom Models:</strong> The platform's core systemic model is fixed and uses specific predicates. Custom models defined by users (e.g., in templates) also create triplets, and their directionality is important for query construction.</p>
<p>D. Data Storage in the N3 Database</p>
<p>- <strong>Storage Mechanism:</strong> All data is stored as triplets, whether it's systemic metadata (e.g., class definitions, property types) or applied data (e.g., records in templates, process instances).</p>
<p>- <strong>N3 Files:</strong> System models are described in .n3 files. Applied data (metadata and instances) are stored in separate files (e.g., data.n3).</p>
<p>- <strong>SQLlite Engine:</strong> Used for transactional aspects, but the core data model and logic for serialization/deserialization between triplets and relational views are custom.</p>
<p>- <strong>Types of Data in Triplets:</strong></p>
<p>- <strong>Qualified Name (QName):</strong> Long URIs representing resources are often shortened with prefixes for readability (e.g., object:findProperty instead of a full HTTP URI). These are used for subjects, predicates, and objects, especially for complex types.</p>
<p>- <strong>Simple Literals:</strong> Direct values like strings, numbers, booleans, dates, durations (e.g., "blue", 5, true).</p>
<p>- <strong>Complex Literals (Formulas and Lists):</strong> Represent collections of facts or ordered sets of values, used in advanced queries. * <strong>Formulas (</strong><strong>{ ... }</strong><strong>):</strong> A set of triplets that are evaluated together. * <strong>Lists (</strong><strong>( ... )</strong><strong>):</strong> An ordered collection of values or variables.</p>
<p>- <strong>Axioms vs. Derived Facts:</strong></p>
<p>- <strong>Axioms:</strong> Directly stored facts (triplets) in the database.</p>
<p>- <strong>Derived Facts:</strong> Facts computed on the fly based on axioms and the current context (e.g., calculated attributes, functions). These are not stored but computed at the moment of access.</p>
<p>--------------------------------------------------------------------------------</p>
<p>II. N3 Query Syntax and Execution</p>
<p>A. Core Syntax Elements</p>
<p>- <strong>Comments (</strong><strong>#</strong><strong>):</strong> Used to add notes.</p>
<p>- <strong>Prefixes (</strong><strong>@prefix</strong><strong>):</strong> Define shortcuts for long URIs, improving readability.</p>
<p>- <strong>Variables (</strong><strong>?</strong><strong>):</strong> Denoted by a question mark followed by an alphanumeric name (e.g., ?item, ?value).</p>
<p>- <strong>Triplet Terminator (</strong><strong>.</strong><strong>):</strong> Every triplet must end with a period.</p>
<p>- <strong>Formula Block (</strong><strong>{ ... }</strong><strong>):</strong> Defines a query block that is executed as a single unit, forming a single iterator result.</p>
<p>- <strong>Lists/Arrays (</strong><strong>( ... )</strong><strong>):</strong> Used to define ordered collections of values.</p>
<p>- <strong>Implicit Subject:</strong> Square brackets ([ ... ]) can implicitly refer to the subject of the previous triplet.</p>
<p>- <strong>Reserved Keywords:</strong> a (for rdf:type - "is an instance of"), is ... of (inverse property).</p>
<p>- <strong>Assignment (</strong><strong>\=</strong><strong>):</strong> Assigns a value from one variable to another.</p>
<p>- <strong>Conditional (</strong><strong>if ... else ...</strong><strong>):</strong> Controls query flow. If the if condition is false and there's no else block, the query stops.</p>
<p>B. Query Execution Model</p>
<p>- <strong>Sequential Execution:</strong> Queries execute top-down, line by line.</p>
<p>- <strong>Iterative Processing:</strong> If a line (triplet) returns an iterator (multiple values), the subsequent lines are executed for each value in that iterator. This creates nested loops.</p>
<p>- <strong>Iterator Scope:</strong> An iterator's scope is confined to the formula/block it was created in. Once the block finishes, the iterator's result is passed as a single value (or a collection) to the next level.</p>
<p>- <strong>Optimization:</strong> The order of triplets matters significantly for performance. Queries should start with the most restrictive conditions to minimize the size of initial iterators.</p>
<p>- <strong>Match vs. Search:</strong></p>
<p>- <strong>Search (unknowns):</strong> When one or more parts of a triplet are variables, the system searches the database for matching facts and populates the variables with iterators. * S P ?O: Find all objects for a given subject and predicate. * ?S P O: Find all subjects for a given predicate and object. * ?S P ?O: Find all subject-object pairs for a given predicate.</p>
<p>- <strong>Match (all known):</strong> When all parts of a triplet are known values, the system checks for the existence of that exact fact in the database, returning true or false. This does not return an iterator.</p>
<p>C. Common Query Patterns and Operators</p>
<p>- <strong>findProperty</strong><strong>:</strong> A built-in predicate to retrieve the ID of an attribute given its template alias and attribute alias (e.g., ("TemplateAlias" "AttributeAlias") object:findProperty ?attributeId). This always returns a single ID and is highly optimized.</p>
<p>- <strong>assert:union</strong><strong>:</strong> Combines the results of multiple iterators into a single iterator. assert:union true performs a union all (duplicates included), assert:union false would imply distinct (though distinct is a separate function).</p>
<p>- <strong>ones</strong><strong>:</strong> Executes a query and returns only the first successful result, stopping further iteration once a match is found.</p>
<p>- <strong>or</strong><strong>:</strong> Evaluates multiple conditions and returns true if any of them are met. It stops once the first successful condition is found.</p>
<p>- <strong>Built-in Functions (e.g.,</strong> <strong>math:sum</strong><strong>,</strong> <strong>time:dayOfWeek</strong><strong>):</strong> Special predicates that perform calculations in memory rather than querying the database. They can operate on lists of values.</p>
<p>- <strong>value</strong> <strong>and</strong> <strong>item</strong><strong>:</strong> Reserved keywords for output and input parameters, respectively, in expressions. value stores the output, item refers to the current object in context.</p>
<p>--------------------------------------------------------------------------------</p>
<p>II. Application Contexts for N3 Queries</p>
<p>A. Calculated Attributes</p>
<p>- Defined on a record template to compute a value dynamically.</p>
<p>- item is the input (current object ID), value is the output.</p>
<p>- Calculated on-the-fly whenever the attribute is requested; values are not stored in the database.</p>
<p>B. List Filters</p>
<p>- Used to filter records displayed in a list.</p>
<p>- item is the output (IDs of records to display). There's no input item here as it filters from a potential global set.</p>
<p>C. Operations (Conditional Display)</p>
<p>- Used to show or hide operations based on conditions (e.g., a "Complete Task" button).</p>
<p>- item is the input (current record ID), value is true (show) or false (hide).</p>
<p>D. Business Rules (Triggers/Scenarios)</p>
<p>- Define actions that execute based on specific events (e.g., a field change).</p>
<p>- Can involve complex N3 queries to determine conditions or derive values for actions.</p>
<p>E. Global Functions</p>
<p>- External functions (e.g., written in C#) that can be invoked from N3 queries.</p>
<p>- Allow for code reusability and complex computations not directly expressible in N3.</p>
<p>- Can retrieve data from external services or perform custom logic.</p>
<p>--------------------------------------------------------------------------------</p>
<p>III. Key Distinctions and Best Practices</p>
<p>- <strong>Calculated Attributes vs. Stored Data:</strong> Calculated attributes are always computed on demand and are never stored in the database. Changes to underlying stored data will trigger re-calculation.</p>
<p>- <strong>Query Optimization:</strong> Begin with highly selective conditions to reduce the size of iterators early in the query execution.</p>
<p>- <strong>Understanding Iterators:</strong> The nested loop nature of N3 query execution means careful structuring can lead to significant performance differences.</p>
<p>- <strong>Contextual Variables:</strong> item, value, current user, now are context-dependent and reserved.</p>
<p>--------------------------------------------------------------------------------</p>
<p>Quiz: N3 Querying and Ontology</p>
<p><strong>Instructions:</strong> Answer each question in 2-3 sentences.</p>
<p>1. What is the primary purpose of an "ontology" in the context of information technologies, as described in the source material?</p>
<p>2. How does a "graph database" fundamentally represent data, and what are its two main components?</p>
<p>3. Explain what a "triplet" is and identify its three essential parts in the N3/RDF model.</p>
<p>4. Why is the "directionality" of a relationship important when defining triplets in the N3 database?</p>
<p>5. What is the difference between an "axiom" and a "derived fact" in the N3 database, and how does this relate to "calculated attributes"?</p>
<p>6. Describe the role of "variables" (e.g., ?item, ?value) in N3 queries.</p>
<p>7. How does the sequential and iterative execution model of N3 queries impact their performance?</p>
<p>8. Explain the function of the assert:union operator in N3 queries.</p>
<p>9. In which context would you use the object:findProperty predicate, and what does it return?</p>
<p>10. What is the significance of the if ... else ... conditional structure in N3 queries regarding query execution flow?</p>
<p>--------------------------------------------------------------------------------</p>
<p>Quiz Answer Key</p>
<p>1. In IT, an ontology is a formal description of a set of objects, their properties, and the relationships between them. Its primary purpose is to provide a structured and machine-readable representation of a specific domain or the real world.</p>
<p>2. A graph database fundamentally represents data using graph structures. Its two main components are "nodes" (representing entities or values) and "edges" (representing relationships between these nodes).</p>
<p>3. A triplet is the fundamental unit of data in the N3/RDF model, representing a single fact. Its three essential parts are the Subject (the resource being described), the Predicate (the property or relationship), and the Object (the value or resource related to the subject).</p>
<p>4. Directionality is crucial because it explicitly defines the flow of a relationship (e.g., Person owns Car). This direction determines which element is the Subject and which is the Object in a triplet, which in turn dictates how queries must be structured to retrieve specific information.</p>
<p>5. An axiom is a fact directly stored in the N3 database, while a derived fact is computed on the fly based on axioms and the query context. Calculated attributes are examples of derived facts; their values are computed at the moment of access and are not permanently stored in the database.</p>
<p>6. Variables in N3 queries (prefixed with ?) are used to represent unknown values that the query aims to discover. When a query is executed, these variables are populated with matching data from the database, often in the form of iterators.</p>
<p>7. The sequential and iterative execution model means queries run line-by-line, and if a line generates multiple results (an iterator), subsequent lines are re-executed for each of those results. This can significantly impact performance, making query optimization (e.g., filtering early) essential.</p>
<p>8. The assert:union operator combines the results of multiple query blocks or iterators into a single, unified iterator. assert:union true specifically indicates a "union all" operation, meaning duplicate values will be included in the combined result.</p>
<p>9. The object:findProperty predicate is used to retrieve the unique identifier (ID) of an attribute within a specific template. It takes the template's system name and the attribute's system name as arguments and returns the corresponding Property ID.</p>
<p>10. The if ... else ... conditional structure controls the flow of query execution. If the if condition evaluates to false and there is no else block, the query's execution path is effectively terminated, and no further triplets in that branch will be processed.</p>
<p>--------------------------------------------------------------------------------</p>
<p>III. Essay Questions</p>
<p>1. Discuss the relationship between <strong>ontology</strong>, <strong>graph databases</strong>, and <strong>triplets</strong> in the context of the provided platform. Explain how these abstract concepts translate into the practical storage and retrieval of both system metadata and user-defined data.</p>
<p>2. Analyze the <strong>N3 query execution model</strong>, focusing on the concepts of "sequential execution," "iterative processing," and "iterator scope." How do these principles influence the design and optimization of N3 queries for performance, and what are common pitfalls developers might encounter?</p>
<p>3. Compare and contrast the different <strong>types of data (</strong><strong>Qualified Names</strong><strong>,</strong> <strong>Simple Literals</strong><strong>,</strong> <strong>Complex Literals</strong><strong>)</strong> that can be represented as objects in N3 triplets. Provide examples from the source material to illustrate their practical application in defining system properties and user data.</p>
<p>4. Elaborate on the role and practical application of <strong>N3 queries in various platform contexts</strong> such as "calculated attributes," "list filters," and "operation display conditions." For each context, describe how item and value are used and how the query's output is interpreted by the system.</p>
<p>5. Discuss the advantages and disadvantages of <strong>derived facts</strong> (e.g., calculated attributes) as opposed to storing data directly in the database, from both a performance and data integrity perspective. How does the N3 platform's architecture support this distinction, and when would you choose one approach over the other?</p>
<p>--------------------------------------------------------------------------------</p>
<p>IV. Glossary of Key Terms</p>
<p>- <strong>Axiom:</strong> A fact that is directly stored in the N3 database.</p>
<p>- <strong>assert:union</strong><strong>:</strong> An N3 operator used to combine the results of multiple iterators into a single, unified iterator (similar to SQL's UNION ALL when true is specified).</p>
<p>- <strong>Built-in Predicates:</strong> Special N3 predicates (functions) that perform calculations or operations in memory rather than querying the database (e.g., math:sum, time:dayOfWeek).</p>
<p>- <strong>Calculated Attribute:</strong> A property whose value is not stored but is computed dynamically on demand using an N3 query.</p>
<p>- <strong>Complex Literal:</strong> An N3 object type representing structured data, such as a formula (a set of triplets) or a list (an ordered collection of values).</p>
<p>- <strong>Derived Fact:</strong> A fact that is not directly stored but is computed or inferred based on existing axioms and the current query context.</p>
<p>- <strong>Directionality (of relationships):</strong> The specific orientation of a relationship in a graph or triplet, indicating the flow from subject to object.</p>
<p>- <strong>Edge:</strong> A connection between two nodes in a graph, representing a relationship.</p>
<p>- <strong>Formula (</strong><strong>{ ... }</strong><strong>):</strong> A type of complex literal in N3 representing a block of one or more triplets that are executed as a single unit.</p>
<p>- <strong>Graph Database:</strong> A database that uses nodes and edges to represent and store data, emphasizing relationships between entities.</p>
<p>- <strong>Implicit Subject (</strong><strong>[ ... ]</strong><strong>):</strong> An N3 syntax construct where square brackets can be used to refer to the subject of the immediately preceding triplet, simplifying query syntax.</p>
<p>- <strong>item</strong><strong>:</strong> A reserved variable in N3 queries, typically representing the ID of the current object or record in the context of the query (e.g., in calculated attributes or operations).</p>
<p>- <strong>Iterator:</strong> A mechanism in N3 query execution that provides a sequence of values, allowing subsequent query lines to be processed for each value in the sequence.</p>
<p>- <strong>List (</strong><strong>( ... )</strong><strong>):</strong> A type of complex literal in N3 representing an ordered collection of values or variables.</p>
<p>- <strong>Match (Query Type):</strong> An N3 query where all parts of a triplet (subject, predicate, object) are known, and the system verifies the existence of that exact fact (returns true or false).</p>
<p>- <strong>Node:</strong> A fundamental component of a graph, representing an entity or a value.</p>
<p>- <strong>N3 (Notation3):</strong> A human-readable and compact syntax for writing RDF (Resource Description Framework) data and logical expressions.</p>
<p>- <strong>object:findProperty</strong><strong>:</strong> A specific built-in predicate used to retrieve the system ID of an attribute, given the system names of its containing template and the attribute itself.</p>
<p>- <strong>ones</strong><strong>:</strong> An N3 operator that, when applied to a query block, ensures only the <em>first</em> successful result is returned, stopping further iteration.</p>
<p>- <strong>Ontology:</strong> In IT, a formal description of a set of objects, their properties, and relationships within a specific domain or the real world.</p>
<p>- <strong>or</strong><strong>:</strong> An N3 operator used in conditional expressions; it evaluates multiple conditions and returns true if any of them are met, stopping evaluation at the first true condition.</p>
<p>- <strong>Predicate:</strong> The part of a triplet that describes the relationship or property between the subject and the object.</p>
<p>- <strong>Prefix (</strong><strong>@prefix</strong><strong>):</strong> A shorthand notation used in N3 to represent long URIs, improving query readability.</p>
<p>- <strong>Qualified Name (QName):</strong> A long, unique identifier (URI) for a resource, often abbreviated with a prefix in N3 for convenience.</p>
<p>- <strong>RDF (Resource Description Framework):</strong> A W3C standard for describing resources on the web, often used as the underlying data model for graph databases.</p>
<p>- <strong>Search (Query Type):</strong> An N3 query where one or more parts of a triplet are variables (?), prompting the system to search the database for matching facts and return iterators.</p>
<p>- <strong>Simple Literal:</strong> A direct value in an N3 triplet, such as a string, number, boolean, or date, that does not represent a complex object or resource.</p>
<p>- <strong>Subject:</strong> The part of a triplet that represents the resource or entity being described.</p>
<p>- <strong>Triplet:</strong> The fundamental data unit in an N3/RDF graph, consisting of a subject, predicate, and object.</p>
<p>- <strong>value</strong><strong>:</strong> A reserved variable in N3 queries, typically representing the output parameter where the result of a query or calculation is stored.</p>
<p>- <strong>Variable (</strong><strong>?</strong><strong>):</strong> A placeholder in N3 queries that represents an unknown value to be retrieved or evaluated (e.g., ?user, ?status).</p>
<h2 id="сущности-в-n3-и-графовых-базах-данных">Сущности в N3 и графовых базах данных</h2>
<p>N3 queries are used in various platform contexts to define and control dynamic behaviors, ranging from calculating attribute values to filtering lists and setting conditions for operations [1, 2]. These applications leverage N3's ability to interact directly with the triplet-based data storage model [2, 3].</p>
<p>Here are the primary application contexts for N3 queries:</p>
<p>- <strong>Calculated Attributes</strong></p>
<p>- <strong>Purpose:</strong> N3 queries are used to <strong>dynamically compute a value for a record template</strong> [1, 4]. These values are <strong>not stored in the database</strong>; instead, they are calculated on-the-fly whenever the attribute is requested [1, 3-7]. This means that changes to underlying stored data will automatically trigger a recalculation [1, 6, 8, 9].</p>
<p>- <strong>Variables:</strong> In this context, item serves as the <strong>input parameter</strong>, representing the ID of the current object or record [1, 4, 6, 7, 10-13], while value is the <strong>output parameter</strong> where the computed attribute value is stored [1, 4, 6, 10-13]. For example, a calculated attribute might compute item's title [14].</p>
<p>- <strong>Mechanism:</strong> When the system requests such an attribute, it understands it's a function, supplies the object's ID as item, executes the N3 query, and returns the computed value [7, 13].</p>
<p>- <strong>List Filters</strong></p>
<p>- <strong>Purpose:</strong> N3 queries are employed to <strong>filter records displayed in a list</strong>, determining which records should appear based on specified conditions [1, 15].</p>
<p>- <strong>Variables:</strong> For list filters, item is the <strong>output parameter</strong>, representing the IDs of the records that should be displayed [1, 12, 15]. Unlike calculated attributes, there is no input item in this context, as the query filters from a potential global set of records [1, 12, 15].</p>
<p>- <strong>Mechanism:</strong> The query outputs a set of item IDs, which the system then uses to populate the list view [16, 17].</p>
<p>- <strong>Operations (Conditional Display)</strong></p>
<p>- <strong>Purpose:</strong> N3 queries control the <strong>conditional display or hiding of operations</strong> (e.g., buttons like "Complete Task") based on certain conditions [1, 15]. This allows for dynamic user interface adjustments [16].</p>
<p>- <strong>Variables:</strong> item is the <strong>input parameter</strong>, representing the ID of the current record on which the operation might be performed [1, 15, 16]. The value is the <strong>output parameter</strong>, which is set to true (to show the operation) or false (to hide it) [1, 15, 16].</p>
<p>- <strong>Mechanism:</strong> If the N3 query's if condition is false and there is no else block, the query execution path for that operation is terminated, effectively preventing its display [1, 18, 19].</p>
<p>- <strong>Business Rules (Triggers/Scenarios)</strong></p>
<p>- <strong>Purpose:</strong> N3 queries define <strong>actions that execute based on specific events</strong>, such as a field change on a record [1, 15, 20]. These rules can involve complex N3 queries to determine the conditions under which an action should occur or to derive values for subsequent actions [1, 15].</p>
<p>- <strong>Evolution:</strong> These were formerly known as "triggers" and are now being considered for renaming to "scenarios" to better reflect their broader business context [20].</p>
<p>- <strong>Interaction:</strong> They can be used to perform various actions, like sending reminders if tasks are overdue or notifying supervisors [16, 21].</p>
<p>- <strong>Global Functions</strong></p>
<p>- <strong>Purpose:</strong> N3 queries can <strong>invoke external functions</strong>, often written in languages like C# [1, 6, 22]. This mechanism promotes code reusability and allows for complex computations or data retrieval from external services that are not directly expressible within N3 itself [1, 6, 22, 23].</p>
<p>- <strong>Flexibility:</strong> Global functions enable integration with external data sources and custom logic, enhancing the platform's capabilities beyond native N3 operations [1, 6, 23]. This means a global function can calculate something like "sum in words" for a financial value, ensuring consistency even if the underlying numbers change [22, 23].</p>
<p>In essence, N3 queries serve as the core language for defining dynamic behavior and calculations within the platform, enabling a flexible and context-aware system where information is processed on-demand based on the underlying graph data [1-3].</p>
<p>--------------------------------------------------------------------------------</p>
<p>Запросы N3: Принципы и Оптимизация</p>
<p><strong>Исполнение запросов N3</strong> является центральным механизмом взаимодействия с данными в графовой базе данных, построенной на триплетах. Запросы N3 служат основным языком для определения динамического поведения и вычислений на платформе, обеспечивая гибкую и контекстно-зависимую обработку информации [1, 2].</p>
<p>Основные Принципы Запросов N3</p>
<p>1. <strong>Операции над триплетами</strong> [3-12]: Запросы N3 работают непосредственно со структурами триплетов, которые являются фундаментальной единицей хранения данных в базе [3-12]. Каждый триплет состоит из <strong>Субъекта</strong>, <strong>Предиката</strong> и <strong>Объекта</strong> [3-10, 13-18].</p>
<p>2. <strong>Направленность</strong> [3-6, 13, 15-23]: Направленность связей имеет решающее значение в триплетах, поскольку она явно определяет поток отношений (например, "Человек владеет Автомобилем" отличается от "Автомобиль принадлежит Человеку") [3-6, 13, 15-23]. Это направление диктует, какой элемент служит Субъектом, а какой — Объектом, что крайне важно для структурирования запросов N3 [3-6, 13, 15-23].</p>
<p>3. <strong>Переменные</strong> [3, 9, 10, 24-28]: Переменные обозначаются вопросительным знаком (например, ?S, ?P, ?O) и представляют неизвестные значения, которые запрос должен обнаружить [3, 9, 10, 24-28]. Когда часть триплета является переменной, система выполняет <strong>поиск</strong> в базе данных, чтобы найти совпадающие факты и заполнить переменные <strong>итераторами</strong> (последовательностями значений) [3, 5, 6, 8, 9, 11, 12, 29].</p>
<p>4. <strong>Поиск (Search) против Сопоставления (Match)</strong> [3, 5, 6, 8, 9, 11, 12, 29]:</p>
<p>- <strong>Поиск (Search)</strong>: Используется, когда одна или несколько частей триплета являются переменными. Система находит факты, соответствующие известным частям, и возвращает итератор результатов [3, 5, 6, 8, 9, 11, 12, 29].</p>
<p>- <strong>Сопоставление (Match)</strong>: Происходит, когда все части триплета являются известными значениями. Система просто проверяет наличие этого точного факта в базе данных, возвращая true или false без итератора [3, 5, 6, 8, 9, 11, 12, 29]. Это часто используется для валидации или условной логики [3].</p>
<p>Модель Выполнения Запросов N3</p>
<p>Выполнение запросов N3 следует определенной модели [9, 11, 12, 29-31]:</p>
<p>- <strong>Последовательное выполнение</strong>: Запросы выполняются сверху вниз, строка за строкой [9, 11, 12, 29-31].</p>
<p>- <strong>Итеративная обработка</strong>: Если строка (триплет) возвращает итератор (несколько значений), последующие строки <strong>повторно выполняются для каждого значения</strong> в этом итераторе [9, 11, 12, 29-31]. Это создает поведение, похожее на вложенные циклы, означающее, что механизм запросов "проходит" по графу от узла к узлу через ребра (предикаты) [9, 30, 31].</p>
<p>- <strong>Область действия итератора</strong>: Область действия итератора ограничена формулой/блоком, в котором он был создан [9, 11, 12, 29-31]. После завершения блока результат итератора передается как одно значение (или коллекция) на следующий уровень [9, 11, 12, 29-31].</p>
<p>Оптимизация Запросов</p>
<p>Последовательный и итеративный характер выполнения запросов N3 <strong>значительно влияет на производительность</strong> [9, 11, 12, 25, 29, 30]. Для оптимизации запросов крайне важно начинать с <strong>наиболее ограничивающих условий</strong>, чтобы минимизировать размер начальных итераторов [9, 11, 12, 16, 18, 25, 29, 30, 32-35]. Это часто означает "переворачивание" структуры запроса по сравнению с традиционными реляционными базами данных [9, 11, 12, 25, 29, 30, 33]. Начиная с высокоселективных условий, уменьшается количество итераций, необходимых для последующих триплетов [30].</p>
<p>Контекстные Переменные</p>
<p>В различных контекстах запросов N3 используются зарезервированные переменные, такие как item и value [9, 25-28, 32, 34-40]:</p>
<p>- <strong>item</strong>: Обычно представляет собой ID текущего объекта или записи в контексте запроса (например, в вычисляемых атрибутах или операциях) [9, 25-28, 32, 34-38, 41-45].</p>
<p>- <strong>value</strong>: Представляет выходной параметр, куда записывается вычисленное значение атрибута или результат запроса [9, 25-28, 32, 34-45]. Его ожидаемый тип может варьироваться в зависимости от контекста (например, логическое значение для операций, ID для фильтров списков или литерал для вычисляемых атрибутов) [25].</p>
<p>Встроенные Предикаты и Операторы</p>
<p>N3 предоставляет специализированные предикаты и операторы, которые также влияют на выполнение запросов:</p>
<p>- <strong>object:findProperty</strong>: Встроенный предикат для получения ID атрибута по его псевдониму шаблона и псевдониму атрибута [16, 18, 36, 38-40, 46, 47]. Он всегда возвращает один ID и высоко оптимизирован [36, 38-40, 46, 47].</p>
<p>- <strong>assert:union</strong>: Объединяет результаты нескольких итераторов в один [16, 18, 36, 38-40, 46-48]. При использовании assert:union true выполняется операция "union all", включающая дубликаты [16, 18, 36, 38-40, 46-48].</p>
<p>- <strong>ones</strong>: Выполняет запрос и возвращает только первый успешный результат, останавливая дальнейшую итерацию после нахождения совпадения [36, 38-40, 46, 47].</p>
<p>- <strong>or</strong>: Оценивает несколько условий и возвращает true, если любое из них выполняется, останавливаясь после первого успешного условия [36, 38-40, 46, 47].</p>
<p>- <strong>Встроенные функции</strong>: Специальные предикаты (например, math:sum, time:dayOfWeek), которые выполняют вычисления в памяти, а не запрашивают базу данных [36, 38-40, 46, 47]. Они могут работать со списками значений [36, 46].</p>
<p>--------------------------------------------------------------------------------</p>
<p>Онтология в Информационных Технологиях и Базах Данных</p>
<p><strong>Онтология в информационных технологиях (ИТ)</strong> является фундаментальной концепцией для структурирования и понимания данных в графовых базах данных, особенно в контексте семантических запросов [1-7].</p>
<p>Определение Онтологии в ИТ</p>
<p>В области информационных технологий <strong>онтология</strong> формально описывается как <strong>набор объектов, их свойств и взаимосвязей между ними</strong> [1, 2, 4-18]. Её основная цель — предоставить <strong>структурированное и машиночитаемое представление конкретной предметной области или реального мира</strong> [1, 2, 4-9, 11-18]. Философски, онтология занимается изучением бытия, существования и фундаментальных категорий реальности [1, 2, 4, 6, 7, 19, 20].</p>
<p>Ключевые Компоненты Онтологической Модели</p>
<p>Онтологическая модель состоит из трёх основных компонентов [1, 4, 6, 7, 9]:</p>
<p>- <strong>Объекты (сущности)</strong>: Это основные элементы или "вещи", которые описываются, например, "Пенал" или "Карандаш" [1, 4, 6, 7, 9, 21].</p>
<p>- <strong>Характеристики/Свойства (атрибуты)</strong>: Определяют качества или атрибуты объектов, такие как "Материал" и "Вместимость" для "Пенала", или "Цвет", "Состояние" и "Твердость" для "Карандаша" [1, 4, 6, 7, 9, 21].</p>
<p>- <strong>Взаимодействия/Отношения (связи)</strong>: Определяют, как объекты связаны друг с другом, например, "Пенал содержит Карандаш" [1, 4, 6, 7, 9, 21].</p>
<p>Пример "Пенал содержит Карандаш" иллюстрирует отношение "один-ко-многим", где пенал может содержать несколько карандашей, но карандаш может находиться в одном или ни одном пенале [1, 4, 6, 7, 21, 22]. Эта связь показывает, что пенал обладает свойством вмещать карандаши [1, 7, 22].</p>
<p>Применение в Графовых Базах Данных</p>
<p><strong>Графовые базы данных естественным образом представляют онтологические модели</strong> [1, 5, 7, 11-14, 16, 22-27]. В этом контексте:</p>
<p>- <strong>Узлы (вершины)</strong> обычно представляют <strong>объекты, классы или экземпляры</strong>, определенные в онтологии [1, 5, 7, 13, 14, 16, 22, 25-29]. Например, "Человек" и "Автомобиль" могут быть узлами, представляющими классы, а "Иван Иванович" и "автомобиль Volvo" – узлами, представляющими конкретные экземпляры [1, 5, 7, 13, 14, 16, 22, 25-29].</p>
<p>- <strong>Ребра (отношения)</strong> представляют <strong>взаимосвязи</strong> между этими узлами [1, 5, 7, 13, 14, 16, 22, 25-28]. Например, "владеет" будет ребром, соединяющим узел "Человек" с узлом "Автомобиль" [1, 5, 7, 13, 14, 16, 22, 25-28].</p>
<p>Графовые базы данных поддерживают различные типы графов, включая направленные и ненаправленные, что отражает характер отношений в онтологии [1, 7, 16, 23, 25, 27]. Такая структура делает их особенно подходящими для семантических запросов, которые фокусируются на смысле и связях между точками данных [1, 5, 7, 12, 14, 16, 23, 25-27, 30].</p>
<p>Связь с Триплетами (N3 и RDF)</p>
<p>Онтологическая модель напрямую трансформируется в фундаментальную единицу хранения данных в графовой базе данных N3/RDF: <strong>триплет</strong> [1, 5, 7, 14, 19, 23, 31-42].</p>
<p>- Триплет состоит из трёх частей: <strong>Субъект</strong>, <strong>Предикат</strong> и <strong>Объект</strong> [1, 7, 15, 17, 23, 33, 34, 36, 37, 39, 43, 44]. Эта структура напрямую отражает онтологическое утверждение: Субъект — это описываемая сущность, Предикат — её свойство или отношение, а Объект — это значение или связанная сущность [1, 7, 15, 17, 23, 33, 34, 36, 37, 39, 43].</p>
<p>- <strong>Направленность является решающим аспектом триплетов</strong>; она явно определяет поток отношения (например, "Человек владеет Автомобилем" отличается от "Автомобиль принадлежит Человеку") [1, 7, 15, 17, 23, 24, 31, 33, 34, 37, 39, 43-46]. Эта направленность определяет, какой элемент является Субъектом, а какой Объектом, что крайне важно для структурирования запросов [1, 7, 15, 17, 23, 24, 31, 33, 34, 37, 39, 43-46].</p>
<p>Хранение Данных и Системные Модели</p>
<p><strong>Все данные в базе данных N3</strong>, включая <strong>системные метаданные</strong> (определения классов, свойств и отношений) и <strong>пользовательские данные</strong> (экземпляры и записи), <strong>хранятся исключительно в виде триплетных фактов</strong> [1, 5, 7, 14, 24, 31, 32, 35, 38, 40, 47-54].</p>
<p>- Системные модели обычно описываются в файлах с расширением .n3 [5, 7, 10, 14, 24, 31, 32, 35, 38, 40, 48, 53], тогда как прикладные данные хранятся в отдельных файлах, таких как data.n3 [5, 7, 14, 24, 31, 32, 35, 38, 40, 48, 53].</p>
<p>- Основная системная модель платформы является фиксированной и использует определенные предикаты, однако пользовательские модели также создают триплеты, и их направленность важна для построения запросов [24, 31, 37, 39].</p>
<p>- Хотя платформа использует движок SQLite для транзакционных операций, её <strong>основная модель данных и логика сериализации/десериализации</strong> между триплетами и реляционными представлениями <strong>разработаны индивидуально</strong> и запатентованы [1, 5, 7, 14, 19, 24, 32, 35, 38, 40, 48, 53, 55]. Такой подход считается ключевым нововведением, обеспечивающим высокую скорость и уникальные принципы обработки данных [48, 53, 56].</p>
<p>- Понимание того, как эти базовые факты структурированы в базе данных N3, является <strong>фундаментальным для создания эффективных N3-запросов</strong> [1, 7, 14, 31, 55].</p>
<p>--------------------------------------------------------------------------------</p>
<p>Графовые базы данных: Основы и онтологии</p>
<p><strong>Базы данных графов</strong> представляют собой специализированный тип баз данных, который использует <strong>графовые структуры</strong> для хранения и представления данных [1-6]. Этот подход особенно хорошо подходит для <strong>семантических запросов</strong>, которые фокусируются на значении и взаимосвязях между точками данных [1-3, 5].</p>
<p>Основные компоненты Графовых Баз Данных</p>
<p>Графовая база данных фундаментально представляет данные с использованием двух основных компонентов:</p>
<p>- <strong>Узлы (вершины)</strong>: Представляют собой сущности или значения. Это могут быть абстрактные концепции, такие как "Пенал" или "Карандаш", или конкретные экземпляры, например, "Иван Иванович" или "автомобиль Volvo" [4-9].</p>
<p>- <strong>Ребра (отношения)</strong>: Представляют <strong>взаимосвязи</strong> между узлами. Ребра могут быть направленными или ненаправленными, обозначая связи, такие как "Пенал содержит Карандаш" или "Человек владеет Автомобилем" [4-9].</p>
<p>Графовые базы данных могут поддерживать различные типы графов, включая связанные, изолированные, направленные, ненаправленные, полные, планарные и древовидные [4-6, 10].</p>
<p>Применение к Онтологии</p>
<p>Графовые базы данных <strong>естественно представляют онтологические модели</strong> [2-6, 8, 10-13]. В информационных технологиях <strong>онтология</strong> формально описывает набор объектов, их свойств и взаимосвязей между ними [2, 3, 5, 8, 11-16]. В такой модели узлы обычно представляют объекты, классы или экземпляры, а ребра — отношения между ними [4-6, 8, 10-13]. Например, "Человек" и "Автомобиль" могут быть узлами, а "владеет" — ребром, соединяющим их [4-6, 8, 10-13].</p>
<p>Взаимосвязь с Триплетами (N3 и RDF)</p>
<p>Онтологическая модель напрямую преобразуется в <strong>фундаментальную единицу хранения данных</strong> в графовой базе данных N3/RDF: <strong>триплет</strong> [3, 5, 12, 13, 17-25].</p>
<p>- Триплет состоит из трех основных частей: <strong>Субъект</strong>, <strong>Предикат</strong> и <strong>Объект</strong> [5, 12, 13, 18, 19, 21-28]. Субъект — это описываемый ресурс (источник стрелки), Предикат — свойство или отношение (сама стрелка), а Объект — значение или ресурс, к которому относится субъект (назначение стрелки) [5, 12, 13, 18, 19, 21-28]. Например, в утверждении "Человек владеет Автомобилем", "Человек" — субъект, "владеет" — предикат, "Автомобиль" — объект [23, 26, 28].</p>
<p>- <strong>Направленность является важнейшим аспектом триплетов</strong> [5, 12, 13, 19, 21, 22, 24, 25, 27, 29-33]. Она явно определяет поток отношения (например, "Человек владеет Автомобилем" отличается от "Автомобиль принадлежит Человеку"), что имеет решающее значение для структурирования запросов N3 [5, 12, 13, 19, 21, 22, 24, 25, 27, 29-33].</p>
<p>Хранение данных и их представление в Триплетах</p>
<p>Все данные в базе данных N3, включая <strong>системные метаданные</strong> (определения классов, свойств и отношений) и <strong>пользовательские данные</strong> (экземпляры и записи), хранятся исключительно в виде этих триплетных фактов [5, 12, 13, 20, 26, 31, 34-39].</p>
<p>- Системные модели обычно описываются в файлах .n3, в то время как прикладные данные хранятся в отдельных файлах, таких как data.n3 [5, 13, 20, 31, 34-40].</p>
<p>- Хотя платформа использует движок SQLite для транзакционных операций, её <strong>основная модель данных и логика сериализации/десериализации</strong> между триплетами и реляционными представлениями являются <strong>собственной разработкой</strong> [5, 12, 13, 20, 31, 34, 36-41]. Этот подход считается ключевым нововведением, обеспечивающим скорость и уникальные принципы обработки данных [40].</p>
<p>Данные в триплетах могут быть представлены в нескольких формах [5, 37, 38, 42-46]:</p>
<p>- <strong>Квалифицированные имена (QName)</strong>: Сокращенные формы длинных URI, используемые для представления ресурсов [5, 37, 38, 42-46].</p>
<p>- <strong>Простые литералы (Simple Literals)</strong>: Прямые, атомарные значения, такие как строки, числа, булевы значения, даты или длительности [5, 37, 38, 42-46].</p>
<p>- <strong>Сложные литералы (Complex Literals)</strong>: Представляют собой коллекции фактов или упорядоченные наборы значений, используемые в расширенных запросах, включая <strong>Формулы (</strong><strong>{...}</strong><strong>)</strong> и <strong>Списки (</strong><strong>(...)</strong><strong>)</strong> [5, 37, 38, 42-46].</p>
<p>Различаются также два типа фактов [5, 37, 38, 42, 44-50]:</p>
<p>- <strong>Аксиомы (Axioms)</strong>: Факты, которые <strong>непосредственно хранятся</strong> в базе данных в виде триплетов [5, 37, 38, 42, 44-50].</p>
<p>- <strong>Выводимые факты (Derived Facts)</strong>: Вычисляются на лету на основе аксиом и текущего контекста (например, <strong>вычисляемые атрибуты</strong>) и <strong>не хранятся</strong> в базе данных [5, 37, 38, 42, 44-50]. Это гарантирует, что они всегда отражают самые актуальные базовые данные [42, 47, 50-52].</p>
<p>Взаимодействие Триплетов с N3-запросами</p>
<p><strong>N3-запросы</strong> оперируют непосредственно этими триплетными структурами [3, 5, 27, 31, 53-57].</p>
<p>- Когда части триплета в запросе являются <strong>переменными</strong> (например, ?S P ?O), система выполняет <strong>поиск (search)</strong> в базе данных для нахождения соответствующих фактов и заполняет переменные <strong>итераторами</strong> (последовательностями значений) [5, 27, 53-55, 57-59].</p>
<p>- Если <strong>все части триплета являются известными значениями</strong>, система выполняет <strong>сопоставление (match)</strong> для проверки существования этого точного факта в базе данных, возвращая true или false [5, 27, 53-55, 57-59]. Эта операция не возвращает итератор [5, 27, 53-55, 57-59].</p>
<p>Выполнение N3-запросов следует <strong>последовательной и итеративной модели</strong>: запросы выполняются сверху вниз, строка за строкой [55, 57, 59-63]. Если строка возвращает итератор (несколько значений), последующие строки выполняются для каждого значения в этом итераторе, создавая поведение, подобное вложенным циклам [55, 57, 59-63]. Это означает, что N3-запрос эффективно "проходит" граф, перемещаясь от одного узла к другому через ребра (предикаты) [3, 5, 55, 61, 64].</p>
<p><strong>Порядок триплетов существенно влияет на производительность</strong> [5, 52, 55, 57, 59, 60, 62, 65-70]. Запросы должны начинаться с <strong>наиболее ограничивающих условий</strong>, чтобы минимизировать размер начальных итераторов, тем самым сокращая количество итераций для последующих триплетов [5, 52, 55, 57, 59, 60, 62, 66-70].</p>
<p>--------------------------------------------------------------------------------</p>
<p>Модель Триплетов в Базах Данных N3/RDF</p>
<p>Модель Триплетов является <strong>фундаментальной единицей хранения данных</strong> в графовых базах данных N3/RDF [1-18]. Эти атомарные строительные блоки имеют решающее значение для захвата фактов и взаимосвязей, обеспечивая всеобъемлющее семантическое представление данных и эффективное выполнение запросов [4, 8, 9, 11, 15, 17, 18].</p>
<p>Компоненты Триплета</p>
<p>Каждый триплет состоит из трех неотъемлемых частей [1-3, 5, 8-10, 12-21]:</p>
<p>- <strong>Субъект (Subject)</strong>: Представляет ресурс, который описывается, и действует как <strong>источник стрелки</strong> в графовой визуализации [1-3, 5, 8-10, 12-21].</p>
<p>- <strong>Предикат (Predicate)</strong>: Обозначает <strong>свойство или отношение</strong> между субъектом и объектом, обычно изображаемое как <strong>сама стрелка</strong> в графе [1-3, 5, 8-10, 12-21].</p>
<p>- <strong>Объект (Object)</strong>: Является значением или ресурсом, с которым связан субъект, образуя <strong>пункт назначения стрелки</strong> [1-3, 5, 8-10, 12-21].</p>
<p>Например, в утверждении "Человек владеет Автомобилем", "Человек" является субъектом, "владеет" — предикатом, а "Автомобиль" — объектом [5, 13, 15, 17, 21].</p>
<p>Направленность Триплетов</p>
<p><strong>Направленность является важнейшим аспектом триплетов</strong> [1-3, 9, 10, 12-14, 16-28]. Она явно определяет поток отношения, делая утверждения типа "Человек владеет Автомобилем" отличными от "Автомобиль принадлежит Человеку" [1-3, 9, 10, 12-14, 16-19, 21, 22, 24, 28]. Эта внутренняя направленность определяет, какой элемент служит Субъектом, а какой — Объектом, что крайне важно для структурирования N3-запросов для получения конкретной информации [1-3, 7, 9, 10, 12-14, 16-29].</p>
<p>Хранение данных и их представление в Триплетах</p>
<p>Все данные в базе данных N3, включая <strong>системные метаданные</strong> (определения классов, свойств и отношений) и <strong>пользовательские данные</strong> (экземпляры и записи), хранятся исключительно в виде этих триплетных фактов [1, 2, 5, 6, 11, 13, 17, 22-25, 27, 29-43]. Системные модели обычно описываются в файлах .n3, в то время как прикладные данные (метаданные и экземпляры) хранятся в отдельных файлах, таких как data.n3 [1, 2, 6, 11, 17, 22-24, 27, 32, 39, 41-43]. Хотя платформа использует движок SQLite для транзакционных операций, ее основная модель данных и логика сериализации/десериализации между триплетами и реляционными представлениями являются <strong>собственной разработкой</strong> [1, 2, 6, 7, 11, 13, 17, 22-24, 27, 30, 32, 33, 39, 41-44]. Такой подход считается ключевым нововведением, обеспечивающим скорость и уникальные принципы обработки данных [33, 45].</p>
<p>Данные в триплетах могут быть представлены в нескольких формах для их субъекта, предиката или объекта [1, 2, 17, 23, 25, 31, 32, 34, 36, 38, 40-43, 46]:</p>
<p>- <strong>Квалифицированные имена (QName)</strong>: Сокращенные формы длинных URI (Uniform Resource Identifiers), используемые для представления ресурсов, особенно для сложных типов [1-3, 5, 17, 22, 23, 25, 26, 31, 32, 34, 36, 38, 40-43, 46, 47]. Например, object:findProperty — это QName, где object является префиксом для более длинного URI [2, 19, 36, 48, 49].</p>
<p>- <strong>Простые литералы (Simple Literals)</strong>: Прямые, атомарные значения, такие как строки ("blue"), числа (5), булевы значения (true), даты или длительности [1, 2, 17, 19, 23-25, 31, 32, 34, 36, 38, 40-43, 46, 47, 50].</p>
<p>- <strong>Сложные литералы (Complex Literals)</strong>: Представляют собой коллекции фактов или упорядоченные наборы значений, используемые в расширенных запросах [1, 2, 17, 21, 23, 25, 31, 32, 34, 36, 38, 40-43, 46, 51].</p>
<p>- <strong>Формулы (</strong><strong>{...}</strong><strong>)</strong>: Набор триплетов, которые оцениваются вместе как единое целое [1-3, 6, 17, 21, 23, 25, 31, 32, 34, 36, 38, 40-43, 46, 51-56].</p>
<p>- <strong>Списки (</strong><strong>(...)</strong><strong>)</strong>: Упорядоченная коллекция значений или переменных [1-3, 17, 21, 23, 25, 31, 32, 34, 36, 38, 40-43, 46, 51, 52, 54-56].</p>
<p>Аксиомы и Выводимые Факты</p>
<p>В базе данных N3 различаются два типа фактов [1-3, 17, 19, 23, 25, 31-34, 36, 38, 40, 42, 43, 46, 57-70]:</p>
<p>- <strong>Аксиомы (Axioms)</strong>: Факты, которые <strong>непосредственно хранятся</strong> в базе данных в виде триплетов [1, 2, 17, 23, 25, 31-34, 36, 38, 40, 42, 43, 46, 57-59, 62, 63, 65-70]. Они представляют собой постоянно хранимые данные [40, 57].</p>
<p>- <strong>Выводимые факты (Derived Facts)</strong>: Вычисляются на лету на основе аксиом и текущего контекста (например, <strong>вычисляемые атрибуты</strong>) и <strong>не хранятся</strong> в базе данных [1-3, 17, 19, 23, 25, 31-34, 36, 38, 40, 42, 43, 46, 57-72]. Вычисляемые атрибуты, например, всегда рассчитываются по запросу, гарантируя, что они всегда отражают самые актуальные базовые данные [1-3, 19, 32, 33, 36, 38, 40, 42, 43, 52, 57-65, 67-76]. Это означает, что изменения в исходных хранимых данных автоматически вызовут пересчет выводимых фактов при доступе к ним [1, 3, 52, 62, 67, 72, 73].</p>
<p>Взаимодействие Триплетов с N3-запросами</p>
<p>N3-запросы оперируют непосредственно этими триплетными структурами [1, 2, 6, 7, 9, 17, 32, 41, 54, 56, 59]. Синтаксические элементы языка, такие как терминатор триплета (.), блоки формул ({...}) и списки ((...)), являются фундаментальными для определения и структурирования триплетов в запросах [6, 9, 52, 54-56, 77].</p>
<p>- Когда части триплета в запросе являются <strong>переменными</strong> (например, ?S P ?O), система выполняет <strong>поиск (search)</strong> в базе данных для нахождения соответствующих фактов и заполняет переменные <strong>итераторами</strong> (последовательностями значений) [1, 2, 6, 9, 17, 19, 20, 22, 24, 30, 31, 34, 41, 52, 57, 78-82].</p>
<p>- Если <strong>все части триплета являются известными значениями</strong>, система выполняет <strong>сопоставление (match)</strong> для проверки существования этого точного факта в базе данных, возвращая true или false [1, 2, 6, 9, 17, 20, 22, 24, 30, 34, 41, 57, 73, 78, 79, 81-83]. Эта операция не возвращает итератор [2, 6, 20, 22, 34, 79, 81, 82].</p>
<p>Понимание структуры и направленности триплетов является фундаментальным для построения эффективных N3-запросов, поскольку способ хранения данных напрямую влияет на то, как информация может быть извлечена и обработана [2, 7, 12, 17, 18, 22, 23, 26, 41, 58]. Последовательная и итеративная модель выполнения N3-запросов означает, что <strong>порядок триплетов существенно влияет на производительность</strong> [1, 3-7, 9, 17, 19, 22, 27, 31, 36, 41, 59, 62, 64, 65, 67, 68, 73, 77-79, 81, 82, 84-86]. Запросы должны начинаться с <strong>наиболее ограничивающих условий</strong>, чтобы минимизировать размер начальных итераторов [1, 3, 6, 7, 17, 22, 26, 31, 36, 38, 41, 59, 62, 64, 65, 67, 68, 73, 77-79, 81, 82, 86, 87].</p>
<p>--------------------------------------------------------------------------------</p>
<p>Язык запросов N3: Основы и применение</p>
<p><strong>Запросы N3</strong> – это <strong>язык, используемый для взаимодействия с данными, хранящимися в графовой базе данных N3/RDF</strong>, которая представляет всю информацию в виде <strong>триплетов</strong> [1-4]. Это мощный инструмент для семантических запросов, позволяющий пользователям определять и извлекать сложные взаимосвязи и факты [1, 2].</p>
<p>Основные принципы запросов N3</p>
<p>1. <strong>Операции с триплетами</strong>: Запросы N3 оперируют непосредственно <strong>структурами триплетов</strong>, которые составляют фундаментальную единицу хранения данных в базе данных [1, 5-8]. Триплет состоит из <strong>субъекта</strong>, <strong>предиката</strong> и <strong>объекта</strong> [1, 3, 6, 8-10].</p>
<p>2. <strong>Направленность</strong>: <strong>Направленность связей</strong> имеет решающее значение в триплетах, прямо влияя на то, как должны быть структурированы запросы [1, 3, 6, 8, 10-16]. Например, "Человек владеет Автомобилем" отличается от "Автомобиль принадлежит Человеку", и это направление определяет, какой элемент служит субъектом, а какой – объектом [1, 3, 8, 10-16].</p>
<p>3. <strong>Переменные</strong>: <strong>Переменные</strong> обозначаются знаком вопроса (например, ?S, ?P, ?O) и представляют собой неизвестные значения, которые запрос стремится обнаружить [1, 4, 17-20]. Когда части триплета являются переменными, система выполняет <strong>поиск</strong> в базе данных для нахождения соответствующих фактов и заполняет переменные <strong>итераторами</strong> (последовательностями значений) [1, 5-8, 18, 21-24].</p>
<p>4. <strong>Соответствие (Match) против Поиска (Search)</strong>:</p>
<p>- <strong>Поиск (Search)</strong>: Используется, когда одна или несколько частей триплета являются переменными. Система находит факты, соответствующие известным частям, и возвращает итератор результатов [1, 5-8, 22-24].</p>
<p>- <strong>Соответствие (Match)</strong>: Происходит, когда все части триплета являются известными значениями. Система просто проверяет наличие этого точного факта в базе данных, возвращая true или false без итератора [1, 5-8, 21-24]. Это часто используется для проверки или условной логики.</p>
<p>Синтаксис и структура запросов N3</p>
<p>Запросы N3 используют определённый синтаксис для определения триплетов и логических выражений [4, 17, 19, 20, 25]:</p>
<p>- <strong>Терминатор триплета (</strong><strong>.</strong><strong>):</strong> Каждый триплет должен заканчиваться точкой [4, 17, 19, 20, 25].</p>
<p>- <strong>Блоки формул (</strong><strong>{...}</strong><strong>):</strong> Определяют блок запроса, который выполняется как единое целое, формируя один результат итератора [4, 17, 19, 20, 25-28]. Они имеют решающее значение для группировки операций [25].</p>
<p>- <strong>Списки (</strong><strong>(...)</strong><strong>):</strong> Используются для определения упорядоченных коллекций значений или переменных [4, 17, 19, 20, 25-28]. Могут использоваться для передачи нескольких аргументов встроенным функциям [25, 29, 30].</p>
<p>- <strong>Префиксы (</strong><strong>@prefix</strong><strong>):</strong> Определяют сокращения для длинных URI (Uniform Resource Identifiers), улучшая читаемость [4, 17, 19, 20, 25].</p>
<p>- <strong>Комментарии (</strong><strong>#</strong><strong>):</strong> Используются для добавления заметок в запросе [4, 17, 19, 20, 25].</p>
<p>- <strong>Неявный субъект (</strong><strong>[...]</strong><strong>):</strong> Квадратные скобки могут неявно ссылаться на субъект предыдущего триплета, упрощая синтаксис [4, 17, 19, 20, 25].</p>
<p>- <strong>Зарезервированные ключевые слова:</strong> a (для rdf:type — "является экземпляром"), is ... of (обратное свойство) [4, 17, 19, 20, 25].</p>
<p>- <strong>Присваивание (</strong><strong>\=</strong><strong>):</strong> Присваивает значение одной переменной другой [4, 17, 19, 20, 25].</p>
<p>- <strong>Условный оператор (</strong><strong>if ... else ...</strong><strong>):</strong> Управляет потоком запроса. Если условие if ложно и нет блока else, выполнение запроса останавливается [4, 17, 19, 20, 25, 31]. Если блок else отсутствует, а условие if не выполняется, выполнение запроса прекращается [2, 17, 32].</p>
<p>Модель выполнения запросов N3</p>
<p>Выполнение запросов N3 следует чёткой модели [7, 23, 24, 33, 34]:</p>
<p>- <strong>Последовательное выполнение:</strong> Запросы выполняются сверху вниз, строка за строкой [7, 23, 24, 33, 34].</p>
<p>- <strong>Итеративная обработка:</strong> Если строка (триплет) возвращает итератор (несколько значений), последующие строки выполняются для каждого значения в этом итераторе [7, 23, 24, 33, 34]. Это создаёт поведение вложенного цикла, означающее, что механизм запросов "проходит" граф от узла к узлу через рёбра (предикаты) [7, 22-24, 33, 34].</p>
<p>- <strong>Область видимости итератора:</strong> Область видимости итератора ограничена формулой/блоком, в котором он был создан. Как только блок завершается, результат итератора передаётся как одно значение (или коллекция) на следующий уровень [7, 23, 24, 33, 34].</p>
<p>- <strong>Оптимизация производительности:</strong> <strong>Порядок триплетов значительно влияет на производительность</strong> [7, 8, 22-24, 33, 35-40]. Запросы должны начинаться с <strong>наиболее ограничивающих условий</strong>, чтобы минимизировать размер начальных итераторов, а не следовать традиционной для реляционных баз данных схеме "FROM-WHERE" [7, 8, 22-24, 33, 35-40]. Начинать с высокоселективных условий сокращает количество итераций, необходимых для последующих триплетов [7, 8, 22-24, 33, 38-40].</p>
<p>Общие шаблоны запросов и операторы</p>
<p>- <strong>object:findProperty</strong>: Встроенный предикат, используемый для получения ID атрибута по его псевдониму шаблона и псевдониму атрибута (например, ("TemplateAlias" "AttributeAlias") object:findProperty ?attributeId) [29, 30, 41-46]. Он высоко оптимизирован, поскольку всегда возвращает один ID [29, 30, 41-44].</p>
<p>- <strong>assert:union</strong>: Объединяет результаты нескольких итераторов в один итератор [29, 30, 41-47]. assert:union true выполняет операцию "union all", включая дубликаты [29, 30, 41-47].</p>
<p>- <strong>ones</strong>: Выполняет запрос и возвращает только первый успешный результат, останавливая дальнейшую итерацию после нахождения соответствия [29, 30, 41-44].</p>
<p>- <strong>or</strong>: Оценивает несколько условий и возвращает true, если любое из них выполняется, останавливаясь после нахождения первого успешного условия [29, 30, 41-44].</p>
<p>- <strong>Встроенные функции</strong>: Специальные предикаты (например, math:sum, time:dayOfWeek), которые выполняют вычисления в памяти, а не запрашивают базу данных [29, 30, 41-44]. Они могут работать со списками значений [29, 30].</p>
<p>- <strong>item</strong> <strong>и</strong> <strong>value</strong>: Зарезервированные ключевые слова для входных и выходных параметров, соответственно, в выражениях [18, 29, 30, 36, 41, 43, 44]. item обычно представляет ID текущего объекта/записи, тогда как value хранит выходные данные запроса [18, 29, 30, 36, 41, 43, 44]. Их конкретные значения могут варьироваться в зависимости от контекста применения запроса [36, 41].</p>
<p>Представление и хранение данных для запросов N3</p>
<p>Все данные в базе данных N3, включая системные метаданные и пользовательские данные, хранятся в виде триплетов [8, 26-28, 48-59]. Эти данные могут принимать несколько форм в рамках триплета [26-28, 48, 51, 52, 54, 58]:</p>
<p>- <strong>Квалифицированное имя (QName)</strong>: Сокращённые формы длинных URI, используемые для субъектов, предикатов и объектов, особенно для сложных типов [26-28, 48, 51, 52, 54, 58].</p>
<p>- <strong>Простые литералы</strong>: Прямые, атомарные значения, такие как строки, числа, булевы значения, даты или длительности [26-28, 48, 51, 52, 54, 58].</p>
<p>- <strong>Комплексные литералы</strong>: Представляют коллекции фактов или упорядоченные наборы значений, используемые в расширенных запросах, а именно <strong>Формулы (</strong><strong>{...}</strong><strong>)</strong> и <strong>Списки (</strong><strong>(...)</strong><strong>)</strong> [26-28, 48, 51, 52, 54, 58].</p>
<p>- <strong>Аксиомы против производных фактов</strong>:</p>
<p>- <strong>Аксиомы</strong> – это факты, напрямую хранящиеся в базе данных в виде триплетов [26-28, 45, 46, 48, 51, 54, 58, 60, 61].</p>
<p>- <strong>Производные факты</strong> вычисляются на лету на основе аксиом и текущего контекста (например, вычисляемые атрибуты) и <strong>не хранятся</strong> в базе данных [26-28, 37, 39, 40, 45, 46, 48, 51, 54, 58, 60, 61]. Это гарантирует, что они всегда отражают самые актуальные базовые данные [26-28, 37, 39, 40, 48, 51, 58, 60, 61].</p>
<p>Контексты применения запросов N3</p>
<p>Запросы N3 используются в различных функциях платформы для определения динамического поведения [31, 32, 62-68]:</p>
<p>- <strong>Вычисляемые атрибуты</strong>: Вычисляют значения динамически для шаблона записи; они не хранятся, но рассчитываются на лету при запросе [31, 32, 37, 39, 40, 61-65, 67]. item является входным параметром (ID текущего объекта), а value – выходным параметром [31, 32, 62-65, 67].</p>
<p>- <strong>Фильтры списков</strong>: Фильтруют записи, отображаемые в списке [31, 32, 62-64, 66, 67]. item является выходным параметром (ID записей для отображения), при этом нет входного item, так как запрос фильтрует из потенциально глобального набора записей [31, 32, 62-64, 66, 67].</p>
<p>- <strong>Операции (Условное отображение)</strong>: Управляют отображением или скрытием операций (например, кнопок типа "Завершить задачу") на основе условий [31, 32, 62-64, 66, 68]. item является входным параметром (ID текущей записи), а value – выходным параметром, устанавливаемым в true (для отображения) или false (для скрытия) [31, 32, 62-64, 66, 68].</p>
<p>- <strong>Бизнес-правила (Триггеры/Сценарии)</strong>: Определяют действия, которые выполняются на основе определённых событий (например, изменение поля), часто с использованием сложных запросов N3 для определения условий или вывода значений для последующих действий [31, 32, 62-64, 66, 68]. Ранее они назывались "триггерами", и в настоящее время рассматривается возможность переименования их в "сценарии" для лучшего отражения их более широкого бизнес-контекста [6, 32].</p>
<p>- <strong>Глобальные функции</strong>: Внешние функции (например, написанные на C#) могут вызываться из запросов N3 для выполнения сложных вычислений или получения данных из внешних сервисов, которые не могут быть выражены непосредственно в N3 [31, 32, 62-64, 66, 68]. Это способствует повторному использованию кода [25, 32, 36, 42].</p>
<p>По сути, запросы N3 служат основным языком для определения динамического поведения и вычислений на платформе, обеспечивая гибкую и контекстно-зависимую систему, где информация обрабатывается по требованию на основе базовых графовых данных [69, 70]. Разработка среды для запросов N3 постоянно улучшается, разрабатываются новые компиляторы и редакторы для обеспечения лучшей подсветки ошибок и помощи в коде [71].</p>
<p>--------------------------------------------------------------------------------</p>
<p>N3 Query Applications and Dynamic Behaviors</p>
<p>N3 queries are used in various platform contexts to define and control dynamic behaviors, ranging from calculating attribute values to filtering lists and setting conditions for operations [1, 2]. These applications leverage N3's ability to interact directly with the triplet-based data storage model [2, 3].</p>
<p>Here are the primary application contexts for N3 queries:</p>
<p>- <strong>Calculated Attributes</strong></p>
<p>- <strong>Purpose:</strong> N3 queries are used to <strong>dynamically compute a value for a record template</strong> [1, 4]. These values are <strong>not stored in the database</strong>; instead, they are calculated on-the-fly whenever the attribute is requested [1, 3-7]. This means that changes to underlying stored data will automatically trigger a recalculation [1, 6, 8, 9].</p>
<p>- <strong>Variables:</strong> In this context, item serves as the <strong>input parameter</strong>, representing the ID of the current object or record [1, 4, 6, 7, 10-13], while value is the <strong>output parameter</strong> where the computed attribute value is stored [1, 4, 6, 10-13]. For example, a calculated attribute might compute item's title [14].</p>
<p>- <strong>Mechanism:</strong> When the system requests such an attribute, it understands it's a function, supplies the object's ID as item, executes the N3 query, and returns the computed value [7, 13].</p>
<p>- <strong>List Filters</strong></p>
<p>- <strong>Purpose:</strong> N3 queries are employed to <strong>filter records displayed in a list</strong>, determining which records should appear based on specified conditions [1, 15].</p>
<p>- <strong>Variables:</strong> For list filters, item is the <strong>output parameter</strong>, representing the IDs of the records that should be displayed [1, 12, 15]. Unlike calculated attributes, there is no input item in this context, as the query filters from a potential global set of records [1, 12, 15].</p>
<p>- <strong>Mechanism:</strong> The query outputs a set of item IDs, which the system then uses to populate the list view [16, 17].</p>
<p>- <strong>Operations (Conditional Display)</strong></p>
<p>- <strong>Purpose:</strong> N3 queries control the <strong>conditional display or hiding of operations</strong> (e.g., buttons like "Complete Task") based on certain conditions [1, 15]. This allows for dynamic user interface adjustments [16].</p>
<p>- <strong>Variables:</strong> item is the <strong>input parameter</strong>, representing the ID of the current record on which the operation might be performed [1, 15, 16]. The value is the <strong>output parameter</strong>, which is set to true (to show the operation) or false (to hide it) [1, 15, 16].</p>
<p>- <strong>Mechanism:</strong> If the N3 query's if condition is false and there is no else block, the query execution path for that operation is terminated, effectively preventing its display [1, 18, 19].</p>
<p>- <strong>Business Rules (Triggers/Scenarios)</strong></p>
<p>- <strong>Purpose:</strong> N3 queries define <strong>actions that execute based on specific events</strong>, such as a field change on a record [1, 15, 20]. These rules can involve complex N3 queries to determine the conditions under which an action should occur or to derive values for subsequent actions [1, 15].</p>
<p>- <strong>Evolution:</strong> These were formerly known as "triggers" and are now being considered for renaming to "scenarios" to better reflect their broader business context [20].</p>
<p>- <strong>Interaction:</strong> They can be used to perform various actions, like sending reminders if tasks are overdue or notifying supervisors [16, 21].</p>
<p>- <strong>Global Functions</strong></p>
<p>- <strong>Purpose:</strong> N3 queries can <strong>invoke external functions</strong>, often written in languages like C# [1, 6, 22]. This mechanism promotes code reusability and allows for complex computations or data retrieval from external services that are not directly expressible within N3 itself [1, 6, 22, 23].</p>
<p>- <strong>Flexibility:</strong> Global functions enable integration with external data sources and custom logic, enhancing the platform's capabilities beyond native N3 operations [1, 6, 23]. This means a global function can calculate something like "sum in words" for a financial value, ensuring consistency even if the underlying numbers change [22, 23].</p>
<p>In essence, N3 queries serve as the core language for defining dynamic behavior and calculations within the platform, enabling a flexible and context-aware system where information is processed on-demand based on the underlying graph data [1-3].</p>
<p>--------------------------------------------------------------------------------</p>
<p>N3 Querying: Principles, Syntax, and Applications</p>
<p><strong>N3 querying</strong> is the <strong>language used to interact with data stored in an N3/RDF graph database</strong>, which represents all information as <strong>triplets</strong> [1-6]. It is a powerful tool for semantic queries, allowing users to define and retrieve complex relationships and facts [1, 4].</p>
<p>Core Principles of N3 Querying</p>
<p>1. <strong>Operation on Triplets</strong>: N3 queries operate directly on the <strong>triplet structures</strong> that form the fundamental unit of data storage in the database [1-6]. A triplet consists of a <strong>Subject</strong>, a <strong>Predicate</strong>, and an <strong>Object</strong> [1-3, 5, 7-10].</p>
<p>2. <strong>Directionality</strong>: The <strong>directionality of relationships</strong> is crucial in triplets, directly influencing how queries must be structured. For example, "Person owns Car" is distinct from "Car owned_by Person," and this direction dictates which element serves as the Subject and which as the Object [1-3, 5, 7, 10-12].</p>
<p>3. <strong>Variables</strong>: <strong>Variables</strong> are denoted by a question mark (e.g., ?S, ?P, ?O) and represent unknown values that the query aims to discover [3, 10, 13-15]. When parts of a triplet are variables, the system performs a <strong>search</strong> in the database to find matching facts and populates the variables with <strong>iterators</strong> (sequences of values) [1, 3, 4, 16-19].</p>
<p>4. <strong>Match vs. Search</strong>:</p>
<p>- <strong>Search</strong>: Used when one or more parts of a triplet are variables. The system finds facts that match the known parts and returns an iterator of results [1, 3, 4, 16, 18-20].</p>
<p>- <strong>Match</strong>: Occurs when all parts of a triplet are known values. The system simply checks for the existence of that exact fact in the database, returning true or false without an iterator [1, 3, 4, 16, 18, 20-22]. This is often used for validation or conditional logic.</p>
<p>N3 Query Syntax and Structure</p>
<p>N3 queries use a specific syntax to define triplets and logical expressions:</p>
<p>- <strong>Triplet Terminator (</strong><strong>.</strong><strong>):</strong> Every triplet must end with a period [13-15].</p>
<p>- <strong>Formula Blocks (</strong><strong>{...}</strong><strong>):</strong> Define a query block that is executed as a single unit, forming a single iterator result [7, 13-15, 23-28]. These are crucial for grouping operations.</p>
<p>- <strong>Lists (</strong><strong>(...)</strong><strong>):</strong> Used to define ordered collections of values or variables [7, 13-15, 23-25, 28-30]. They can be used to pass multiple arguments to built-in functions [30].</p>
<p>- <strong>Prefixes (</strong><strong>@prefix</strong><strong>):</strong> Define shortcuts for long URIs (Uniform Resource Identifiers), improving readability [13-15, 31-35].</p>
<p>- <strong>Comments (</strong><strong>#</strong><strong>):</strong> Used to add notes within the query [13-15, 36].</p>
<p>- <strong>Implicit Subject (</strong><strong>[...]</strong><strong>):</strong> Square brackets can implicitly refer to the subject of the previous triplet, simplifying syntax [13, 14, 27].</p>
<p>- <strong>Reserved Keywords:</strong> a (for rdf:type - "is an instance of"), is ... of (inverse property) [13-15, 36].</p>
<p>- <strong>Assignment (</strong><strong>\=</strong><strong>):</strong> Assigns a value from one variable to another [13-15, 24].</p>
<p>- <strong>Conditional (</strong><strong>if ... else ...</strong><strong>):</strong> Controls query flow. If the if condition is false and there's no else block, the query stops execution [10, 13, 14, 25, 37, 38].</p>
<p>N3 Query Execution Model</p>
<p>The execution of N3 queries follows a distinct model:</p>
<p>- <strong>Sequential Execution:</strong> Queries execute top-down, line by line [3, 13, 27, 39].</p>
<p>- <strong>Iterative Processing:</strong> If a line (triplet) returns an iterator (multiple values), the subsequent lines are executed for each value in that iterator [3, 13, 27, 39, 40]. This creates a nested loop behavior, meaning the query engine "walks" the graph from node to node via edges (predicates) [1, 3, 41].</p>
<p>- <strong>Iterator Scope:</strong> An iterator's scope is confined to the formula/block it was created in. Once the block finishes, the iterator's result is passed as a single value (or a collection) to the next level [3, 13, 27, 40, 42, 43].</p>
<p>- <strong>Performance Optimization:</strong> The <strong>order of triplets significantly impacts performance</strong> [1, 3, 16, 40, 41, 44, 45]. Queries should start with the <strong>most restrictive conditions</strong> to minimize the size of initial iterators, rather than following a traditional relational database's "FROM-WHERE" pattern [1, 3, 16, 45-47]. Starting with highly selective conditions reduces the number of iterations required for subsequent triplets [8].</p>
<p>Common Query Patterns and Operators</p>
<p>- <strong>object:findProperty</strong>: A built-in predicate used to retrieve the ID of an attribute given its template alias and attribute alias (e.g., ("TemplateAlias" "AttributeAlias") object:findProperty ?attributeId) [10, 13, 23, 33, 35, 45, 47-49]. This is highly optimized as it always returns a single ID.</p>
<p>- <strong>assert:union</strong>: Combines the results of multiple iterators into a single iterator. assert:union true performs a "union all" operation, including duplicates [10, 13, 18, 23, 25, 43, 50].</p>
<p>- <strong>ones</strong>: Executes a query and returns only the first successful result, stopping further iteration once a match is found [13, 23, 24, 51].</p>
<p>- <strong>or</strong>: Evaluates multiple conditions and returns true if any of them are met, stopping once the first successful condition is found [13, 23, 25, 38, 51].</p>
<p>- <strong>Built-in Functions</strong>: Special predicates (e.g., math:sum, time:dayOfWeek) that perform calculations in memory rather than querying the database [4, 13, 23, 26, 30, 52-54]. They can operate on lists of values.</p>
<p>- <strong>item</strong> <strong>and</strong> <strong>value</strong>: Reserved keywords for input and output parameters, respectively, in expressions [4, 10, 13, 16, 18, 23, 24, 27, 29, 37, 39, 55-57]. item typically represents the ID of the current object/record, while value stores the query's output. Their specific meanings can vary depending on the query's application context [29].</p>
<p>Data Representation and Storage for N3 Queries</p>
<p>All data in the N3 database, including systemic metadata and user-applied data, is stored as triplets [1, 2, 4-7, 23, 37, 58, 59]. This data can take several forms within a triplet:</p>
<p>- <strong>Qualified Name (QName)</strong>: Shortened forms of long URIs used for subjects, predicates, and objects, especially for complex types [1, 5, 7, 23, 32, 33].</p>
<p>- <strong>Simple Literals</strong>: Direct, atomic values like strings, numbers, booleans, dates, or durations [1, 5, 7, 23, 33, 59].</p>
<p>- <strong>Complex Literals</strong>: Represent collections of facts or ordered sets of values, used in advanced queries, specifically <strong>Formulas (</strong><strong>{...}</strong><strong>)</strong> and <strong>Lists (</strong><strong>(...)</strong><strong>)</strong> [1, 7, 23, 28, 30].</p>
<p>- <strong>Axioms vs. Derived Facts</strong>:</p>
<p>- <strong>Axioms</strong> are facts directly stored as triplets in the database [1, 7, 10, 23, 24, 56, 57].</p>
<p>- <strong>Derived facts</strong> are computed on the fly based on axioms and the current context (e.g., calculated attributes) and are <strong>not stored</strong> in the database [1, 7, 10, 23, 24, 42, 56, 57, 60-62]. This ensures they always reflect the most current underlying data [8, 61].</p>
<p>Application Contexts for N3 Queries</p>
<p>N3 queries are utilized in various platform features to define dynamic behavior:</p>
<p>- <strong>Calculated Attributes</strong>: Compute values dynamically for a record template, not stored but calculated on-the-fly when requested [4, 8, 10, 13, 19, 27, 37, 57, 60-62]. item is the input (current object ID), and value is the output.</p>
<p>- <strong>List Filters</strong>: Filter records displayed in a list. item is the output (IDs of records to display), with no input item [4, 13, 21, 37, 63, 64].</p>
<p>- <strong>Operations (Conditional Display)</strong>: Show or hide operations based on conditions. item is the input (current record ID), and value is true (show) or false (hide) [4, 13, 21, 65].</p>
<p>- <strong>Business Rules (Triggers/Scenarios)</strong>: Define actions that execute based on specific events (e.g., field change), often involving complex N3 queries for conditions or value derivation [13, 60, 65].</p>
<p>- <strong>Global Functions</strong>: External functions (e.g., written in C#) can be invoked from N3 queries to perform complex computations or retrieve data from external services, promoting code reusability [13, 60, 65-68].</p>
<p>The development environment for N3 queries is continuously improving, with new compilers and editors being designed to provide better error highlighting and code assistance [69].</p>
<p>--------------------------------------------------------------------------------</p>
<p>N3/RDF Triplet Data: Structure, Storage, and Querying</p>
<p><strong>Triplet data</strong> serves as the <strong>fundamental unit of data storage</strong> within an <strong>N3/RDF graph database</strong> [1-3]. These atomic building blocks are crucial for capturing facts and relationships, enabling a comprehensive semantic data representation and efficient querying [1, 4].</p>
<p>Components of a Triplet</p>
<p>Each triplet is comprised of three indispensable parts [1-3]:</p>
<p>- <strong>Subject</strong>: This element represents the resource being described and acts as the <strong>source of the arrow</strong> in a graph visualization [1-3].</p>
<p>- <strong>Predicate</strong>: This signifies the <strong>property or relationship</strong> between the subject and object, typically depicted as the <strong>arrow itself</strong> in a graph [1-3].</p>
<p>- <strong>Object</strong>: This is the value or resource to which the subject is related, forming the <strong>destination of the arrow</strong> [1-3].</p>
<p>For instance, in the statement "Person owns Car," "Person" is the subject, "owns" is the predicate, and "Car" is the object [1]. The entire database, encompassing both <strong>systemic metadata</strong> (definitions of classes, properties, and relationships) and <strong>user-applied data</strong> (instances and records), is stored exclusively as these triplet facts [1, 3, 5-10].</p>
<p>Directionality of Triplets</p>
<p><strong>Directionality is a crucial aspect of triplets</strong> [1-3]. It explicitly defines the flow of a relationship, making statements like "Person owns Car" distinct from "Car owned_by Person" [1-3]. This inherent directionality determines which element functions as the Subject and which as the Object, which is vital for structuring N3 queries to retrieve specific information [1-3]. The choice of direction during data modeling can significantly influence how queries are subsequently constructed [2, 3]. As discussed, this means that understanding how the platform's core systemic model is designed with specific directions for its attributes is essential, and user-defined models also require careful consideration of directionality for effective querying [2, 11].</p>
<p>Data Storage and Representation in Triplets</p>
<p>All data in the N3 database, whether it pertains to system models or user-applied data, is persisted as triplets [1, 3, 5-7, 9, 10]. System models are typically defined in .n3 files, while applied data (metadata and instances) is stored in separate files like data.n3 [1, 5, 6, 9]. While the platform leverages an SQLite engine for transactional operations, its core data model and the serialization/deserialization logic between triplets and relational views are custom-built [1, 5, 6, 9, 10]. This custom approach is considered a key innovation, providing speed and unique data handling principles [10].</p>
<p>Triplets can represent data in several forms for their Subject, Predicate, or Object components [1, 5, 6]:</p>
<p>- <strong>Qualified Name (QName)</strong>: These are shortened forms of long URIs (Uniform Resource Identifiers) used to represent resources, especially for complex types [1, 3, 5, 6, 12]. QNames are commonly employed for subjects, predicates, and objects [1, 3, 5, 6]. For example, object:findProperty is a QName where object is a prefix for a longer URI [5, 13].</p>
<p>- <strong>Simple Literals</strong>: These represent direct, atomic values such as strings ("blue"), numbers (5), booleans (true), dates, or durations [1, 5, 6, 13, 14].</p>
<p>- <strong>Complex Literals</strong>: These are used in advanced queries to represent collections of facts or ordered sets of values [1, 5, 6, 15].</p>
<p>- <strong>Formulas (</strong><strong>{...}</strong><strong>):</strong> A set of triplets that are evaluated together as a single unit [1, 5, 6, 15, 16]. This allows for complex logic within a single block.</p>
<p>- <strong>Lists (</strong><strong>(...)</strong><strong>):</strong> An ordered collection of values or variables [1, 5, 6, 15]. These are useful for passing multiple arguments to functions or defining a sequence of items [17].</p>
<p>- <strong>Axioms vs. Derived Facts</strong>:</p>
<p>- <strong>Axioms</strong> are facts directly stored as triplets in the database [1, 5, 6, 9]. They represent the persistently stored data [18].</p>
<p>- <strong>Derived facts</strong> are computed on the fly based on axioms and the current context (e.g., calculated attributes) and are <strong>not stored</strong> in the database [1, 5, 6, 9]. Calculated attributes, for instance, are always computed on demand when the attribute is requested, ensuring they reflect the most current underlying data [5, 9, 18-21]. This on-the-fly computation means that changes to source data automatically trigger re-calculation of derived facts upon access [19, 21].</p>
<p>Triplet Interaction with N3 Querying</p>
<p>N3 queries operate directly on these triplet structures [1, 9]. The language's syntax elements, such as the triplet terminator (.), formula blocks ({...}), and lists ((...)), are fundamental to defining and structuring triplets within queries [22].</p>
<p>- When parts of a triplet in a query are <strong>variables</strong> (e.g., ?S P ?O), the system performs a <strong>search</strong> in the database to find matching facts and populate the variables with iterators (sequences of values) [1, 23].</p>
<p>- If <strong>all parts of a triplet are known values</strong>, the system performs a <strong>match</strong> to check for the exact fact's existence, returning true or false [1, 23]. This operation does not return an iterator [23].</p>
<p>Understanding the structure and directionality of triplets is fundamental for building effective N3 queries, as the way data is stored directly influences how information can be retrieved and processed [3, 24]. The sequential and iterative execution model of N3 queries means that the order of triplets significantly impacts performance, as queries should start with the most restrictive conditions to minimize the size of initial iterators [1, 23].</p>
<p>--------------------------------------------------------------------------------</p>
<p>N3 Queries: Graph Database Interaction and Semantics</p>
<p><strong>N3 (Notation3) queries</strong> are a fundamental aspect of interacting with graph databases that are structured around ontological models and triplets [1-3]. N3 is a <strong>compact and human-readable syntax for RDF (Resource Description Framework)</strong>, which also supports logical expressions [1-4]. Its design allows it to operate directly on the triplet data structure of the database [1, 5, 6].</p>
<p>Core Syntax Elements</p>
<p>N3 queries use several key syntax elements to define and structure their logic [7]:</p>
<p>- <strong>Comments (</strong><strong>#</strong><strong>)</strong>: Used for adding notes within the query [7].</p>
<p>- <strong>Prefixes (</strong><strong>@prefix</strong><strong>)</strong>: Define shortcuts for long URIs, enhancing readability and making queries more concise [7]. For example, object: is a prefix for a longer URI related to object properties [1, 5, 8].</p>
<p>- <strong>Variables (</strong><strong>?</strong><strong>)</strong>: Represent unknown values that the query aims to discover. They are denoted by a question mark followed by an alphanumeric name (e.g., ?item, ?value) [7].</p>
<p>- <strong>Triplet Terminator (</strong><strong>.</strong><strong>)</strong>: Every triplet expression in an N3 query must end with a period [7].</p>
<p>- <strong>Formula Block (</strong><strong>{...}</strong><strong>)</strong>: Defines a query block that is executed as a single unit, forming a single iterator result [5, 7].</p>
<p>- <strong>Lists/Arrays (</strong><strong>(...)</strong><strong>)</strong>: Used to define ordered collections of values or variables [5, 7].</p>
<p>- <strong>Implicit Subject (</strong><strong>[...]</strong><strong>)</strong>: Square brackets can implicitly refer to the subject of the previous triplet, simplifying syntax [7].</p>
<p>- <strong>Reserved Keywords</strong>: Include a (for rdf:type, meaning "is an instance of") and is ... of (for inverse properties) [7].</p>
<p>- <strong>Assignment (</strong><strong>\=</strong><strong>)</strong>: Assigns a value from one variable to another [7].</p>
<p>- <strong>Conditional (</strong><strong>if ... else ...</strong><strong>)</strong>: Controls query flow. If the if condition is false and there's no else block, the query's execution path effectively terminates [7, 9].</p>
<p>Triplet Interaction and Query Types</p>
<p>N3 queries operate directly on <strong>triplet structures</strong>, which consist of a <strong>Subject</strong>, a <strong>Predicate</strong>, and an <strong>Object</strong> [1-4]. The <strong>directionality</strong> of triplets is crucial, as it dictates which element is the Subject and which is the Object, fundamentally influencing how queries must be structured [1-4, 8].</p>
<p>Queries can perform two main types of operations on triplets [3, 5]:</p>
<p>- <strong>Search (Unknowns)</strong>: When one or more parts of a triplet in a query are variables (e.g., ?S P ?O), the system performs a search in the database to find matching facts and populates the variables with <strong>iterators</strong> (sequences of values) [1, 3, 5]. This is used to discover subjects, objects, or both, based on known predicates or other parts of the triplet [3, 5].</p>
<p>- <strong>Match (All Known)</strong>: When all parts of a triplet are known values, the system performs a match to check for the <strong>exact fact's existence</strong> in the database, returning true or false [1, 3, 5]. This type of query does not return an iterator [3, 5].</p>
<p>Query Execution Model</p>
<p>N3 queries follow a <strong>sequential and iterative execution model</strong> [1, 3]:</p>
<p>- <strong>Sequential Execution</strong>: Queries execute top-down, line by line [3].</p>
<p>- <strong>Iterative Processing</strong>: If a line (triplet) returns an iterator (multiple values), the subsequent lines are re-executed for each value in that iterator, creating a nested loop-like behavior [3, 9, 10].</p>
<p>- <strong>Iterator Scope</strong>: An iterator's scope is confined to the formula or block in which it was created. Once the block finishes, the iterator's result is passed as a single value (or a collection) to the next level [3]. This "loop-join" behavior is fundamental to how N3 "walks" the graph to retrieve information [1, 11, 12].</p>
<p>Query Optimization</p>
<p>The sequential and iterative nature of N3 query execution significantly impacts performance [1, 3, 9]. To optimize queries, it is essential to <strong>start with the most restrictive conditions</strong> to minimize the size of initial iterators [1, 3, 12, 13]. This often means "flipping" the query's structure compared to traditional relational database query patterns [1, 12].</p>
<p>Contextual Variables</p>
<p>In various N3 query contexts, reserved variables like item and value are used [7]:</p>
<p>- <strong>item</strong>: Typically represents the ID of the current object or record in the query's context (e.g., in calculated attributes or operations) [7, 14, 15].</p>
<p>- <strong>value</strong>: Represents the output parameter where the result of a query or calculation is stored [7, 14, 15]. Its expected type can vary depending on the context (e.g., boolean for operations, ID for list filters, or a literal for calculated attributes) [16].</p>
<p>Built-in Predicates and Operators</p>
<p>N3 provides specialized predicates and operators for common tasks [5]:</p>
<p>- <strong>object:findProperty</strong>: A built-in predicate used to retrieve the unique ID of an attribute given its template alias and attribute alias (e.g., ("TemplateAlias" "AttributeAlias") object:findProperty ?attributeId) [1, 5, 9]. It's highly optimized and returns a single ID [5].</p>
<p>- <strong>assert:union</strong>: Combines the results of multiple iterators into a single iterator. assert:union true performs a "union all" operation, including duplicates [5, 9, 17, 18].</p>
<p>- <strong>ones</strong>: Executes a query and returns only the first successful result, stopping further iteration once a match is found [5, 19].</p>
<p>- <strong>or</strong>: Evaluates multiple conditions and returns true if any are met, stopping once the first successful condition is found [5, 19, 20].</p>
<p>- <strong>Built-in Functions</strong>: Special predicates like math:sum or time:dayOfWeek perform calculations in memory rather than querying the database [5, 21-23].</p>
<p>Application Contexts for N3 Queries</p>
<p>N3 queries are used across various platform contexts [15]:</p>
<p>- <strong>Calculated Attributes</strong>: Define properties whose values are computed dynamically on demand and are not stored in the database [9, 13, 14, 24-26]. item is the input (current object ID), and value is the output [14].</p>
<p>- <strong>List Filters</strong>: Used to filter records displayed in a list. item represents the output (IDs of records to display), with no input item [15, 27].</p>
<p>- <strong>Operations (Conditional Display)</strong>: Used to show or hide operations (like a "Complete Task" button) based on conditions. item is the input (current record ID), and value is true (show) or false (hide) [15, 27].</p>
<p>- <strong>Business Rules (Triggers/Scenarios)</strong>: Define actions that execute based on specific events (e.g., a field change), often involving complex N3 queries to determine conditions or derive values [15, 24].</p>
<p>- <strong>Global Functions</strong>: External functions (e.g., written in C#) can be invoked from N3 queries to perform complex computations or retrieve data from external services not directly expressible in N3 [15, 28-30].</p>
<p>Data Types in Triplets and N3 Queries</p>
<p>N3 queries interact with various data types stored as triplet objects [1, 5, 8]:</p>
<p>- <strong>Qualified Name (QName)</strong>: Shortened forms of URIs representing resources, used for subjects, predicates, and objects, especially for complex types [1, 5, 8, 31].</p>
<p>- <strong>Simple Literals</strong>: Direct values such as strings, numbers, booleans, dates, or durations [1, 5, 8, 32, 33].</p>
<p>- <strong>Complex Literals</strong>: Represent collections of facts or ordered sets of values, used in advanced queries [1, 5, 8].</p>
<p>- <strong>Formulas (</strong><strong>{...}</strong><strong>)</strong>: A set of triplets evaluated together as a single unit [1, 5, 8, 34].</p>
<p>- <strong>Lists (</strong><strong>(...)</strong><strong>)</strong>: An ordered collection of values or variables [1, 5, 8, 34].</p>
<p>Axioms vs. Derived Facts</p>
<p>N3 queries distinguish between:</p>
<p>- <strong>Axioms</strong>: Facts directly stored as triplets in the database [1, 5, 8, 9, 25].</p>
<p>- <strong>Derived Facts</strong>: Computed on the fly based on axioms and the current query context (e.g., calculated attributes). They are <strong>not stored</strong> in the database but are computed at the moment of access [1, 5, 8, 9, 13, 24-26]. This distinction impacts performance and data integrity, as derived facts are always current but require re-computation upon request [13, 35].</p>
<p>--------------------------------------------------------------------------------</p>
<p>The Essence of Triplet Data in N3 Databases</p>
<p><strong>Triplets</strong> are the <strong>fundamental unit of data storage</strong> in an <strong>N3/RDF graph database</strong> [1-3]. They are the atomic building blocks that capture facts and relationships within a graph database, enabling semantic data representation and querying [4].</p>
<p>Components of a Triplet</p>
<p>Every triplet consists of three essential parts [1, 2]:</p>
<p>- <strong>Subject</strong>: This is the resource being described, acting as the source of the arrow in a graph [1, 2].</p>
<p>- <strong>Predicate</strong>: This represents the property or relationship between the subject and object. It is visualized as the arrow itself in a graph [1, 2].</p>
<p>- <strong>Object</strong>: This is the value or resource that the subject is related to, forming the destination of the arrow [1, 2].</p>
<p>For example, in the statement "Person owns Car," "Person" would be the subject, "owns" the predicate, and "Car" the object [1]. The data in an N3 database, including both <strong>systemic metadata</strong> (definitions of classes, properties, and relationships) and <strong>user-applied data</strong> (instances and records), is entirely stored as these triplet facts [1, 3, 5].</p>
<p>Directionality of Triplets</p>
<p><strong>Directionality is crucial for triplets</strong> because it explicitly defines the flow of a relationship [1, 2, 5]. For instance, "Person owns Car" is distinct from "Car owned_by Person" [1, 5]. This directionality dictates which element functions as the Subject and which as the Object, which is vital for structuring N3 queries to retrieve specific information [1, 2, 5]. The choice of direction when modeling can significantly impact how queries are later built [6].</p>
<p>Data Storage and Representation in Triplets</p>
<p>All data within the N3 database, whether it describes system models or applied user data, is stored as triplets [1, 3]. System models are typically defined in .n3 files, while applied data is found in separate files like data.n3 [1, 3]. Although the platform uses an SQLite engine for transactional aspects, its core data model and the logic for serializing/deserializing data between triplets and relational views are custom-built [1, 3, 5, 7].</p>
<p>Triplets can represent data in several forms for their Subject, Predicate, or Object components:</p>
<p>- <strong>Qualified Name (QName)</strong>: These are shortened forms of long URIs (Uniform Resource Identifiers) used to represent resources, especially for complex types [1, 3, 8]. QNames are commonly used for subjects, predicates, and objects [1, 3]. An example would be object:findProperty where object is a prefix for a longer URI [3].</p>
<p>- <strong>Simple Literals</strong>: These are direct values such as strings ("blue"), numbers (5), booleans (true), dates, or durations [1, 3].</p>
<p>- <strong>Complex Literals</strong>: These represent collections of facts or ordered sets of values, utilized in advanced queries [1, 3].</p>
<p>- <strong>Formulas (</strong><strong>{...}</strong><strong>):</strong> A set of triplets that are evaluated together as a single unit [1, 3, 9].</p>
<p>- <strong>Lists (</strong><strong>(...)</strong><strong>):</strong> An ordered collection of values or variables [1, 3, 9].</p>
<p>- <strong>Axioms vs. Derived Facts</strong>:</p>
<p>- <strong>Axioms</strong> are facts directly stored as triplets in the database [1, 3].</p>
<p>- <strong>Derived facts</strong> are computed on the fly based on axioms and the current context (e.g., calculated attributes) and are <strong>not stored</strong> in the database [1, 3, 10-12]. Calculated attributes, for instance, are always computed on demand when the attribute is requested [10, 11, 13].</p>
<p>Triplets and N3 Querying</p>
<p>N3 queries operate directly on these triplet structures [1, 9]. The language's syntax elements like the triplet terminator (.), formula blocks ({...}), and lists ((...)) are fundamental to defining and structuring triplets within queries [9].</p>
<p>- When parts of a triplet in a query are <strong>variables</strong> (e.g., ?S P ?O), the system performs a <strong>search</strong> in the database to find matching facts and populate the variables with iterators (sequences of values) [1, 14].</p>
<p>- If <strong>all parts of a triplet are known values</strong>, the system performs a <strong>match</strong> to check for the exact fact's existence, returning true or false [1, 14].</p>
<p>Understanding the structure and directionality of triplets is fundamental for building effective N3 queries, as the way data is stored directly influences how information can be retrieved [5, 6, 15].</p>
<p>--------------------------------------------------------------------------------</p>
<p>Ontology, Graphs, and Triplet Data Models</p>
<p><strong>Ontological models</strong> serve as the conceptual framework for defining entities and their connections within information systems [1]. In the realm of Information Technologies (IT), an ontology is formally described as <strong>a set of objects, their properties, and the relationships between them</strong> [2-6]. Its primary purpose is to provide a structured and machine-readable representation of a specific domain or the real world [4, 6].</p>
<p>Core Concepts of Ontology</p>
<p>An ontological model fundamentally consists of three main components [3, 4]:</p>
<p>- <strong>Objects (Entities)</strong>: These are the core elements or things being described, such as "Pencil Case" or "Pencil" [3, 4, 7].</p>
<p>- <strong>Characteristics/Properties (Attributes)</strong>: These define the qualities or attributes of the objects, like "Material" and "Capacity" for a "Pencil Case," or "Color," "Condition," and "Hardness" for a "Pencil" [3, 4, 7].</p>
<p>- <strong>Interactions/Relationships (Connections)</strong>: These define how objects are connected to each other, such as "Pencil Case contains Pencil" [3, 4, 7].</p>
<p>The "Pencil Case contains Pencil" example illustrates a one-to-many relationship, where a pencil case can hold multiple pencils, but a pencil can be in zero or one pencil case. This relationship signifies that the pencil case possesses the property of containing pencils [4, 7, 8].</p>
<p>Application to Graph Databases</p>
<p><strong>Graph databases naturally represent ontological models</strong> [2-4]. In this context:</p>
<p>- <strong>Nodes (Vertices)</strong> typically represent the <strong>objects, classes, or instances</strong> defined in the ontology [2-4, 9]. For example, "Person" and "Car" can be nodes representing classes, or "Ivan Ivanovich" and a "Volvo car" can be nodes representing specific instances [2, 4, 9].</p>
<p>- <strong>Edges (Relations)</strong> represent the <strong>relationships</strong> between these nodes [2-4, 9]. For instance, "owns" would be an edge connecting a "Person" node to a "Car" node [2, 4, 9].</p>
<p>Graph databases support various graph types, including directed and undirected graphs, which reflect the nature of relationships in an ontology [2-4, 10, 11]. This structure makes them particularly well-suited for semantic queries [2, 3, 12].</p>
<p>Relationship with Triplets (N3 and RDF)</p>
<p>The ontological model directly translates into the fundamental unit of data storage in an N3/RDF graph database: the <strong>triplet</strong> [2-4, 8, 11].</p>
<p>- A triplet consists of a <strong>Subject</strong>, a <strong>Predicate</strong>, and an <strong>Object</strong> [2-4, 13, 14]. This structure directly reflects an ontological statement: the Subject is the entity being described, the Predicate is its property or relationship, and the Object is the value or related entity [2, 4, 13, 14].</p>
<p>- <strong>Directionality is crucial for triplets</strong>; it explicitly defines the flow of a relationship (e.g., "Person owns Car" versus "Car owned_by Person") [2-4, 14, 15]. This direction dictates which element serves as the Subject and which as the Object, which in turn significantly influences how queries must be structured to retrieve information [2-4, 15].</p>
<p>All data in the N3 database, including <strong>systemic metadata</strong> (definitions of classes, properties, and their relationships) and <strong>user-applied data</strong> (instances, records), is stored as these triplet facts [2-4, 16, 17]. System models are described in .n3 files, while applied data is stored in separate files like data.n3 [2, 3, 16]. The platform's core systemic model is fixed and uses specific predicates, but user-defined custom models also create triplets, and their directionality is important for query construction [3, 16]. Understanding how these underlying facts are structured in the N3 database is fundamental to building effective N3 queries [4, 15].</p>
<p>In essence, ontology provides the conceptual framework, graph databases offer the structural means to store this information, and triplets serve as the atomic units that capture these ontological facts, forming the basis for semantic data representation and querying [1, 4]. The platform's core data model and the logic for handling data between triplets and relational views are custom-built, even though an SQLite engine is used for transactional aspects [2-4, 17].</p>
<p>--------------------------------------------------------------------------------</p>
<p>System Models and N3 Database Integration</p>
<p><strong>System models</strong> are a fundamental component of the platform's data architecture, providing a formal and structured description of core entities, their properties, and the relationships between them in the context of information technologies [1-4]. These models function as <strong>systemic metadata</strong>, defining elements such as class structures and property types [3-5]. They represent the platform's <strong>fixed, core systemic model</strong> [6] and are not directly editable by users [7, 8].</p>
<p>Here's how system models integrate into the larger context of N3 database data storage:</p>
<p>- <strong>Description in .n3 Files</strong></p>
<p>- System models are explicitly <strong>described in dedicated</strong> <strong>.n3</strong> <strong>files</strong> [1, 3, 9-11]. These files act as the "dictionary" for the system's foundational elements [12].</p>
<p>- They typically come pre-installed with the platform and can be inspected by users [11, 12].</p>
<p>- The definitions within these .n3 files are largely static, changing primarily with platform upgrades or new versions [12]. Adding new parameters or functionalities to these models requires developer intervention [12].</p>
<p>- <strong>Integration with N3 Database Data Storage</strong></p>
<p>- <strong>Triplet-Based Foundation</strong>: The N3 database stores <strong>all data—both system models (systemic metadata) and user-applied data (instances and records)—as triplets</strong> [1, 3, 4, 9-11, 13]. A triplet consists of a Subject, Predicate, and Object, representing a single fact or relationship [1, 6, 14-17].</p>
<p>- <strong>Graph Structure</strong>: This triplet storage naturally forms a <strong>graph structure</strong>, where <strong>nodes</strong> represent entities (like classes defined in system models, e.g., "Person" or "Car") and <strong>edges</strong> represent relationships between these nodes (e.g., "owns") [1, 2, 4]. System models directly define these fundamental nodes and edges [1, 6, 13, 18].</p>
<p>- <strong>Crucial Directionality</strong>: The <strong>directionality of relationships</strong> within triplets is critical [1, 3, 4, 6, 14, 19, 20]. This direction dictates which element is the Subject and which is the Object, significantly influencing how data is stored and how subsequent queries must be structured to retrieve information [1, 3, 4, 6, 14, 19, 20]. This principle applies uniformly to both system-defined and user-defined relationships.</p>
<p>- <strong>Custom Data Model and SQLite</strong>: While the platform leverages an <strong>SQLite engine for transactional operations</strong> [1, 3, 4, 9-11], the <strong>core data model and the logic for converting data between triplets and relational views are custom-built</strong> by the platform developers [1, 3, 4, 9-11]. This custom architecture is patented and is central to how the platform stores and manages data [11]. N3 queries operate directly on this triplet structure, effectively "walking" the graph to retrieve or verify information [1, 21].</p>
<p>- <strong>File Segregation</strong>: To maintain clarity and separation, system models are stored in .n3 files, distinct from user-applied data (metadata and instances), which reside in separate files such as data.n3 [1, 3, 9-11]. This separation underscores the distinction between the fixed, underlying system definitions and the dynamic, user-generated content.</p>
<p>--------------------------------------------------------------------------------</p>
<p>Graph Databases and N3 Querying Fundamentals</p>
<p><strong>Graph databases</strong> are a type of database that uses <strong>graph structures</strong> to represent and store data, and they are particularly well-suited for semantic queries [1-3]. This data is organized using <strong>nodes</strong>, <strong>edges</strong>, and properties [1-3]. <strong>N3 (Notation3) querying</strong> directly interacts with these graph structures by leveraging their fundamental unit of storage: the <strong>triplet</strong> [1, 4, 5].</p>
<p>Graph Databases</p>
<p>A graph database fundamentally represents data using <strong>graph structures</strong> [1]. Its two main components are:</p>
<p>- <strong>Nodes (Vertices):</strong> These represent entities or values, such as classes, instances, or literal values [1-3]. In the platform context, nodes can be abstract concepts like "Pencil Case" or "Pencil," or specific instances like "Ivan Ivanovich" or a "Volvo car" [1].</p>
<p>- <strong>Edges (Relations):</strong> These represent <strong>relationships</strong> between nodes. Edges can be either directed or undirected [1-3]. They signify how different entities are connected, for example, "Pencil Case contains Pencil" or "Person owns Car" [1].</p>
<p>Graph databases can support various types of graphs, including connected, isolated, directed, undirected, complete, planar, and tree-like graphs [1, 2].</p>
<p><strong>Application to Ontology</strong>: Graph databases are naturally suited to represent <strong>ontological models</strong> [1-3]. In information technology, an ontology formally describes a set of objects, their properties, and the relationships between them [1, 3]. In such a model, <strong>nodes</strong> typically represent objects, classes, or instances, while <strong>edges</strong> represent the relationships between them [1, 3]. For instance, "Person" and "Car" could be nodes, and "owns" would be an edge connecting them [1].</p>
<p>N3 Querying</p>
<p>The fundamental unit of data storage in an N3/RDF graph database is a <strong>triplet</strong> [1, 3, 4]. The entire database, encompassing both <strong>systemic metadata</strong> (definitions of classes, properties, and relationships) and <strong>user-applied data</strong> (instances and records), is stored as these triplet facts [1, 3, 6]. System models are described in .n3 files, while applied data is stored in separate files like data.n3 [1, 6]. The platform uses an SQLite engine for transactional aspects, but its core data model and the logic for serializing/deserializing data between triplets and relational views are custom [1, 3, 6].</p>
<p><strong>Components of a Triplet</strong>: A triplet consists of three essential parts [1, 3, 4]:</p>
<p>- The <strong>Subject</strong>: The resource being described, acting as the source of the arrow in a graph [1, 4].</p>
<p>- The <strong>Predicate</strong>: The property or relationship, represented as the arrow itself [1, 4].</p>
<p>- The <strong>Object</strong>: The value or resource that the subject is related to, forming the destination of the arrow [1, 4].</p>
<p><strong>Directionality</strong>: <strong>Directionality is crucial for triplets</strong>; it explicitly defines the flow of a relationship (e.g., "Person owns Car" versus "Car owned_by Person") [1, 3, 4]. This direction dictates which element is the Subject and which is the Object, and consequently, how queries must be structured to retrieve information [1, 3, 4, 7].</p>
<p><strong>Types of Data in Triplets</strong>: Data within triplets can be represented in various forms [1, 6]:</p>
<p>- <strong>Qualified Name (QName):</strong> These are shortened forms of long URIs (Uniform Resource Identifiers) used to represent resources, especially for complex types. QNames are typically used for subjects, predicates, and objects [1, 6, 8].</p>
<p>- <strong>Simple Literals:</strong> These are direct values like strings ("blue"), numbers (5), booleans (true), dates, or durations [1, 6].</p>
<p>- <strong>Complex Literals:</strong> These represent collections of facts or ordered sets of values, used in advanced queries [1, 6].</p>
<p>- <strong>Formulas (</strong><strong>{...}</strong><strong>):</strong> A set of triplets that are evaluated together as a single unit [1, 6].</p>
<p>- <strong>Lists (</strong><strong>(...)</strong><strong>):</strong> An ordered collection of values or variables [1, 6].</p>
<p>- <strong>Axioms vs. Derived Facts</strong>: <strong>Axioms</strong> are facts directly stored as triplets in the database [1, 6]. <strong>Derived facts</strong> are computed on the fly based on axioms and the current context (e.g., calculated attributes) and are <strong>not stored</strong> in the database [1, 6, 9, 10]. Calculated attributes, for instance, are always computed on demand [10, 11].</p>
<p><strong>N3 Query Syntax and Execution</strong>: N3 queries operate directly on these triplet structures [1, 5, 12]. The language has specific syntax elements like comments (#), prefixes (@prefix), variables (?), and a triplet terminator (.) [13]. Reserved keywords include a (for rdf:type) and is ... of (for inverse properties) [13]. <strong>item</strong> and <strong>value</strong> are reserved variables often representing the current object ID and the output parameter, respectively [5, 14-16].</p>
<p><strong>Query Execution Model</strong>:</p>
<p>- <strong>Sequential and Iterative</strong>: N3 queries execute top-down, line by line [17]. If a line (triplet) returns an <strong>iterator</strong> (multiple values), subsequent lines are executed for each value in that iterator, creating nested loops [17-19].</p>
<p>- <strong>Iterator Scope</strong>: An iterator's scope is confined to the formula/block it was created in. Once the block finishes, the iterator's result is passed as a single value (or a collection) to the next level [17, 18].</p>
<p>- <strong>Optimization</strong>: The <strong>order of triplets significantly impacts performance</strong> [11, 12, 17]. Queries should start with the most restrictive conditions to minimize the size of initial iterators, often requiring "flipping" the query compared to traditional relational database patterns [1, 11, 12, 17, 20, 21].</p>
<p>- <strong>Search vs. Match</strong>:</p>
<p>- When parts of a triplet are <strong>variables</strong> (e.g., ?S P ?O), the system performs a <strong>search</strong> in the database to find matching facts and populate the variables with iterators [1, 5, 17].</p>
<p>- If <strong>all parts of a triplet are known values</strong>, the system performs a <strong>match</strong> to check for the exact fact's existence, returning true or false [1, 5, 17].</p>
<p><strong>Common Query Patterns and Operators</strong>:</p>
<p>- <strong>object:findProperty</strong>: A built-in predicate used to retrieve the unique identifier (ID) of an attribute given its template alias and attribute alias [5, 21-23].</p>
<p>- <strong>assert:union</strong>: Combines the results of multiple iterators into a single iterator. assert:union true performs a "union all," meaning duplicates are included [5, 22-24].</p>
<p>- <strong>ones</strong>: Executes a query and returns only the first successful result, stopping further iteration once a match is found [5, 22, 25].</p>
<p>- <strong>or</strong>: Evaluates multiple conditions and returns true if any of them are met, stopping once the first successful condition is found [5, 22].</p>
<p>- <strong>Built-in Functions</strong>: Special predicates like math:sum or time:dayOfWeek perform calculations in memory rather than querying the database [5, 22].</p>
<p><strong>Application Contexts for N3 Queries</strong>: N3 queries are used in various platform contexts to define behavior and derive information [26, 27]:</p>
<p>- <strong>Calculated Attributes</strong>: Dynamically compute attribute values on a record template. item is the input (current object ID), and value is the output. These values are not stored in the database [11, 26].</p>
<p>- <strong>List Filters</strong>: Filter records displayed in a list. item is the output (IDs of records to display) [16, 26].</p>
<p>- <strong>Operations (Conditional Display)</strong>: Control the visibility of operations (e.g., buttons) based on conditions. item is the input (current record ID), and value is true (show) or false (hide) [27, 28].</p>
<p>- <strong>Business Rules (Triggers/Scenarios)</strong>: Define actions that execute based on specific events, often involving complex N3 queries to determine conditions or derive values [9, 27].</p>
<p>- <strong>Global Functions</strong>: External functions (e.g., written in C#) can be invoked from N3 queries for reusability, complex computations, or retrieving data from external services [27, 29, 30].</p>
<p>--------------------------------------------------------------------------------</p>
<p>Ontology and Graph Database Fundamentals</p>
<p><strong>Ontology</strong> is a core concept that underpins how data is structured and understood in graph databases, particularly in the context of semantic queries [1-4].</p>
<p>Here's a discussion of ontology concepts:</p>
<p>- <strong>Definition of Ontology</strong></p>
<p>- Philosophically, ontology is the study of being, existence, and the fundamental categories of reality [2, 4].</p>
<p>- In the realm of <strong>information technologies (IT)</strong>, ontology describes a <strong>formal description of a set of objects, their properties, and the relationships between them</strong> [1-3, 5, 6]. Its primary purpose in IT is to provide a structured and machine-readable representation of a specific domain or the real world [6].</p>
<p>- <strong>Core Components of Ontology</strong>An ontological model fundamentally consists of three main components [2, 4]:</p>
<p>- <strong>Objects (Entities):</strong> These are the core elements or things being described.</p>
<p>- <strong>Characteristics/Properties (Attributes):</strong> These define the qualities or attributes of the objects.</p>
<p>- <strong>Interactions/Relationships (Connections):</strong> These define how objects are connected to each other.</p>
<p>- <strong>Real-world Analogy</strong>To illustrate these concepts, consider the example of "pencils in a pencil case" [2, 7]:</p>
<p>- <strong>Classes:</strong> "Pencil Case" and "Pencil" can be defined as classes [2, 7].</p>
<p>- <strong>Properties:</strong> A "Pencil Case" might have properties like "Material" and "Capacity," while a "Pencil" might have "Color," "Condition" (e.g., sharp, dull), and "Hardness" [2, 7].</p>
<p>- <strong>Relationship:</strong> The relationship could be "Pencil Case contains Pencil." This relationship can be specified as one-to-many, where a pencil case can contain multiple pencils, but a pencil can be in zero or one pencil case [2, 7]. This relationship signifies that the pencil case has the property of containing pencils [8].</p>
<p>- <strong>Application to Graph Databases</strong> <strong>Graph databases naturally represent ontological models</strong> [1, 3]. In this context:</p>
<p>- <strong>Nodes (Vertices)</strong> typically represent the <strong>objects, classes, or instances</strong> defined in the ontology [1, 3, 9, 10]. For example, "Person" and "Car" could be nodes representing classes, or "Ivan Ivanovich" and a "Volvo car" could be nodes representing instances [1, 10].</p>
<p>- <strong>Edges (Relations)</strong> represent the <strong>relationships</strong> between these nodes [1, 3, 9, 10]. For instance, "owns" would be an edge connecting a "Person" node to a "Car" node [1, 9]. Graph databases can support various graph types, including directed and undirected graphs, which reflect the nature of relationships in an ontology [1, 3].</p>
<p>- **Relationship with Triplets (N3 and RDF)**The ontological model translates directly into the fundamental unit of data storage in an N3/RDF graph database: the <strong>triplet</strong> [9, 11, 12].</p>
<p>- A triplet consists of a <strong>Subject</strong>, a <strong>Predicate</strong>, and an <strong>Object</strong> [9, 11-15]. This structure directly reflects an ontological statement: the Subject is the entity being described, the Predicate is its property or relationship, and the Object is the value or related entity [9, 15].</p>
<p>- <strong>Directionality is crucial for triplets</strong> [6, 9, 11, 13, 15, 16]. It explicitly defines the flow of a relationship (e.g., "Person owns Car" versus "Car owned_by Person"). This direction dictates which element serves as the Subject and which as the Object, which in turn significantly influences how queries must be structured to retrieve information [6, 9, 11, 13, 16].</p>
<p>- The entire database, including both <strong>systemic metadata</strong> (definitions of classes, properties, and their relationships) and <strong>user-applied data</strong> (instances, records), is stored as these triplet facts [13, 17-22]. Understanding how these underlying facts are structured in the N3 database is fundamental to building effective N3 queries [16, 20].</p>
<p>- N3 (Notation3) is a human-readable syntax used for RDF that also supports logical expressions [9, 11, 23]. The system's core data model and logic for handling data between triplets and relational views are custom, even though an SQLite engine is used for transactional aspects [13, 17, 19, 21].</p>
<p>In essence, ontology provides the conceptual framework for defining entities and their connections, graph databases offer the structural means to store this information, and triplets serve as the atomic units that capture these ontological facts, forming the basis for semantic data representation and querying [23].</p>
<p>--------------------------------------------------------------------------------</p>
<p>N3/RDF: Graph Database Concepts and Querying</p>
<p>Please note: Some terms and names in the sources are in Russian and have been transliterated or translated for clarity in the timeline and character list.</p>
<p>Detailed Timeline of Main Events</p>
<p>The provided sources do not describe a sequential narrative of events but rather explain technical concepts and their application. Therefore, this timeline focuses on the <strong>conceptual progression and development of the N3/RDF graph database and its querying capabilities</strong> as presented in the source material.</p>
<p>- <strong>Ancient Greek Philosophy (Ontology's Origin):</strong> Ontology, as the "study of being, existence, and the fundamental categories of reality," originated from ancient Greek philosophy [Source: N3 Querying, I.A. Ontology and its Application].</p>
<p>- <strong>Mathematical Concept of Graphs:</strong> The abstract mathematical concept of graphs, comprising vertices (nodes) and edges (relations), forms the theoretical foundation [Source: Graph Databases, Types of Graphs; n3 p1]. Graphs can be connected, isolated, directed, undirected, complete, planar, or tree-like [Source: Graph Databases, Types of Graphs].</p>
<p>- <strong>Emergence of Ontology in Information Technologies:</strong> In IT, ontology describes a structured set of objects, their properties, and relationships. It is a formal, machine-readable representation of a domain [Source: N3 Querying, I.A. Ontology and its Application; Part 1].</p>
<p>- <strong>Development of Resource Description Framework (RDF):</strong> The World Wide Web Consortium (W3C) developed RDF as a standard for describing web resources, often represented in XML or N3 [Source: N3 Querying, I.C. Triplets (N3 and RDF); Part 1].</p>
<p>- <strong>Introduction of Notation3 (N3):</strong> N3 emerged as a compact, human-readable syntax for RDF, supporting logical expressions, designed for describing resources and relationships [Source: N3 Querying, I.C. Triplets (N3 and RDF); Part 1].</p>
<p>- <strong>Founding of the Graph Database Concept:</strong> Graph databases are defined as a type of database using graph structures (nodes, edges, properties) to store and represent data, particularly well-suited for semantic queries [Source: Graph Databases, Definition and Components; N3 Querying, I.B. Graph Databases].</p>
<p>- <strong>Establishment of Triplets as Fundamental Data Unit:</strong> The triplet (Subject, Predicate, Object) is established as the fundamental unit of data storage in N3/RDF graph databases [Source: Graph Databases, Relationship with Triplets; N3 Querying, I.C. Triplets (N3 and RDF); Part 1]. Directionality in triplets is crucial for defining relationships and structuring queries [Source: Graph Databases, Directionality].</p>
<p>- <strong>Development of Custom N3 Database Engine:</strong> The platform uses an SQLite engine for transactional aspects, but the core data model and logic for serializing/deserializing data between triplets and relational views are custom-developed and patented [Source: Graph Databases, Relationship with Triplets; N3 Querying, I.D. Data Storage; Part 1].</p>
<p>- <strong>Standardization of N3 Query Syntax and Execution:</strong> N3 queries operate directly on triplet structures, supporting sequential and iterative execution, with specific syntax elements for variables, prefixes, formulas, and literals [Source: Graph Databases, N3 Query Interaction; N3 Querying, II.A &amp; II.B].</p>
<p>- <strong>Introduction of Axioms and Derived Facts:</strong> The distinction between axioms (directly stored triplets) and derived facts (computed on-the-fly) is established, with calculated attributes being a prime example of derived facts [Source: Graph Databases, Types of Data in Triplets; N3 Querying, I.D. Data Storage].</p>
<p>- <strong>Ongoing Development and Optimization (Present):</strong> The platform continues to undergo significant development in N3 querying, including enhancements to built-in predicates, optimization strategies, and the introduction of a new expression compiler in version 3.6, with plans for a more advanced editor (F4.0) and DMN tables in future releases [Source: Part 2; n3 p1; n3 p2]. Documentation efforts are also underway to bring terminology into order for version 4.0 [Source: Part 2].</p>
<p>Cast of Characters</p>
<p>- <strong>Georgy (Георгий):</strong> The primary speaker and presenter in the "Part 1" and "Part 2" excerpts, responsible for explaining N3 querying, graph databases, and ontology. He is a technical expert, possibly a developer or solution architect, who designed the current N3 course and is familiar with the platform's architecture and optimization techniques. He also mentions developing parts of the system and its compiler.</p>
<p>- <strong>Anatoly (Анатолий):</strong> A participant in the discussion, frequently asking detailed, practical, and challenging questions about N3 querying, its application, performance, and integration with C# code. He seems to have a strong background in databases (relational algebra) and C# development, often referencing specific technical challenges he faces with the platform, such as calculating sums in words or managing processes. He also brings up the need for better documentation and alternative methods for process management.</p>
<p>- <strong>Alexander (Александр):</strong> Another participant who contributes to the discussion, sometimes clarifying Anatoly's questions or echoing concerns about specific features like calculated attributes. He also expresses interest in better process documentation and group work.</p>
<p>- <strong>Pavel (Паша):</strong> Mentioned by Georgy at the end of "Part 2" regarding the progress of activation issues, indicating he is involved in the technical support or development of the platform's licensing/activation mechanisms.</p>
<p>- <strong>Igor (Игорь):</strong> A colleague frequently referenced by Anatoly and Georgy. Igor is mentioned as a source for examples on global functions, C# integration, and specific technical solutions within the platform (e.g., calculated collections). He appears to be a key developer or technical resource.</p>
<p>- <strong>Anna (Анна):</strong> Briefly mentioned by Anatoly as someone, along with Igor, who might have implemented specific features related to process instance IDs in the past.</p>
<p>- <strong>Maxim Viktorovich (Максим Викторович):</strong> Mentioned briefly by Georgy in the context of a separate module for process documentation, indicating he is likely involved in product management or development strategy.</p>
<p>- <strong>Konstantin (Костя):</strong> Referenced as the author of a document ("Kostin's document") that provides examples and explanations, specifically regarding abstract concepts like apple characteristics. This suggests he is a technical writer or documentation specialist.</p>
<p>- <strong>Sergey (Серёжа):</strong> A colleague whose example code for a calculated property is used by Georgy to explain complex N3 expressions and execution flow. He is also mentioned in relation to the formatting of N3 code.</p>
<p>- <strong>Valery (Валерий):</strong> Likely a senior consultant or manager. Anatoly and Georgy frequently address him for strategic decisions, session scheduling, and overall platform direction (e.g., future features, documentation, support). He seems to be in a position of authority regarding coordination between the technical team and user needs.</p>
<p>--------------------------------------------------------------------------------</p>
<p>Graph Databases and N3 Querying: A Briefing</p>
<p>Detailed Briefing Document: Graph Databases and N3 Querying</p>
<p>1. Introduction to Graph Databases and Ontology</p>
<p>Graph databases are a specialized type of database that uses graph structures—nodes, edges, and properties—to represent and store data. This model is particularly well-suited for semantic queries, which focus on the meaning and relationships between data points.</p>
<p>1.1. Core Components: Nodes and Edges</p>
<p>- <strong>Nodes (Vertices):</strong> Represent entities or values. These can be abstract concepts like "Pencil Case" and "Pencil" or specific instances such as "Ivan Ivanovich" or a "Volvo car."</p>
<p>- <strong>Edges (Relations):</strong> Represent relationships between nodes. Edges can be directed or undirected, signifying connections like "Pencil Case contains Pencil" or "Person owns Car."</p>
<p>1.2. Application to Ontology</p>
<p>Graph databases naturally represent ontological models. In Information Technology, an <strong>ontology</strong> formally describes a set of objects, their properties, and the relationships between them. In an ontological model, nodes typically represent objects, classes, or instances, while edges represent the relationships between them. For example, "Person" and "Car" could be nodes, and "owns" would be an edge connecting them.</p>
<p>2. Triplet Fundamentals (N3 and RDF)</p>
<p>The fundamental unit of data storage in an N3/RDF graph database is a <strong>triplet</strong>.</p>
<p>2.1. Triplet Structure</p>
<p>A triplet consists of three essential parts: <strong>Subject</strong>, <strong>Predicate</strong>, and <strong>Object</strong>.</p>
<p>- <strong>Subject:</strong> The resource being described, acting as the source of the arrow in a graph.</p>
<p>- <strong>Predicate:</strong> The property or relationship, represented as the arrow itself.</p>
<p>- <strong>Object:</strong> The value or resource that the subject is related to, forming the destination of the arrow.</p>
<p><strong>Directionality</strong> is crucial for triplets; it explicitly defines the flow of a relationship (e.g., "Person owns Car" versus "Car owned_by Person"). This direction dictates which element is the Subject and which is the Object, and consequently, how queries must be structured.</p>
<p>2.2. N3 (Notation3) and RDF (Resource Description Framework)</p>
<p>- <strong>RDF:</strong> A W3C standard for describing resources, often represented in XML or N3.</p>
<p>- <strong>N3:</strong> A compact and human-readable syntax for RDF, supporting logical expressions. All data, whether systemic metadata or user-applied data, is stored as triplets in the the platform's N3 database.</p>
<p>2.3. Data Storage Mechanism</p>
<p>System models are described in .n3 files, while applied data (metadata and instances) are stored in separate files (e.g., data.n3). The platform uses an SQLite engine for transactional aspects, but the core data model and the logic for serializing/deserializing data between triplets and relational views are custom.</p>
<p>2.4. Types of Data in Triplets</p>
<p>- <strong>Qualified Name (QName):</strong> Shortened forms of long URIs (Uniform Resource Identifiers) used to represent resources, especially for complex types. QNames are typically used for subjects, predicates, and objects.</p>
<p>- <strong>Simple Literals:</strong> Direct values like strings ("blue"), numbers (5), booleans (true), dates, or durations.</p>
<p>- <strong>Complex Literals:</strong> Represent collections of facts or ordered sets of values, used in advanced queries.</p>
<p>- <strong>Formulas (</strong><strong>{...}</strong><strong>):</strong> A set of triplets evaluated together as a single unit.</p>
<p>- <strong>Lists (</strong><strong>(...)</strong><strong>):</strong> An ordered collection of values or variables.</p>
<p>- <strong>Axioms vs. Derived Facts:</strong></p>
<p>- <strong>Axioms:</strong> Facts directly stored as triplets in the database.</p>
<p>- <strong>Derived Facts:</strong> Computed on the fly based on axioms and the current context (e.g., calculated attributes) and are not stored in the database.</p>
<p>3. N3 Query Syntax and Execution</p>
<p>N3 queries operate directly on triplet structures, allowing for powerful data retrieval and manipulation within the graph database.</p>
<p>3.1. Core Syntax Elements</p>
<p>- <strong>Comments (</strong><strong>#</strong><strong>):</strong> For adding notes.</p>
<p>- <strong>Prefixes (</strong><strong>@prefix</strong><strong>):</strong> Define shortcuts for long URIs to improve readability.</p>
<p>- <strong>Variables (</strong><strong>?</strong><strong>):</strong> Denoted by a question mark followed by an alphanumeric name (e.g., ?item, ?value). They represent unknown values to be discovered.</p>
<p>- <strong>Triplet Terminator (</strong><strong>.</strong><strong>):</strong> Every triplet must end with a period.</p>
<p>- <strong>Formula Block (</strong><strong>{ ... }</strong><strong>):</strong> Defines a query block executed as a single unit, forming a single iterator result.</p>
<p>- <strong>Lists/Arrays (</strong><strong>( ... )</strong><strong>):</strong> Used to define ordered collections of values.</p>
<p>- <strong>Implicit Subject (</strong><strong>[ ... ]</strong><strong>):</strong> Square brackets can implicitly refer to the subject of the previous triplet.</p>
<p>- <strong>Reserved Keywords:</strong> a (for rdf:type - "is an instance of"), is ... of (inverse property).</p>
<p>- <strong>Assignment (</strong><strong>\=</strong><strong>):</strong> Assigns a value from one variable to another.</p>
<p>- <strong>Conditional (</strong><strong>if ... else ...</strong><strong>):</strong> Controls query flow. If the if condition is false and there's no else block, the query stops.</p>
<p>3.2. Query Execution Model</p>
<p>- <strong>Sequential Execution:</strong> Queries execute top-down, line by line.</p>
<p>- <strong>Iterative Processing:</strong> If a line (triplet) returns an iterator (multiple values), subsequent lines are executed for each value in that iterator, creating nested loops. An iterator's scope is confined to the formula/block it was created in. Once the block finishes, the iterator's result is passed as a single value (or a collection) to the next level.</p>
<p>- <strong>Optimization:</strong> "The order of triplets matters significantly for performance. Queries should start with the most restrictive conditions to minimize the size of initial iterators." This often means "flipping" the query to start from the most selective conditions rather than following a traditional relational database's "FROM-WHERE" pattern.</p>
<p>- <strong>Match vs. Search:</strong></p>
<p>- <strong>Search (unknowns):</strong> When one or more parts of a triplet are variables (e.g., ?S P ?O), the system searches the database for matching facts and populates the variables with iterators.</p>
<p>- <strong>Match (all known):</strong> When all parts of a triplet are known values, the system checks for the existence of that exact fact in the database, returning true or false. This does not return an iterator.</p>
<p>3.3. Common Query Patterns and Operators</p>
<p>- object:findProperty: A built-in predicate to retrieve the ID of an attribute given its template alias and attribute alias. It always returns a single ID and is highly optimized.</p>
<p>- assert:union: Combines the results of multiple iterators into a single iterator. assert:union true performs a "union all" (duplicates included).</p>
<p>- ones: Executes a query and returns only the first successful result, stopping further iteration once a match is found.</p>
<p>- or: Evaluates multiple conditions and returns true if any are met, stopping at the first successful condition.</p>
<p>- <strong>Built-in Functions:</strong> Special predicates (e.g., math:sum, time:dayOfWeek) that perform calculations in memory rather than querying the database.</p>
<p>- value and item: Reserved keywords for output and input parameters, respectively, in expressions. value stores the output, item refers to the current object in context.</p>
<p>4. Application Contexts for N3 Queries</p>
<p>N3 queries are used in various platform contexts to enable dynamic behavior and data processing.</p>
<p>- <strong>Calculated Attributes:</strong> Defined on a record template to compute a value dynamically. item is the input (current object ID), value is the output. Calculated on-the-fly and not stored in the database.</p>
<p>- <strong>List Filters:</strong> Used to filter records displayed in a list. item is the output (IDs of records to display).</p>
<p>- <strong>Operations (Conditional Display):</strong> Used to show or hide operations based on conditions (e.g., a "Complete Task" button). item is the input (current record ID), value is true (show) or false (hide).</p>
<p>- <strong>Business Rules (Triggers/Scenarios):</strong> Define actions that execute based on specific events (e.g., a field change).</p>
<p>- <strong>Global Functions:</strong> External functions (e.g., written in C#) that can be invoked from N3 queries. "Allows for code reusability and complex computations not directly expressible in N3." They can retrieve data from external services or perform custom logic.</p>
<p>5. Key Distinctions and Best Practices</p>
<p>- <strong>Calculated Attributes vs. Stored Data:</strong> "Calculated attributes are always computed on demand and are never stored in the database." They are "computed at the moment of access." Changes to underlying stored data will trigger re-calculation. Axioms are directly stored facts.</p>
<p>- <strong>Query Optimization:</strong> Begin with highly selective conditions to reduce the size of iterators early in the query execution.</p>
<p>- <strong>Understanding Iterators:</strong> The nested loop nature of N3 query execution means careful structuring can lead to significant performance differences.</p>
<p>- <strong>Contextual Variables:</strong> item, value, current user, now are context-dependent and reserved.</p>
<p>This briefing provides a comprehensive overview of graph databases, triplet fundamentals, N3 querying, and its practical applications, drawing directly from the provided source material.</p>
<p>--------------------------------------------------------------------------------</p>
<p>Graph Databases: N3 Querying Fundamentals Explained</p>
<p>Here's an 8-question FAQ based on the provided sources, with thorough answers:</p>
<p>Frequently Asked Questions about Graph Databases and N3 Querying</p>
<p>What is the primary purpose of an "ontology" in the context of information technologies?</p>
<p>In information technology, an ontology serves as a formal description of a set of objects, their properties, and the relationships between them within a specific domain or the real world. Its primary purpose is to provide a structured, machine-readable representation of knowledge, allowing systems to understand and process information in a more meaningful way. It acts as a blueprint for data organization, defining "what exists" within a given sphere of interest.</p>
<p>How does a "graph database" fundamentally represent data, and what are its two main components?</p>
<p>A graph database fundamentally represents and stores data using <strong>graph structures</strong>, which are exceptionally well-suited for semantic queries. Its two main components are <strong>nodes</strong> (or vertices) and <strong>edges</strong> (or relations). Nodes represent entities or values (such as classes, instances, or literal values), while edges represent the relationships between these nodes. Edges can be either directed or undirected, indicating how different entities are connected (e.g., "Person owns Car"). This structure naturally aligns with ontological models.</p>
<p>Explain what a "triplet" is and identify its three essential parts in the N3/RDF model.</p>
<p>A triplet is the fundamental unit of data storage in an N3/RDF graph database, representing a single fact or statement. It consists of three essential parts:</p>
<p>1. <strong>Subject:</strong> The resource or entity being described, acting as the source of the arrow in a graph.</p>
<p>2. <strong>Predicate:</strong> The property or relationship that connects the subject and object, represented as the arrow itself.</p>
<p>3. <strong>Object:</strong> The value or resource that the subject is related to, forming the destination of the arrow. For example, in the triplet "Person owns Car," "Person" is the Subject, "owns" is the Predicate, and "Car" is the Object.</p>
<p>Why is the "directionality" of a relationship important when defining triplets in the N3 database?</p>
<p>The directionality of a relationship is crucial in N3 triplets because it explicitly defines the flow and meaning of that relationship. For instance, "Person owns Car" has a different meaning than "Car owned_by Person." This direction determines which element is the Subject and which is the Object in a triplet, directly influencing how data is stored and, consequently, how N3 queries must be structured to retrieve specific information. Understanding directionality is key to correctly constructing queries and interpreting results.</p>
<p>What is the difference between an "axiom" and a "derived fact" in the N3 database, and how does this relate to "calculated attributes"?</p>
<p>In the N3 database, an <strong>axiom</strong> is a fact that is directly stored as a triplet within the database. It represents explicit, persistent data. In contrast, a <strong>derived fact</strong> is not directly stored but is computed or inferred on the fly based on existing axioms and the current context of a query. <strong>Calculated attributes</strong> are a prime example of derived facts; their values are dynamically computed whenever they are requested and are never permanently saved in the database. This distinction allows for dynamic data generation and ensures that certain values are always up-to-date without explicit storage.</p>
<p>Describe the role of "variables" (e.g., ?item, ?value) in N3 queries.</p>
<p>Variables in N3 queries, identified by a question mark prefix (e.g., ?item, ?value), serve as placeholders for unknown values that the query aims to discover or populate. When an N3 query is executed, the system searches the database for triplets that match the known parts of the query pattern and then populates these variables with the corresponding data. If multiple matches are found, variables often return an "iterator," allowing subsequent query lines to process each matching value. ?item and ?value are reserved variables often used for input (current object ID) and output (query result) parameters in specific contexts like calculated attributes or list filters.</p>
<p>How does the sequential and iterative execution model of N3 queries impact their performance?</p>
<p>The sequential and iterative execution model of N3 queries significantly impacts performance. Queries execute top-down, line by line. If a line (or triplet) returns an iterator (multiple values), subsequent lines are executed for <em>each</em> value within that iterator. This creates nested loop-like processing, where deeper iterators cause the upper levels to re-evaluate repeatedly. Therefore, <strong>optimization is crucial</strong>: queries should always start with the most restrictive conditions. By minimizing the size of initial iterators, the overall number of operations performed in subsequent nested loops is drastically reduced, leading to much faster query execution. Failing to do so can lead to substantial performance degradation.</p>
<p>Explain the function of the operator in N3 queries.</p>
<p>The assert:union operator in N3 queries is used to combine the results of multiple query blocks or iterators into a single, unified iterator. When assert:union true is specified, it performs a "union all" operation, meaning that duplicate values from the combined iterators will be included in the final result. This is particularly useful when you need to gather data from different, potentially overlapping, sources or conditions and present them as a single collection, allowing for further processing or filtering on the combined set.</p>
<p>--------------------------------------------------------------------------------</p>
<p>Graph Databases: Structure, Ontology, and Triplet Fundamentals</p>
<p><strong>Graph databases</strong> are a type of database that uses <strong>graph structures</strong> to represent and store data, which is particularly well-suited for semantic queries [1]. In this context, data is organized using <strong>nodes</strong>, <strong>edges</strong>, and properties [1].</p>
<p>Here's a breakdown of graph databases:</p>
<p>- <strong>Definition and Components</strong></p>
<p>- A graph database fundamentally represents data using <strong>graph structures</strong> [1].</p>
<p>- Its two main components are: * <strong>Nodes (Vertices):</strong> These represent entities or values. Examples include classes, instances, or literal values [1-3]. In the context of the platform, nodes can represent abstract concepts like "Pencil Case" and "Pencil," or specific instances like "Ivan Ivanovich" or a "Volvo car" [4, 5]. * <strong>Edges (Relations):</strong> These represent <strong>relationships</strong> between nodes. Edges can be either directed or undirected [1, 2]. They signify how different entities are connected, such as "Pencil Case contains Pencil" or "Person owns Car" [4, 5].</p>
<p>- <strong>Types of Graphs</strong></p>
<p>- Graph databases can support various types of graphs, including connected, isolated, directed, undirected, complete, planar, and tree-like graphs [1, 2].</p>
<p>- <strong>Application to Ontology</strong></p>
<p>- Graph databases naturally represent <strong>ontological models</strong> [1]. An ontology, in information technology, describes a set of objects, their properties, and the relationships between them [4, 6].</p>
<p>- In an ontological model, <strong>nodes</strong> typically represent objects, classes, or instances, while <strong>edges</strong> represent the relationships between them [1, 5, 7]. For example, "Person" and "Car" could be nodes, and "owns" would be an edge connecting them [5].</p>
<p>- <strong>Relationship with Triplets (N3 and RDF)</strong></p>
<p>- The fundamental unit of data storage in an N3/RDF graph database is a <strong>triplet</strong> [8-11].</p>
<p>- A triplet consists of three essential parts: <strong>Subject</strong>, <strong>Predicate</strong>, and <strong>Object</strong> [6, 8, 12, 13]. * The <strong>Subject</strong> is the resource being described, acting as the source of the arrow in a graph [8, 12, 13]. * The <strong>Predicate</strong> is the property or relationship, represented as the arrow itself [8, 12, 13]. * The <strong>Object</strong> is the value or resource that the subject is related to, forming the destination of the arrow [8, 12, 13].</p>
<p>- <strong>Directionality</strong> is crucial for triplets; it explicitly defines the flow of a relationship (e.g., "Person owns Car" versus "Car owned_by Person") [6, 8, 14]. This direction dictates which element is the Subject and which is the Object, and consequently, how queries must be structured [6, 8, 14].</p>
<p>- <strong>N3 (Notation3)</strong> is a compact and human-readable syntax used for RDF, which also supports logical expressions [8, 15]. All data, whether systemic metadata or user-applied data, is stored as triplets in the N3 database [9, 10, 16].</p>
<p>- In an N3 database, system models are described in .n3 files, while applied data (metadata and instances) are stored in separate files, such as data.n3 [9, 16].</p>
<p>- The platform uses an SQLite engine for transactional aspects, but the core data model and the logic for serializing/deserializing data between triplets and relational views are custom [9, 16].</p>
<p>- <strong>Types of Data in Triplets</strong></p>
<p>- <strong>Qualified Name (QName):</strong> These are shortened forms of long URIs (Uniform Resource Identifiers) used to represent resources, especially for complex types [9, 17]. QNames are typically used for subjects, predicates, and objects [9, 17, 18].</p>
<p>- <strong>Simple Literals:</strong> These are direct values like strings ("blue"), numbers (5), booleans (true), dates, or durations [9, 19].</p>
<p>- <strong>Complex Literals:</strong> These represent collections of facts or ordered sets of values, used in advanced queries [9]. * <strong>Formulas (</strong><strong>{...}</strong><strong>):</strong> A set of triplets that are evaluated together as a single unit [9, 20-22]. * <strong>Lists (</strong><strong>(...)</strong><strong>):</strong> An ordered collection of values or variables [9, 20, 21, 23].</p>
<p>- <strong>Axioms vs. Derived Facts:</strong> * <strong>Axioms</strong> are facts directly stored as triplets in the database [9, 20, 24]. * <strong>Derived Facts</strong> are computed on the fly based on axioms and the current context (e.g., calculated attributes) and are not stored in the database [9, 20, 24, 25].</p>
<p>- <strong>N3 Query Interaction with Graph Databases</strong></p>
<p>- N3 queries operate directly on these triplet structures [16, 26]. When parts of a triplet are variables (e.g., ?S P ?O), the system performs a <strong>search</strong> in the database to find matching facts and populate the variables with iterators [26-28].</p>
<p>- If all parts of a triplet are known values, the system performs a <strong>match</strong> to check for the exact fact's existence, returning true or false [26, 28, 29].</p>
<p>- The sequential and iterative execution model of N3 queries means that the order of triplets significantly impacts performance, as queries should start with the most restrictive conditions to minimize the size of initial iterators [26, 30, 31]. This often means "flipping" the query to start from the most selective conditions rather than following a traditional relational database's "FROM-WHERE" pattern [32].</p>
<p>- An N3 query effectively "walks" the graph, moving from one node to another via edges (predicates) to retrieve or verify information [31].</p>
</article>
</div>
</div>
<a class="md-top md-icon mkdocs_imported_link" data-md-component="top" href="#">
<i class="fa-light fa-arrow-up">&zwnj;<!--icon--></i>
            К началу
          </a>
</main>
</div>
<script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": true, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></div>