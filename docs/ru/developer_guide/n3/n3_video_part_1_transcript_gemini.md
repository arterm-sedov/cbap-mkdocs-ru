### Подробное резюме и объяснения

Этот видеофрагмент представляет собой обучающую сессию или лекцию, посвященную основам работы с графовой базой данных и ее языком запросов, который участники называют "тройками" или "выражениями". Целевая аудитория — новички, которым необходимо понять фундаментальные концепции для дальнейшей работы.

#### 1. Введение и цель
*   **Цель:** Создать обучающий материал (вероятно, для внутренней базы знаний или видеокурса) для клиентов и сотрудников (в частности, для Сбербанка).
*   **Задачи:**
    1.  Объяснить, что такое "тройки" (триплеты).
    2.  Научить читать и понимать их.
    3.  В перспективе — научить писать их самостоятельно.
*   **Предварительные требования:** Лекторы приходят к выводу, что для понимания материала необходимы базовые знания о графах. Без этого контекста концепция "троек" кажется сложной и непонятной.

#### 2. Основы графовой базы данных
Лектор (Георгий) начинает с самых основ:

*   **Граф:** Система состоит из **узлов** (сущностей) и **ребер** (связей, отношений между ними). В их системе граф **направленный**, то есть ребро (связь) имеет направление от одного узла к другому (обозначается стрелкой).
*   **Стандарт RDF:** Их база данных основана на стандарте **RDF (Resource Description Framework)**, разработанном консорциумом W3C. Это стандарт для представления данных в виде графа, который лежит в основе семантической паутины (Semantic Web).
*   **Триплеты (Triples):** Основной единицей хранения информации в графе является **триплет**. Это атомарный факт, состоящий из трех частей:
    *   **Subject (Субъект):** Узел, от которого исходит связь.
    *   **Predicate (Предикат):** Сама связь или свойство.
    *   **Object (Объект):** Узел или значение, к которому ведет связь.
*   **Пример:** На доске приводится наглядный пример фразы "мама мыла раму", где:
    *   `мама` — Subject
    *   `мыла` — Predicate
    *   `раму` — Object
    Это показывает, как утверждение на естественном языке можно разложить на структуру "субъект-действие-объект".
*   **Ориентированность:** Направленность графа важна. Пример "Миша сын Васи" создает связь `(Миша) --сын--> (Вася)`. Это не то же самое, что `(Вася) --сын--> (Миша)`. Для обратного отношения используется **инверсный предикат**: `(Вася) --папа--> (Миша)`. В их платформе это реализовано через `инверс-проперти`.

#### 3. Типы данных и идентификация
*   **URL/URI как идентификаторы:** Сущности в графе (субъекты, предикаты и сложные объекты) — это не просто строки, а **ресурсы**, которые однозначно идентифицируются через **URL** (или, более обще, URI). Пример: `https://www.commandware.com/ontology/user#42` однозначно идентифицирует пользователя с ID 42.
*   **Префиксы:** Чтобы не писать длинные URL каждый раз, используются **префиксы** (аналог `namespace` в программировании). Например, длинный URL `http://.../ontology/Object#FineProperty` можно сократить до `object:FineProperty`, где `object:` — это префикс, заменяющий `http://.../ontology/Object#`.
*   **Типы объектов:**
    *   **Ресурсы (сложные типы):** Субъекты и предикаты почти всегда являются ресурсами (идентифицируются URL). Объекты тоже могут быть ресурсами (например, в тройке `(Миша) --сын--> (Вася)`, и Миша, и Вася — ресурсы).
    *   **Литералы (простые типы):** Объекты могут быть и простыми значениями, такими как строки, числа, даты, булевы значения (`true`/`false`). Пример: `(Заявка_123) --приоритет--> "Высокий"`.

#### 4. Введение в язык запросов и выражений
Лектор переходит к синтаксису языка, который используется для работы с базой данных (запросов, вычислений, правил).

*   **Сложные литералы:** В языке есть два основных типа сложных структур:
    1.  **Формула `{ ... }`:** Это набор триплетов (утверждений или паттернов), заключенных в фигурные скобки и разделенных точками. Формула представляет собой подграф или условие.
    2.  **Список `( ... )`:** Это упорядоченный набор элементов (ресурсов или литералов), разделенных пробелами и заключенных в круглые скобки. Используется для передачи нескольких аргументов в функции.

*   **Правила вывода (`log:implies` или `<=`):** Это ключевая концепция, позволяющая выводить новые факты из существующих. Правило имеет вид: `Левая_часть <= Правая_часть`.
    *   **Чтение:** "Если `Правая_часть` истинна, то `Левая_часть` также истинна". (Примечание: в видео лектор говорит наоборот, но по синтаксису и логике это правило вывода, где из "тела" следует "голова"). В их синтаксисе `A <= B` означает "A следует из B".
    *   **Правая часть (тело правила, конъюнкция):** Это набор условий (фильтров) в виде формулы. Все условия в ней должны быть истинны одновременно (логическое "И").
    *   **Левая часть (голова правила, дизъюнкция):** Это новый факт (триплет), который считается истинным, если тело правила выполнилось.

*   **Переменные (`?имя`):** В запросах и правилах используются переменные, начинающиеся с `?`. Они служат для поиска неизвестных значений. Например, в запросе `?item op:42 ?title` система найдет все узлы (`?item`), у которых есть свойство `op:42`, и вернет их значения в переменную `?title`.

*   **Вычисляемые свойства и `built-in` предикаты:**
    *   Некоторые предикаты не ищут данные в базе, а выполняют вычисления. Например, `math:sum` суммирует список чисел, а `format` форматирует строку.
    *   Такие предикаты называются **built-in**. Они являются частью языка.
    *   **Аксиомы vs. Выводимые факты:**
        *   **Аксиомы** — это факты, которые физически хранятся в базе данных.
        *   **Выводимые (inferred) факты** — это факты, которые не хранятся, а вычисляются "на лету" с помощью правил в момент запроса. Это позволяет хранить меньше данных и поддерживать их консистентность автоматически.

#### 5. Механизм выполнения запроса (Backtracking)
Лектор подробно объясняет, как движок выполняет запрос, состоящий из нескольких паттернов (триплетов).

*   **Энумератор/Итератор:** Каждый паттерн в запросе возвращает не сразу все результаты, а специальный объект — **энумератор** (или итератор). Этот объект позволяет перебирать найденные соответствия по одному. У него есть методы типа `MoveNext` (перейти к следующему результату) и `GetCurrent` (получить текущий результат).
*   **Перебор с возвратом (Backtracking):**
    1.  Движок берет первый паттерн, находит для него первое совпадение в базе и "биндит" (присваивает) значения переменным.
    2.  Затем он переходит ко второму паттерну, подставляя уже известные значения переменных, и пытается найти для него совпадение.
    3.  Если совпадение найдено, он идет дальше. Если нет — он **возвращается** к предыдущему паттерну (`backtrack`), просит у его энумератора следующее значение (`MoveNext`) и повторяет попытку.
    4.  Этот процесс продолжается, пока не будут перебраны все возможные комбинации совпадений для всех паттернов в запросе.
*   **Пример с несколькими значениями:** Если для объекта есть несколько значений свойства `title` (например, "Low" и "High"), движок сначала найдет "Low", пройдет по остальным условиям, вернет результат. Затем он вернется, найдет "High" и снова пройдет по остальным условиям, вернув второй результат. Если бы у `ID` тоже было несколько значений, получился бы декартово произведение (перемножение) всех комбинаций.

Эта сессия закладывает основу для понимания декларативной природы языка запросов, где пользователь описывает, *что* он хочет найти, а движок сам определяет, *как* это сделать, используя механизм перебора и сопоставления с образцом (pattern matching).

### Транскрипция видеозаписи

***

##### `00:00:00` — `00:00:37`
**Видео:**
В кадре видна часть офисного помещения. Слева на стене висит белая маркерная доска с едва заметными надписями. На доску падают блики от потолочных ламп. В центре кадра стоит офисное кресло серого цвета. Справа — большая часть экрана затемнена, в центре этого темного поля находится круглое окошко с видеозвонком, в котором виден мужчина (Георгий Полян).
Мужчина в черной футболке подходит к креслу, кладет на него руку. Он поворачивается к доске.

**Речь:**
*   **[Неразборчиво]:** Все пропало.
*   **[Мужской голос]:** А выдвинуть нельзя?
*   **[Неразборчиво]:** Огонь.
*   **[Мужской голос]:** Здесь ничего не видно будет.
*   **[Мужской голос]:** Ничего не увидишь, да.
*   **[Мужской голос]:** Единственный вариант — это фотать… и потом вставлять в видео слайды…
*   **[Мужской голос]:** Ну, так нормально, да, в целом, можно…
*   **[Мужской голос]:** Да, да, да, фотать.

##### `00:00:37` — `00:01:27`
**Видео:**
Человек в черной футболке отходит от кресла. В кадре появляется другой мужчина в черной футболке, подходит к доске с красным маркером в руке, готовится начать лекцию.

**Речь:**
*   **[Мужской голос]:** Ну что, начнем?
*   **[Мужской голос 2]:** Начнем. Задавайте вопросы, что в прошлый раз непонятно было.
*   **[Мужской голос]:** Да, смотри, в чем суть. Мы для клиентов, и отдельно Сбербанк попросил это… Мы на основе этого сделаем… ну, как бы…
*   **[Мужской голос]:** …есть потребность, чтобы люди, и клиенты, и…
*   **[Мужской голос 2]:** Клиенты — не люди.
*   **[Мужской голос]:** …в частности Сбербанк…
*   **[Мужской голос 2]:** Совсем не люди, да.
*   **[Мужской голос]:** …могли, во-первых, иметь понимание троек, понимали, из чего они состоят, как они работают. Ну и в идеальном случае могли уметь их писать, научиться.
*   **[Мужской голос 2]:** Сначала читать, потом писать, да.
*   **[Мужской голос 3]:** А потом уже можно будет писать.
*   **[Мужской голос]:** Вот. Э-э… но мы как бы… тебе оставим честь нам определить, какой у нас входной порог, да, то есть какие, ну, требуются знания, чтобы вообще вот… начинать понимать это.

##### `00:01:27` — `00:02:27`
**Видео:**
Слева в кадр входит мужчина в розовой футболке (поло), он становится основным лектором. Мужчина в черной футболке отходит в сторону.

**Речь:**
*   **[Мужской голос 2]:** Я думаю, что надо изначально рассказать тогда про графовую базу.
*   **[Мужской голос]:** Да, ну, да-да-да. Мы пообщались, потому что даже там тому же Андрею, Вахиду… до этого они вообще как-то тройки просто ну… поменять айдишник, как в тройке там, на таком уровне. А когда вот на прошлой неделе чуть-чуть про базу там Георгий рассказал, у них в голове что-то начало…
*   **[Мужской голос 3]:** Укладываться.
*   **[Мужской голос]:** Укладываться, да. Поэтому, видимо, да, вот объяснить, как работает база — это первый шаг, первое, что нужно знать. А дальше уже по ходу дела, то есть, может быть, что-то еще, то есть…
*   **[Мужской голос 3]:** Ну сначала база, потом как бы ризонер, наверное, все, больше особо ничего нет.

##### `00:02:27` — `00:03:34`
**Видео:**
Лектор в розовой футболке (Георгий) берет черный маркер и начинает рисовать на доске. Он рисует простой направленный граф: два круга (узлы) и стрелку между ними. Затем рисует более сложный граф с шестью узлами, пронумерованными от 1 до 6, и соединяет их стрелками. Рядом с графом он записывает соответствующие триплеты: `1 2 3`, `4 2 5`, `3 6 5`.

**Речь:**
*   **[Георгий]:** Да, ну что, короче, графовая база у нас, да. Да, все знают, что такое граф. У нас направленный, да, то есть узел, стрелочка, узел.
*   **[Мужской голос 2]:** Лучше с нуля, из математики понятие, да?
*   **[Георгий]:** Вот. Это обычное понятие. Бывает граф ненаправленный, когда стрелочки нет, бывает направленный. В нашем случае граф направленный. Вот. Это номер один. Вообще про наш граф можно почитать на W3.org. Это стандартный семантический граф, который построен на базисах RDF, так есть Resource Description Framework. Вот, там есть словарик и так далее. Хранится у нас граф в виде триплетов. То есть если мы здесь вот для простоты возьмем, допустим, один, два, три, четыре, пять, шесть. Так сделаем. У нас будет написано в каждой триплете это вот: 1 2 3, 4 2 5, 3 6 5.

##### `00:03:34` — `00:05:14`
**Видео:**
Георгий пишет на доске: `Subject`, `Predicate`, `Object`, указывая на соответствующие части триплета `1 2 3`. Затем стирает это и пишет пример: "мама мыла раму".

**Речь:**
*   **[Георгий]:** То есть каждый триплет — это просто, на самом деле, связь… откуда выходит стрелочка, стрелочки, ну то есть сама эта вторая, и как бы куда она приходит. По RDF'у это называется Subject, Predicate, Object.
*   **[Мужской голос 2]:** На русском языке… Что есть что? Subject — это…
*   **[Георгий]:** Subject, predicate, object. А… Первая часть называется Subject, вторая Predicate, это Object. СПО, стандартный триплет или СПО в сокращении, оно называется Subject-Predicate-Object. Да, на них описываются такие вот направленные графы элементарно. Ну, понятно, да, что можно любой такой граф описать вот такой фигней.
*   **[Мужской голос 3]:** Пример какой-нибудь, может, более понятный? Вам понятно или вы?..
*   **[Мужской голос 2]:** Ну да, пример нужен какой-то реальный.
*   **[Георгий]:** Ну, конечно, сейчас скажем, да. То есть теперь давайте поговорим о конкретных графах, которые… на более простой язык сейчас перейдем, потом перейдем к нашим, которые у нас вообще конкретно словари есть. То есть про RDF сейчас пока не говорим, да? Обычно вот этот триплет выглядит так. Вот самый простой — это мама мыла раму. То есть мама у нас, понятно, да? Subject, мыла — Predicate, раму — Object.

##### `00:05:14` — `06:57`
**Видео:**
Георгий пишет на доске другие примеры: "папа смотрел на маму" и "Миша сын Васи", затем "Вася папа Миши". Он объясняет концепцию инверсных предикатов. Затем он пишет на доске длинный URL: `https://www.commandware.com/ontology/user#42`.

**Речь:**
*   **[Георгий]:** Дальше можно построить там папа смотрел на это вместе, маму.
*   **[Мужской голос 2]:** То, что он ориентированный, со стрелочкой, это какое свойство дает?
*   **[Георгий]:** Ну, так вот, то что слева — это справа. Сейчас еще более понятно… назовем, то есть, более такой понятный… там, например, там Миша сын Васи. Ну, такого, кривое, да? То есть, по сути, это у Миши есть сын Вася, да? Это вот это направление, в обратную сторону не работает. То есть, просто так нельзя сказать, что у Васи сын Миша, вот в эту сторону. Да? Можно сказать вот так вот: Вася папа Миши. То есть, это называется инверсные предикаты, обратные предикаты, когда у тебя в одну сторону отношение есть, соответственно, если ты его инвертируешь, у него другое отношение. У нас это есть тоже.
*   **[Мужской голос 3]:** То есть объект, свойство и как бы значение.
*   **[Георгий]:** Значение… Ну, по сути, да.
*   **[Мужской голос 4]:** Здесь два объекта. Здесь в этом смысле…
*   **[Георгий]:** Ну, здесь у тебя референс. То есть если посмотреть на нашу платформу, так работают референс-филды, да, когда у вас, грубо говоря… одна… один какой-то record type ссылается на другой record type. Вот так работает. А есть обратные ссылки, да, по которым… вы им тоже даете название, на самом деле, при настройке платформы. Вот по сути, вот, вы выставляете одного предиката, его инверс-проперти название. В базе это хранится, на самом деле, один раз всего лишь, вот само это отношение. Есть вопросы?
*   **[Мужской голос 2]:** А как определяется порядок?
*   **[Георгий]:** Без разницы. Порядка нет. То есть от того, что вот так вот написано, то есть в таком порядке... строчка 1, это строчка 2, это строчка 3... без разницы. Граф весь целиком загружается. То есть как перемены мест слагаемых, не меняется тут ничего.

##### `06:57` — `08:49`
**Видео:**
Георгий пишет на доске пример сложного литерала, используя синтаксис с фигурными скобками, переменными (`?item`), префиксами (`op:`) и функцией `format`.

**Речь:**
*   **[Георгий]:** Не все подряд можно запихать в Subject, Predicate и Object. У нас есть разные типы внутренние, да, скажем так, узлов. То есть самый простой тип, который у нас есть — это базовый, так скажем, qualified name. По RDF'у это… вообще по RDF'у любая фигня, которая здесь написана, она должна в URL превращаться и однозначно резолвиться, URL, знаете, да? ...и однозначно определяться этим узлом. То есть, просто так абстрактного папу обычно не пишут, да, то есть пишут какого-то конкретного, длинный URL такой, и там папа, да? Соответственно, как можно сказать, то есть у нас есть всякие там идентификаторы, а-а, там, наши понятия класса и прочие штуки, вот они, это вот в URL обычно превращаются, и это называется qualified name, fully qualified name внутри. То есть, ну и они как бы в тройках, они как бы, синтаксис троек такой обычный, то есть никто не любит писать вот так вот фигак, и тут там https://www.commandware.com/ontology/user#42. Никто такой фигней не хочет... Да, все любят префиксы.
*   **[Мужской голос 2]:** Вот там, вот если бы мы вот это написали, вы там что хранится, там…
*   **[Георгий]:** Это вот, по сути, вот этот сабжект так записывается. Предикат тоже бы записался… Ну, то есть, если…
*   **[Мужской голос 2]:** А пример, вот реальный пример с платформы вот сабжекта, ну что…
*   **[Георгий]:** Какой сабжект в платформе? Ну, ты открой экран сейчас, я покажу тебе, есть… Вот этот ObjectFineProperty, он через префикс расшифровывается полностью вот так. Для того, чтобы такие не писать длиннющие слова, как бы, все равно они никому не нужны, они нечитаемые, вот просто сокращенная форма, записывают, что object:FineProperty. Это типа namespace, если брать с программирования, аналог, то есть это область, где лежат знания, скажем, да, вот об этих словах.
*   **[Мужской голос 4]:** В данном случае FineProperty в базе, наверное, все-таки не лежит.
*   **[Георгий]:** Без разницы, мы про базу не говорим сейчас, это про определение троек. То есть как бы, да, какие слова использовать можно. Вот. Это вот самый такой базовый ваш, который расшифровывается, а дальше бывают, значит, следующих типов. Сабжекты обычно либо сложные литералы, о которых чуть позже, либо вот такие же точно, а объекты — это обычно там либо value-типы, либо тоже такие. Value-типы — это, например, дата, это, например, число, это строка, и так далее. То есть если мы говорим про какую-то нашу заявку, когда мы… сабжект у неё будет что-нибудь там… User Ontology, ну, то есть, здесь Commandware наша, это бла-бла-бла, да, User Ontology, слэш там, решётка. Это типа будет префикс такой User Objects. И значит, какая-то конкретная заявка, когда мы откроем, открой конкретную заявку какую-нибудь, пофиг какую. Вот это вот ID, вот видите, 1861, да, заканчивается, то на самом деле это будет вот… 1861. Вот эта фигня полностью вот этот объект, это это рут этого объекта, то есть основное понятие про него. Дальше у него есть вот два свойства: Title и Русское название. То есть там будет записано вот это… не знаю, там, ничего не знаю, ну там какой-то будет prop, двоеточие, 42, ну вот так же, как prop — это какой-то префикс. И дальше написано там Минск.

##### `08:49` — `12:40`
**Видео:**
Георгий стирает с доски и пишет новый пример, используя стрелку `<-` для обозначения логического вывода. Он объясняет, что это предикат `log:implies`. Он рисует примеры запросов (паттернов), используя вопросительные знаки для обозначения переменных.

**Речь:**
*   **[Георгий]:** Этот наш волшебный язык Expression'ов, он сам по себе двух типов. Один называется формула и обозначается вот в фигурных скобочках. Что он находится в формуле? В формуле находится набор фактов там, ну или стейтментов. То есть они есть факт, стейтмент, одинаково называются, то есть набор триплетов. То есть еще раз, триплет - это там Subject-Predicate-Object. А вот эта формула - это, короче, Т1, Т2, Т3, разделенных точками.
*   **[Мужской голос 2]:** Что ты слышал?
*   **[Георгий]:** Нет.
*   **[Мужской голос 2]:** Лист вот так.
*   **[Георгий]:** Каждый триплет через точку. В листе просто через пробел.
*   **[Мужской голос 2]:** Не через запятую?
*   **[Георгий]:** Да. То есть вот это, это свойство.
*   **[Мужской голос 3]:** Ну почему свойство? Это просто перечисление такое вот. Просто перечисление каких-то, какой-то коллекции, не коллекции, чего хочешь назови.
*   **[Георгий]:** Вот это - это просто там N, N, N.
*   **[Мужской голос 2]:** Что ты про N...
*   **[Георгий]:** Ну, N - это вот, базовый тип для вот этого сабджекта, предиката, объекта. Считаем, что у всех базовый тип - просто слово там, ну, слово.
*   **[Мужской голос 2]:** В качестве N могут быть как значения, так и какие-нибудь вот эти вот сложные типы.
*   **[Георгий]:** Да, URL'ы.
*   **[Мужской голос 2]:** Алло? Да-да. Нет, сейчас неудобно, через часа два. Да, спасибо, до свидания.
*   **[Георгий]:** То есть вот здесь вот в этом примере, я не знаю, видно вам или нет, вот здесь слева написано: WorkItem и WorkPlan через пробел. Это вот пример списка такой фигни.
*   **[Мужской голос 4]:** Где? Какая строчка?
*   **[Георгий]:** Ну, просто при...
*   **[Мужской голос 4]:** Выдели.
*   **[Георгий]:** Вот.
*   **[Мужской голос 4]:** А где третий?
*   **[Георгий]:** Какой третий?
*   **[Мужской голос 4]:** В функции Union тоже она принимает же внутри этих скобочек все равно формулу.
*   **[Георгий]:** Это формула. Это список. В списке просто перечисление там 30 сабжектов подряд лежат, да?
*   **[Мужской голос 2]:** А, так, а...
*   **[Георгий]:** А в формуле - это стейтменты, это тройки.
*   **[Мужской голос 4]:** Ну, там от одного... ну, скажем, тот же самый, там набор формул.
*   **[Георгий]:** Да, Union объединяет набор формул.
*   **[Мужской голос 2]:** Применительно это где, зачем?
*   **[Георгий]:** Блин, к тройкам сейчас будешь это применять.
*   **[Мужской голос 2]:** Формула - это чтобы...
*   **[Георгий]:** Сейчас ты увидишь. Вот этот вот синтаксический сахар так называемый на предикат `log:implies`. Это то, что, которое, ну, можно почитать на V3.org, но читается и следует так: из вот этой фигни следует вот эта фигня. Любят еще это называть конъюнкцией, это дизъюнкцией. Если вам совсем хочется почитать.
*   **[Мужской голос 3]:** Если ораторский рынок не хватает вам...
*   **[Георгий]:** Из этого вот это. Самое простое, как это, ну, в нашей базе реализация, зачем это... Не, ну, зачем... сначала на простых вещах объясним, чтобы сразу в базу. То есть, например, из ящика яблоки...
*   **[Мужской голос 4]:** Зеленые!
*   **[Георгий]:** Знаете такую контекстную переменную now? Видели где-нибудь там?
*   **[Мужской голос 2]:** Угу.
*   **[Георгий]:** Ну, окей. Можно такое выражение написать, например. Вот этот now, который там пока не будем говорить, каким образом туда пришел, без разницы. Now... `dayOfWeek`... есть такой у нас предикат тоже из нашего домена "время", по-моему, да? Из namespace "время". `Friday`. Следует, что, ну, еще можно так сказать, `now dayOfWeek, Friday`. Следует, что `now timeOfDay`... ну, сейчас я не знаю, как он называется. `time > 18:00`. Больше тоже, по-моему, так писать нельзя, поэтому здесь лучше напишем по-честному `math:greaterOrEqual`. И когда... образно, да, то есть есть специальная форма записи констант для даты и времени, можете просмотреть и написать.
*   **[Мужской голос 2]:** О, пока.
*   **[Георгий]:** `Home`. Вот. Что написано? Опять же, вот левая часть выражения, конъюнкция, вот правая дизъюнкция. Что выводится? Выводится, что всем пора идти домой, да? Вот, ну, такая новая... новая тройка выводится, да, по сути. Как будто она присутствует. Когда она валидна эта тройка? Когда вот эта штука отработает и скажет, что правда все эти условия соблюлись. Что здесь написано? Взять now, который как бы в каждый момент выполнения запроса будет свой, да, то есть сейчас now один, через час now другой, в пятницу now третий. Дальше из этого now с помощью нашего волшебного нашего такого же билтина, как `math` предиката там и все прочее, есть такой, ну, то есть, `dayOfWeek`. И проверяется с константой `Friday`. То есть если сегодня пятница, если так его по-человечески, да? Потом берется у now, забирается `timeOfDay`. И кладется в переменную `time`. И потом этот `time`...
*   **[Мужской голос 3]:** `dayOfWeek` - это булевая такая, билтинговая? True/False возвращает?
*   **[Георгий]:** Какое? `GTE`?
*   **[Мужской голос 3]:** Первый, `dayOfWeek`.
*   **[Георгий]:** `dayOfWeek` он возвращает, на самом деле, число, но так как у нас парсер умный... то есть вот это можно было бы записать более длинно, как люди иногда пишут.
*   **[Мужской голос 4]:`?day`... потом бы надо было... можно было бы написать `?day == 'Friday'`. То есть как константа, наверное, там, не знаю, какая-нибудь есть. Ну, или там число пять, хрен с ним, я не знаю, как они назвали эти константы. То есть по сути, можно и так было записать.
*   **[Мужской голос 3]:** Вопросиками - это переменные, да?
*   **[Георгий]:** Вопросиками - это переменные.
*   **[Мужской голос 4]:** Петр, а тут вопрос больше в том, что у тебя часть этих троек возвращает данные, а часть просто выходит, да или нет, и ты что тут сравниваешь.
*   **[Георгий]:** Это не зависит от тройки, это я сейчас чуть позже расскажу. Ну да, что как, как, как вот здесь каждая конкретная штука работает, я сейчас чуть позже расскажу, потому что это важно.
*   **[Мужской голос 2]:** Мне сейчас мозг сломается.
*   **[Мужской голос 3]:** Ну ты держишься или уже все, уплыл?
*   **[Георгий]:** Вот это понятно то есть, да? Дальше, если ты в другой какой-нибудь тройке там спросишь: вот это сейчас выражение является правдой или нет? Ну то есть, домой пора или не пора? И в случае, если это сработает все условия, что типа день недели - пятница, что время больше, чем 18:00, значит пора. Если нет, значит это не выведется просто. Не не скажет здесь false, ничего, просто нет. Это неправда.
*   **[Мужской голос 3]:** То есть конъюнкция - это как фильтр получается.
*   **[Георгий]:** Да, конъюнкция - это как фильтр.
*   **[Мужской голос 2]:** Они все должны быть true, чтобы...
*   **[Георгий]:** Да, вы пишете всегда вот сюда конъюнкцию. Вот здесь всегда у вас конъюнкция находится.
*   **[Мужской голос 2]:** А какой вопрос? А это сейчас ведь напишется, все условия.
*   **[Георгий]:** Ну, через точку.
*   **[Мужской голос 2]:** Здесь точка, здесь точка, здесь точка, здесь точка.
*   **[Георгий]:** В одной строке. Как хочешь.
*   **[Мужской голос 2]:** То есть после точки нет пробела, сразу `now`.
*   **[Георгий]:** Лучше писать пробел, да. Потому что это же читают люди.
*   **[Мужской голос 2]:** А чтобы оно работало?
*   **[Георгий]:** Скорее всего, пофигу ей. Скорее всего, распарсится. Ну можешь попробовать, если что, тебе скажет синтаксическая ошибка. Если точку не поставишь, точно скажет, что синтаксическая ошибка.
*   **[Мужской голос 4]:** Между аргументами точно там пробелы нужны.
*   **[Георгий]:** Между аргументами - пробелы.
*   **[Мужской голос 4]:** Это точно. Да.
*   **[Георгий]:** Потому что если записать вот...
*   **[Мужской голос 4]:** Скобка закрылась, сразу двоеточие, стрелка, скобка открылась, то он тебе ругаться будет.
*   **[Георгий]:** Равно-равно тоже, если напишешь без обрамления пробелов, тоже ругаться будет.
*   **[Георгий]:** Да, теперь посмотрим на пример, который написал Сергей тогда с вычисляемым свойством.
*   **[Мужской голос 2]:** Он там он форматировал.
*   **[Георгий]:** Да.
*   **[Мужской голос 2]:** Именно со свойством вычисляемым.
*   **[Георгий]:** Да, это важно. Все, это я стираю, да, готовы? Да.
*   **[Георгий]:** Значит, Сергей написал такое вот выражение на этом волшебном языке экспрешнов, он написал формат, в первом аргументом сюда отдал...
*   **[Мужской голос 3]:** Синтаксис форматирования.
*   **[Георгий]:** Вторым аргументом отдал лист аргументов.
*   **[Мужской голос 2]:** Title ID?
*   **[Георгий]:** Да, Title ID. Вот. В тройке это преобразовалось в следующее. Так как он это задал для какого-то свойства, да, что это свойство вот это вычисляется там было, не знаю, как оно называлось, op:48 там или что-то. Ну, допустим, да, op:48. То дизъюнкция, та самая часть, которая вывелась, она на самом деле четко записалась, сама она знает, как ее писать, и никаких вопросов больше не возникает, она представляет собой вот такую вот фигню. `body`.
*   **[Георгий]:** Вот выводится строго вот это вот. А из чего выводится? Ну, и с форматированием. Можно как бы пойти с конца, пробить интереснее. То есть формат — это тот самый string.format.
*   **[Мужской голос 4]:** Ну, В3-орговский стринг.
*   **[Георгий]:** Нет, по-моему, это наш.
*   **[Мужской голос 4]:** Нет, это В3-орговский.
*   **[Георгий]:** Ну, хорошо. Это вот это вот слово. Теперь у него есть как бы что-то на входе, что-то на выходе. На выходе, понятно, value будет. То есть сохраняет он в это самое value. Что на входе? На входе у него как раз лист аргументов, очень похоже, как здесь. Ну, и, соответственно, этот лист аргументов будет выглядеть из вот этого нолика там, просто строки реально. И внутри будет второй лист аргументов, который вот снова вот тот. И в него, соответственно, запихался title, ID. Давайте для примера их назовем, как бы, сюда сейчас, ?title, ?id. Ну, это вот сюда фигня идет на первое место. Ну, и, соответственно, откуда-то он их взять должен в этом месте, да? Так как здесь доллар написано title, доллар ID. Наш умный парсер вот этих выражений, он поймет, что title — это, на самом деле, ну, это ж alias, да, вот этот system name, что system name title — это там, op:42. System name ID там, op:14, допустим, да? И он тогда напишет такие следующие строчки. `item op:42 ?title`, `item op:14 ?id`. Вот. То есть, когда он начнет вычислять, самый первый проход, там рассказываю, самый такой простой. То есть, он обратится в базу. Когда как бы... для чего он вычисляет? Для конкретного какого-то объекта, да, который там Сергей открыл, хрен знает какой, там 1861 был какой-то такой. Он сюда придет не с неизвестным айтемом, а придет с айтемом, который 1861. И он спросит базу, вот прямо здесь. `DB`, дай мне, пожалуйста, все, что подходит под этот паттерн, так сказать. `1761`, `op:42`, `?title`. `DB` ему в ответ...
*   **[Мужской голос 2]:** А если select написать, как выглядит?
*   **[Георгий]:** Ты уже все понял?
*   **[Мужской голос 2]:** Ну, я понял.
*   **[Георгий]:** Молодец. Ну, остальным дай понять.
*   **[Мужской голос 2]:** Нет.
*   **[Мужской голос 4]:** Просто select, пример селекта был бы проще.
*   **[Георгий]:** Ты отсидел. Какой селект, Валера? Не проще. Ты что, офигел? Селектор был бы проще?
*   **[Мужской голос 4]:** Селект - он обернуть вот это и запихать еще в список. С этим сначала разберись.
*   **[Георгий]:** То есть, в базу данных он спросит: "Дай мне, пожалуйста, все, что подходит под этот паттерн". На что база данных ему... он вернет, она всегда отдает одно и то же, когда ее вот так вот спрашивают, она отдает энумератор. Не знакомы с таким понятием?
*   **[Мужской голос 2]:** Нет.
*   **[Георгий]:** Перечислитель. Это такая фигня, в которой есть, по сути, два метода.
*   **[Мужской голос 4]:** Возвращает текущее значение.
*   **[Георгий]:** Два метода. Первый метод называется `MoveNext`, второй метод `GetCurrentValue`. То есть, это некоторые просто курсор такой, слышали? Перечислитель, курсор, да? Когда у вас есть какой-то список там где-то чего-то, и вы не список возвращаете, а некоторый волшебный такой объектик, который изначально смотрит вот сюда. И когда ты ему говоришь: "Дай current", он тебе все время вот это возвращает. Потом ты говоришь `MoveNext`, он смещается вниз на один. "Дай current", он вернет вот это. Дальше `MoveNext`, `MoveNext`, `MoveNext`, он бежит до конца. И когда вот здесь делаешь `MoveNext`, он скажет "больше нечего отдавать, все закончилось". Почему? Потому что в базе гипотетически у этого объекта по этому свойству может быть лежать множество значений. Ну, предположительно, там коллекция у вас как работает? В одном этом у тебя много значений в одном объекте. Соответственно, он тебе будет перечислитель на эти объекты возвращать. В данном случае мы четко знаем, что, на самом деле, значение там одно, да? Поэтому вернет перечислитель, в котором будет на самом деле вот одно значение. То есть, перечислитель сюда вернулся - enum, в котором вот эта штука лежит. И ему позовут current, да? То есть, дай мне current value. И тогда этот самый value засетится вот сюда, в title. То есть value будет, по-моему, low, как мы там приходили, low value. Дальше он опять скажет: "База, дай мне, пожалуйста, все, что подходит вот под эту фигню". То есть, `DB`, дай мне с этим `1861`, `op:14`, `?id`. База ему опять вернет перечислитель с одним только значением, потому что у нас ничего больше туда не подойдет, это сто процентов, потому что идентификатор один для объекта. И он сюда засетит в этот ID несчастный `18` как раз `61` и засетит, потому что это единственный ID, да? Дальше позовется уже вот это, вот это не база, это просто посчитать в памяти. Куда будет вот это отдано, тот самый title, который low у нас забиндился, и айдишник, который забиндился, ну, то есть то, что сюда в данный момент загрузилось, `1861`. И он этот, вот по этому формату отформатирует и запихает в value. И для объекта вернется вот такое value.
*   **[Мужской голос 2]:** Почему мы вообще пишем лист вот в этой вот формуле изначальной, да, Expression Sample? Почему мы пишем лист, вот и title, ID?
*   **[Георгий]:** А потому что у тебя тогда типизировано... то есть у нас есть синтаксис вызова. Мы знаем, что лист - это перечисление какого-то недетерминированного количества аргументов, да? То есть мы не знаем заранее, сколько туда аргументов напихают.
*   **[Мужской голос 2]:** Угу.
*   **[Георгий]:** Поэтому это лист. У функции `format` у неё четкое определение. Она даже подсказывает это в...
*   **[Мужской голос 2]:** Что…
*   **[Георгий]:** То, что у нее есть два аргумента всего. Первый аргумент - строчка, второй аргумент - набор чего-то там.
*   **[Мужской голос 2]:** И а... какой-то гипотетический пример, вот… если title у нас не один? Как можно мы можем какой-то такой сделать?
*   **[Георгий]:** Да-да-да, title не один, мы представляем, что вдруг так получилось, что title не один. Такое бывает.
*   **[Мужской голос 2]:** Вот, вопрос на засыпку, что же в этом случае произойдет, если я вам сейчас рассказал, что вот как вот он взял `current`, спустился ниже, взял `current`, спустился ниже. Это не, это не перечисляемая фигня, он просто сюда засетил и вернул вот это. Подсказка, вот эта вот штука, она тоже на самом деле возвращает перечислитель дальше наверх, то есть она возвращает тоже такой же enum, как и база, так и она возвращает, потому что потенциально этих значений может быть много. То есть что вот когда он первый раз здесь, ему скажут `getCurrent`, когда ему позовут `getCurrent`, он вот это все взял, один раз прокрутил и вернул, ну вот эту вот строчку там, что там `low 1861`. Вот он тебе вернул. Но на самом деле ему позвали `MoveNext`. Что он дальше будет делать? Как вы думаете?
*   **[Мужской голос 2]:** Я не знаю, как он должен. Приплюснуть еще что-то?
*   **[Георгий]:** Да, но на самом деле он пойдет снизу вверх обратно. То есть, вот это крутить нечего, вот это крутить бесполезно, да, это константное выражение, все время возвращает. Ну то есть, 2+2=4 всегда. Ну или string.format от одного и того же... Он поднимется на одну строчку выше. Позовет вот у этой штуки `MoveNext`, ему вернут `null`, нет такого айдишника, был один. Он говорит: "Окей, без проблем". Поднимаемся еще выше, позовет вот у этой штуки `MoveNext`. Она найдет ему второй title, `high`, пускай. Пускай их было два, почему-то, да? Она найдет ему `high`. И он начнет обратно в этом же порядке спускаться. Опять у базы попросит вот это, опять, ну и опять вот здесь посчитает. И второе значение зафигачит вот это вот `high 1861`. Так бывает. Да.
*   **[Мужской голос 2]:** Это будет два этих… отдельных, да? То есть он не к нему приплюснёт, не к `low`?
*   **[Георгий]:** Нет, нет, нет, это два отдельных значения.
*   **[Мужской голос 3]:** Он возвращает тот же энумератор, а это значит, что у тебя в энумераторе они будут вот там и там.
*   **[Георгий]:** Да.
*   **[Мужской голос 3]:** Вот это важный момент, хороший вопрос. Вот так оно работает. Вы такое можете получить. То есть когда вы…
*   **[Мужской голос 2]:** Нет, я такое получу, но оно не выведет мне...
*   **[Георгий]:** Ну, выведет. Два значения до формы долетают, по-моему.
*   **[Мужской голос 4]:** Долетают, да, там просто обрежется, на этом все. Если на списке он еще покажется, то на форме он обрежет, значение...
*   **[Георгий]:** Ну, такое бывает. Да, когда модель данных вы там думали, что там одно значение, а оно `multiple`. Ну, как правило, в `join` какой-нибудь, когда ты делаешь, соответственно, он тебе вот...
*   **[Мужской голос 4]:** `ID` в данном случае, когда у тебя `title` поменялся наверх, да, у тебя он заново пересчитал там что-то другое.
*   **[Георгий]:** Да.
*   **[Мужской голос 4]:** А у тебя `ID` прибавит или все-таки энумератор новый будет?
*   **[Георгий]:** Энумератор будет новый. Потому что, представим, что еще раз усложним, что у него на самом деле не только два тайтла, но и два айдишника гипотетически. То есть это не айдишник, пускай, а там какой-нибудь `uber_id` какой-то, который бывает за два. Тогда он на самом деле вернет четыре значения, в каком порядке? Исходя из того, как здесь записано. То есть сначала будет `low 1861`, потом он вниз прокрутил, поднимается наверх, докручивает еще раз с айдишником дальше. Пускай `1862`. То есть он выведет еще раз `low 1862`. Потом поднял, вернул, вернулся наверх до тайтла, потому что айдишники уже все прокрутил. Будет `high 1861`, и опять `low...` ой, и еще раз `high 1862`. То есть как бы перемножение.
*   **[Мужской голос 3]:** Четыре значения.
*   **[Георгий]:** Поэтому вот такие вот штуки просто так писать не стоит.
*   **[Мужской голос 2]:** Вот этот `enum` он включается, когда вот мы написали там...
*   **[Георгий]:** Всегда! From...
*   **[Мужской голос 2]:** А, или всегда?
*   **[Георгий]:** Всегда. Каждая вот эта строчка возвращает enum.
*   **[Мужской голос 3]:** Просто у тебя может быть...
*   **[Георгий]:** За исключением одного специального случая.
*   **[Мужской голос 3]:** ...который Жора говорил - "объяснит".
*   **[Георгий]:** То есть, один специальный случай - ну вот такие специальные случаи бывают, да, когда у вас просто что-то вычислить, выражение, которое не зависит от базы и всего остального. Вот оно всегда одно и то же значение возвращает, не `enum` возвращает. Но бывает, что вы, например, вычисляете... уже вам все известно, и вам надо проверить, да? Как такое бывает? Ну, например, не знаю. Ну, в этом примере как это сделать там...
*   **[Мужской голос 4]:** `id == null`...
*   **[Георгий]:** Нет, ну вот в этом примере, он дурацкий как бы. Что, `item User`...
*   **[Мужской голос 2]:** `current user` достается из того самого окружения, о котором я говорил. `now` в окружении валяется, и `current user` в окружении валяется. У нас есть специальный сабжект такой, что-то `current context` он называется. Прямо вот через двоеточие, захардкоженный сабжект, текущий контекст. У него есть набор заранее известных свойств. Одно из них...
*   **[Мужской голос 2]:** `current user`...
*   **[Георгий]:** Да, есть `user`, а есть дата-время, и есть еще что-то там, локаль какая-то, ну и куча всякой фигни. И есть у него, соответственно, предикат, который `currentUser`. Мы вычислили `user`.
*   **[Мужской голос 2]:** По сути, такой тоже есть?
*   **[Георгий]:** Да, конечно.
*   **[Мужской голос 2]:** В базе должен быть.
*   **[Георгий]:** Как он еще будет работать? Только так и работает.
*   **[Мужской голос 4]:** Ну, мы через `session` вытаскиваем. У нас пакет `session`, и мы через него...
*   **[Георгий]:** Ну, `session` - это и есть этот контекст.
*   **[Мужской голос 4]:** А, ну то есть...
*   **[Георгий]:** Да, вот у тебя есть вот этот `current session` или `current context`. Дальше ты у него берешь свойство `user` и фигачишь его в `user`. То есть он сюда закрутился. Это будет энумератор, кстати, тоже обязательно. То есть, конечно, никогда двух юзеров в сессии не бывает, но в целом там все равно внутри это самое... Дальше у тебя уже пришел сюда `item`, поэтому и ты знаешь, представим, что ты знаешь, как называется этот предикат: `op:43`, `op:44` вот этот. То есть, можно как написать? Можно написать чуть как бы более понятно, но менее изящно, да? То есть, `item op:44 ?item_user`, то есть, ну из разницы, да? И потом написать `?user == ?item_user`. Вот это, это вернет энумератор, вот это будет энумератор, а вот это энумератором тоже, ну, не будет никак, да? Потому что у тебя написано `А == B`, ты и `A` и `B` на данный момент знаешь, тебе просто надо сравнить. Оно не может быть много значений вернуть. Оно может быть либо, ну, либо истина, либо ложно. Если ложно, оно дальше не пойдет никуда. Если истина, то у тебя все...
*   **[Мужской голос 2]:** Если хоть одно ложно, или как?
*   **[Георгий]:** Если хоть одно из этих выражений ложно, дальше ничего не идет. Все. Да.
*   **[Мужской голос 4]:** То есть, если ты `item_user` не определен, то он тогда сработает как просто приравнивание.
*   **[Георгий]:** Ну, через `==` оно как бы не сработает как приравнивание, я не рассказываю, потому что если `item_user` не определен, то здесь вот это выражение ложное. Дальше не пойдет.
*   **[Мужской голос 4]:** Ты `item_user` вообще не получаешь, а просто...
*   **[Георгий]:** Вот я получаю `item op:44`, `?item_user`.
*   **[Мужской голос 4]:** Нет, я говорю, если не получаешь, если верхней нету, то он тебя не сработает как приравнивание?
*   **[Георгий]:** Если у тебя нет верхней, а нижней, вот это? Ну, а что толку-то? Ну, это `item_user` будет. Ну, нам же не интересно, да? То есть... И второй момент, если у тебя `user` или `item_user` у тебя несколько значений содержит. Такое, ну, `user` - один, а `item_user` у тебя, например, там несколько значений содержит, то он для каждого `item_user`'а сначала тебе проверку наверху делает, да? И для каждого `user`'а, ну, потом вверх намертво...
*   **[Георгий]:** Мы уже проходили это в прошлом раз. В предыдущем нашем, а...
*   **[Мужской голос 4]:** Ну, мы не проходили в смысле, что он именно `true`/`false`... `true`/`false` возвращает... то есть, он итерирует еще по сабжекту.
*   **[Георгий]:** Нет, он вернет энумератор какой-то, да, если он там хоть что-то, есть, то он вернет энумератор, ты его крутанешь один раз. Вот же он, для того, чтобы тебе текущее значение забиндить, так это работает. База, если ты экзэкт-матч, она возвращает `true` или `false`. Движок, возвращаемым значением пользуется. Да, если вернули `true`, он едет дальше вниз куда-то. Если `false`, он едет наверх, вариантов нету. Если у базы спросили паттерн-матч, да, то есть какие бывают паттерн-матчи сразу, вот там напишу, бывает вот такой. Ну, понятно, что бывает... вот такой, вот такой. Ну, и понятно, что вот так, то есть неизвестно ни то, ни другое, дай мне все, что с этим свойством вообще есть, слева-справа. Известен этот, этот, этот неизвестен, известен этот, этот неизвестен. Вот, он будет такие энумераторы возвращать. Соответственно, если я спросил что-то такое, она вернет энумератор. Движок спросит: "Дай мне первый элемент энумератора". Тут она ему скажет: "Нет первого элемента". Он говорит: "Окей, тогда едем наверх".
