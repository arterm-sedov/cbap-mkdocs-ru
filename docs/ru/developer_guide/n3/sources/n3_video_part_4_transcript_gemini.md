### Резюме и объяснения

Это видео представляет собой техническое учебное занятие по использованию языка запросов **N-Triples** в рамках платформы Comindware. Занятие предназначено для пользователей, знакомых с основами платформы, и направлено на углубленное изучение возможностей кастомизации с помощью запросов.

#### Основные темы и концепции:

1.  **Введение в запросы N-Triples**:
    *   **Модель данных**: Язык основан на RDF-модели (Resource Description Framework) и оперирует тройками вида "субъект - предикат - объект". В контексте Comindware это обычно означает "ID записи - ID атрибута - значение атрибута".
    *   **Переменные**: В запросах используются переменные, начинающиеся с `?` (например, `?item`, `?value`, `?Region`).
    *   **Зарезервированные переменные**:
        *   `?item`: Обычно представляет ID текущего объекта (записи), в контексте которого выполняется запрос.
        *   `?value`: Используется для возврата результата запроса.

2.  **Полезные конструкции и встроенные функции (built-in)**:
    *   **`("tempAlias" "attrAlias") object:findProperty ?p`**: Находит ID атрибута `attrAlias` в шаблоне записи `tempAlias` и присваивает его переменной `?p`. Это предварительный шаг для использования атрибута в качестве предиката.
    *   **`once { ... }`**: Оператор, который выполняет вложенный блок кода и прекращает итерацию после нахождения первого же совпадения. Идеально подходит для проверки существования чего-либо, так как повышает производительность, не перебирая все возможные варианты.
    *   **`or { ... }`**: Логический оператор "ИЛИ". Позволяет объединить несколько условий, где достаточно выполнения хотя бы одного из них.
    *   **`if {condition} then {action1} else {action2}`**: Условный оператор. Если условие `condition` выполняется (т.е. возвращает хотя бы один результат), выполняется блок `then`. В противном случае — блок `else`.
    *   **`from { ... } select ?var -> ?list`**: Собирает все значения переменной `?var` из всех итераций блока `from` в единый список (массив) `?list`.
    *   **`?list math:sum ?sum`**: Вычисляет сумму всех числовых элементов в списке `?list`.
    *   **`{ ... } assert:count ?c`**: Считает количество результатов (итераций), которые вернул вложенный блок кода, и помещает результат в переменную `?c`.
    *   **`{ ... } assert:distinct ?var`**: Отфильтровывает итератор, оставляя только уникальные значения для переменной `?var`.
    *   **`{ ... } assert:union true`**: Объединяет результаты нескольких независимых итераторов (формул) в один общий итератор.

3.  **Примеры использования**:
    *   **`once`**: Проверка наличия хотя бы одного магазина (`Biznesstruktura`) в регионе (`Region`), указанном в текущей записи.
    *   **`or`**: Получение задач, где текущий пользователь является либо возможным исполнителем (`possibleAssignee`), либо назначенным исполнителем (`assignee`).
    *   **`if`**: Фильтрация задач, чтобы показать только непросроченные. Если у задачи нет срока выполнения (`dueDate`), она также считается непросроченной.
    *   **`from` и `sum`**: Расчет общей суммы по всем позициям в накладной. Сначала `from` собирает суммы всех позиций в список, а затем `sum` их складывает.
    *   **`count`**: Подсчет общего количества позиций в накладной.
    *   **`distinct` и `count`**: Подсчет количества *уникальных* товаров (номенклатур) в позициях накладной.
    *   **`union`**: Создание единого списка всех контрагентов (грузоотправителей и грузополучателей) из накладной.

4.  **Использование N-Triples в платформе**:
    *   Обсуждалась таблица, разъясняющая, как меняется смысл зарезервированных переменных `?item` и `?value` в зависимости от места применения скрипта в платформе:
        *   **Вычисляемый атрибут**: Вход — ID текущей записи (`?item`), выход — значение атрибута (`?value`).
        *   **Фильтр на списке**: Вход отсутствует (можно начать с любого объекта), выход — список ID записей для отображения (`?item`).
        *   **Условие операции**: Вход — ID текущей записи (`?item`), выход — `true/false` для определения видимости операции (`?value`).
        *   **Выражение для роли**: Вход — ID текущего пользователя (`?value`), выход — список ID записей, на которые у пользователя есть права (`?item`).

5.  **Обсуждение и вопросы**:
    *   **Вычисляемые атрибуты**: Было разъяснено, что вычисляемые атрибуты не хранятся в базе данных. Их значение рассчитывается "на лету" в момент обращения (например, при отображении формы). Это означает, что на их "изменение" нельзя подписаться с помощью триггеров, так как события изменения как такового нет. Для пересчета необходимо изменение исходных данных, от которых зависит вычисление.
    *   **Глобальные функции и внешние сервисы**: Подтверждена возможность вызова глобальных функций (включая C#-функции, которые могут обращаться к внешним веб-сервисам) из N-Triples. Это позволяет значительно расширить логику.
    *   **Экспорт и C#**: Обсуждались два механизма экспорта: простой (low-code с подстановкой полей в фигурных скобках) и сложный (через C#-скрипт). В C#-скрипте можно создать объект (класс) с нужной структурой, наполнить его данными из текущей записи и дополнительными вычисляемыми данными, а затем передать этот объект в шаблон экспорта.
    *   **Поиск системной информации**: Для написания сложных запросов разработчикам может понадобиться информация о системных объектах и атрибутах. Было упомянуто, что эту информацию можно найти, изучая системные `.ntri` файлы платформы.

В целом, сессия предоставила глубокий обзор синтаксиса и практического применения N-Triples для решения сложных задач по извлечению и обработке данных в Comindware, выходящих за рамки стандартных low-code инструментов.

### Полная транскрипция видео и речи

**[00:00:00]**

*(На экране отображается интерфейс видеоконференции с пятью участниками. Четыре участника с выключенными камерами и микрофонами (имена: Alexander, Georgy Polyan, Artem25Sedov), и один участник с включенной камерой — женщина. Имя пятого участника не полностью видно, но начинается на "Anatoly".)*

**[00:00:03]**

*(Экран меняется. Демонстрируется презентация PowerPoint. Заголовок слайда — "Запросы N-Triples". Слайд содержит список.)*

**Ведущий:** Всё, запись пошла. Можем тогда продолжать.

*(Пауза)*

**[00:00:15]**

*(Ведущий переключает на следующий слайд. Заголовок слайда: "Запросы N-Triples". Подзаголовок: "Примеры (once)". На слайде приведен пример кода.)*

**Ведущий:** Да. Ну вот есть примеров несколько, примеров я тут привёл на разные операторы, да, чтобы можно было как-то их там посмотреть.

**[00:00:29]**

*(Ведущий указывает курсором на разные части кода на слайде.)*

**Ведущий:** Вот. Тут, собственно, что... что имеется в виду, да?

*(Пауза)*

**Ведущий:** Вот, нам нужно посмотреть, что... Да, у нас есть там текущий шаблон, да...
**Участник 1:** В котором есть регион.
**Ведущий:** В котором есть атрибут "регион", да. И есть какая... какое-то подразделение там, ну, грубо говоря, там, не знаю, можно назвать там магазином, да, который в этом регионе существует. Вот. И нам нужно просто проверить, что, например, э-э, как бы вот, в это, в задан... в заданный регион, да, при... при задании региона на текущей форме, да, я как бы это, у меня есть хоть один магазин в этом регионе выбранном. Вот. И фактически true или false должно вернуться. И вот я как раз-таки здесь, да, использую `once`. Нам мне не нужно доставать все регио... все магазины этого региона. То есть, как только я первый регион... первый магазин нашёл, то есть, как только в `?check` упало там, итератор получился хоть один, да, у нас, у меня, соответственно, мы выходим.
**Участник 1:** `?check` - это тоже, я так понимаю, это зарезервированное слово?
**Ведущий:** Нет-нет-нет, это тоже переменная, я её просто `check` назвал. Зарезерви... зарезервированное — это вот, как я и говорил, то есть это `?item`, да, текущий объект, и `?value` — это выходной параметр.
**Участник 1:** Так, секундочку.
**Ведущий:** Это вот зарезервированные слова.
**Участник 1:** Секундочку, секундочку. Вот сейчас... Первая... сверху понятно. Ну, бизнес-структура — это другой шаблон записи, правильно?
**Ведущий:** Угу, угу.
**Участник 1:** Соответственно, мы говорим, что у нас... так, так, так, так.
**Ведущий:** Мы получаем текущий регион, и дальше мы вытаскиваем по региону все, ну, в переменную `?check` просто все магазины.
**Участник 1:** `?item` — это служебная, правильно?
**Ведущий:** Да, да, да, да.
**Участник 1:** Мы говорим, что э-э, мы, э, получаем `?RegionVal`.
**Ведущий:** Угу.
**Участник 1:** Так, `?item` — это что у нас, если как, ну...
**Ведущий:** `?value` знаю. `?item` — это текущий объект.
**Участник 1:** А, текущий объект. То есть мы получаем просто ID объекта...
**Ведущий:** Да-да-да.
**Участник 1:** Правильно говорю?
**Ведущий:** Да-да-да. Ну, `?item` — это ID текущего объекта.
**Участник 1:** Да. Вот. А, соответственно, мы запоминаем значение в `?RegionVal`. И дальше мы смотрим, `?Region2` э-э, совпадает ли...
**Ведущий:** Ну да, тут может быть несколько регионов, ну, в общем случае, да. То есть у нас регионов множественное может быть, то есть итератор может быть не только одной записи. Вот. Он перейдёт, проверит первую. Если в это, в первом регионе хоть один магазин есть, соответственно, он тогда, ну, то есть он его это, итератор переключит на первый магазин и пойдёт дальше за `once`. И если он, соответственно, вышел с этим итератором, всё, он запоминает `?RegionVal` и `?check`, как бы, и снаружи будет только одно значение использовать, а дальше как бы итератор уже не перейдёт, не переключится. Вот. Если `?RegionVal` у нас как бы... если у нас в регионе не нашлось магазина, он перейдёт к следующему. Если ни к одному не перейдёт, то он выйдет просто с пустым...
**Участник 1:** Я понимаю. Вот у меня слово `?check`...
**Ведущий:** Забейте на `?check`. Я его назвал `?check` просто, как бы, и всё.
**Участник 1:** Я понимаю, я просто говорю, что у нас... неважно, как он называется...
**Ведущий:** Да, это просто переменная названа так.
**Участник 1:** ...важно то, что на выходе мы получаем значение, либо пусто... либо мы получаем, соответственно, э-э, этот самый регион. Или `true`, или `false`. Что мы получаем?
**Ведущий:** *(переименовывает переменную `?check` на `?shop` в презентации)* Можем назвать его `shop`.
**Участник 1:** Нет, ну...
**Ведущий:** `true` или `false` мы получаем на выходе что?
**Участник 1:** На выходе у нас будет вот если мы говорим про выход из функции нашей, ну, в смысле нашего скрипта, то у нас только `true`. Или `null`. То есть, если у нас ничего вот здесь вот не нашлось, да, ни одного магазина, то он вернёт `null`. Ну, это равносильно...
**Участник 1:** Это понятно, да, да, да, это пустое значение, да.
**Ведущий:** Да, это пустое значение. Если хоть один нашёл, он просто `true` вернёт, одно значение. Потому что как бы итератор один раз только сработает. То есть он не будет несколько раз проитерироваться и каждый раз `true` записывать в `?value`.
**Участник 1:** А, присваиваем значение.
**Ведущий:** Да.
**Участник 1:** Это вот... вот этот оператор присваивания значения, это вот стрелочка.
**Ведущий:** Если `once`... `true` присваиваю значение... `true` я кладу в `?value`.
**Участник 1:** `true` вы кладёте в `?value`, правильно. Но, а если у меня `null`?
**Ведущий:** А `null` у вас будет только в том случае, если не дойдёт вообще до `true` в `?value` положить. То есть у вас если вот здесь вот ничего не нашлось, он вообще отрубается, он прерывает выполнение.
**Участник 1:** Всё, я понял. То есть...
**Ведущий:** То есть итератор он работает именно так, что если у нас итерации как бы идёт на каждой строчке хоть одно там мэтчит или находит э-э этот...
**Участник 1:** Я понял, я не обратил внимание, что у нас... я фигурную скобку вверху первую и закрывающую... Всё понятно теперь. Да.
**Ведущий:** Да, вот.
**Участник 1:** Вот теперь всё понятно. То есть мы просто либо... либо возвращаем... э-э... да.
**Ведущий:** Либо `true`, либо да, либо `null` у нас будет.
**Участник 1:** Всё, поехали дальше. Всё понятно.

**[00:05:28]**

*(Ведущий переключает на следующий слайд. Заголовок: "Запросы N-Triples". Подзаголовок: "Примеры (or)". Слайд содержит пример кода.)*

**Ведущий:** Вот. Ну, опять же, `or` наш, да, `assignee` - `possibleAssignee`. То есть он вернёт либо оттуда, либо оттуда. То есть не два вместе, а либо-либо. Ну, кстати, вот именно для задачи, для `possibleAssignee` и `assignee` - это достаточно, потому что они вместе не могут существовать. У нас либо есть назначенный, как бы тогда `possible` уже пустые становятся, либо у нас только `possible` без назначенного.
**Участник 1:** Понятно.
**Ведущий:** Вот, это...
**Участник 1:** То есть тот пример, который был раньше, он он совсем...
**Ведущий:** Ну, он да, он он... он просто да, как бы вернёт то же самое, что и `or`, по сути.
**Участник 1:** Пойдёмте дальше.
**Ведущий:** Угу.

**[00:06:08]**

*(Ведущий переключает на следующий слайд. Заголовок: "Запросы N-Triples". Подзаголовок: "Примеры (if)". Слайд содержит пример кода.)*

**Ведущий:** Так, дальше. `if`. Так, `if`... Так. Здесь вот с отступами беда, конечно, он что-то слетает.
**Участник 1:** Не страшно, не страшно, мы видим.
**Ведущий:** Вот. В общем, если у нас заполнено `dueDate`, то как бы сравни, что `dueDate`... ну, получи все задачи, у которых `dueDate` больше, чем сейчас. То есть это как бы это...
**Участник 1:** Ну, понятно.
**Ведущий:** ...не... непросроченные.
**Участник 1:** Да, понятно. И, соответственно, если там э-э, `due`... соответственно, э-э... `dueDate` отсутствует, да?
**Ведущий:** Да, если `dueDate` отсутствует, то мы просто возвращаем как бы задачу, что она тоже не просрочена. Ну, то есть это не... это непросроченные задачи. Вот.
**Участник 1:** А зачем так сложно?
**Ведущий:** Не, ну это я для примера вам сконструировал. Можно было... можно было упростить, конечно же. Можно было сделать просто задачу меньше, да, и `not` сделать, и всё, и как бы одной строчкой. Тут не надо ифов, ничего. Я вам как бы... для примера показываю просто это...
**Участник 1:** Я понял, что...
**Ведущий:** Может быть, неудачное использование, но конструкцию именно, как она будет работать.
**Участник 1:** Я понял, то есть, если мы `else` выбрасываем...
**Ведущий:** Если мы `else` выбрасываем, то вообще тогда эта задача, да, она не попадёт. То есть фактически у вас на этих задачах итератор будет прерываться. Даже если дальше что-то у вас будет, да, какая-то обработка, то нужно понимать, что оно никуда не пойдёт. Вот.
**Участник 1:** То есть другими словами, ничего не вернёт.
**Ведущий:** У кого `dueDate` не задан, да, он тогда как бы вообще никуда не включит, ни в какие условия.
**Участник 1:** Всё, пошли дальше.

**[00:07:55]**

*(Ведущий переключает на следующий слайд. Заголовок: "Запросы N-Triples". Подзаголовок: "Примеры (from, sum)". Слайд содержит пример кода.)*

**Ведущий:** Так, `from`. Да. Тут `from`, `sum` как раз.
**Участник 1:** Ну...
**Ведущий:** То есть у нас есть там... какая-нибудь накладная, на которой мы сейчас находимся, да, мы получаем... есть позиции накладной там, какие-нибудь строки, типа коллекции.

**[00:08:16]**

*(Ведущий указывает на ошибки в коде на слайде и исправляет их.)*

**Ведущий:** Мы... так, тут... не обращайте внимания.
**Участник 1:** Ну, бывает. Заодно мы вам помогаем.
**Ведущий:** На лету... на лету всё правим. А... ну, то есть мы сначала получаем позиции, из позиций получаем атрибут "сумма". И, соответственно, и сумма `Val` у нас собирается в список.
**Участник 1:** Угу.
**Ведущий:** Вот. На выходе нужно понимать, итератор принимает только одно значение. Значение это — это массив. Этот массив в качестве этого, как его зовут, э-э, аргумента, да, или субъекта мы подаём на функцию `mass`. То есть входящая будет это массив, и он на выходе выдаёт сумму этого массива. На самом деле, как бы, вот, ну, по-хорошему, да... `mass` — это вот там 2, 3, 5...
**Участник 1:** Не-не, это понятно, понятно.
**Ведущий:** Вы массив как бы задаёте, и вот, вот... вот так вот именно `mass` работает, да. Ну, вот в круглых скобках — это массив считается, то есть лист.
**Участник 1:** Понятно.

**[00:09:17]**

*(Ведущий указывает на переменную `?SummaList` в коде.)*

**Ведущий:** Соответственно, оно именно так и работает.
**Участник 1:** Угу. Давайте дальше.
**Ведущий:** Угу.

**[00:09:23]**

*(Ведущий переключает на следующий слайд. Заголовок: "Запросы N-Triples". Подзаголовок: "Примеры (count)". Слайд содержит пример кода.)*

**Ведущий:** Так. `count`.
**Участник 1:** `count` - ну, понятно.
**Ведущий:** `count`, соответственно, работает не с массивом, а работает просто с формулой. То есть у вас в скобках есть какая-то формула на входе, да, и он посчитает, сколько значений оно вернёт на выходе.
**Участник 1:** Э-э... но он не... ну, сколько позиций.
**Ведущий:** Он работает с итератором, правда?
**Ведущий:** А, да, он именно итератор считает. То есть у него на выходе формируется итератор, который вот там `?PositionsVal` будет, и он посчитает количество, которое вернёт этот итератор.
**Участник 1:** Конечно, красиво было бы вот у вас первая, и потом, ну, имеется в виду, первая строчка — накладная позиции накладной, да? И дальше просто сказать, что э-э, так, `?Positions` сразу `count` и всё.
**Ведущий:** Ну, первая, тут нужно понимать, да, вот эта вот строчка, она не возвращает никаких данных. Имеется в виду, это вот `?Positions` будет хранить одно лишь значение - ID атрибута. То есть, чтобы его потом использовать в качестве предиката для получения данных.
**Участник 1:** А, понял, да.
**Ведущий:** То есть у вас `?item` — это ID объекта, а это ID атрибута. Поэтому вы, когда здесь указываете, у вас именно конструкция, что данные как бы в базе, они хранятся, то есть когда вы там на форме что-то заполняете, да, у вас ID объекта, ID атрибута, значение. ID объекта, ID атрибута, значение. И вот таких вот троек, да, по форме там 30 штук у вас сохраняется сразу. Ну, сколько атрибутов на форме, столько как бы и таких троек сохранится в базе. Вот. И как бы именно вот этот вот запрос, да, он как... как бы спрашивает, он понимает, что `?item` у вас задан, ID объекта — это как входящий. `?Positions` у вас, вы его здесь нашли. Вот. И, соответственно, у вас отрабатывает поиск э-э значений по заданному субъекту и объекту.
**Участник 2:** Можно ещё раз? А, вот... вот когда у нас это отрабатывает... Вот э-э, раз первая строчка... У нас есть э-э, накладная, э-э, позиции накладной — это её свойство?
**Ведущий:** Атрибут, да.
**Участник 2:** Атрибут. Мы э-э говорим, что ищем у этого атрибута э-э позиции? Или что?
**Ведущий:** Нет, это ищет не атрибут, ой, не значение. Ну, нашу базу помните? Слушай, ну давай я подумаю...
**Участник 1:** Помним.

**[00:11:52]**

*(Ведущий переключает окно на веб-интерфейс Comindware, где сначала видна ошибка "Can't read from server", затем после входа администратора открывается страница "Задачи".)*

**Ведущий:** Так. Сейчас я открою хоть что-нибудь.

**[00:12:00]**

*(Ведущий в левом меню переходит в "Шаблоны -> Т Панель коллекции", затем на вкладку "Атрибуты".)*

**Ведущий:** Так. Вот видите, у нас есть ID.
**Участник 2:** Угу.
**Ведущий:** Вот. Вот именно вот это ID вернётся вот в эту вот... вот-вот-вот, вот в эту переменную.
**Участник 2:** ID э-э того атрибута, который я... то есть там накладная — это системное имя...
**Ведущий:** Это не системное имя.
**Участник 2:** Системное имя шаблона и системное имя атрибута.
**Ведущий:** Да. Вот вы задали коллекция, тут есть, да, вы её коллекция здесь задаёте, и системное имя шаблона, который как бы вот, в котором оно находится.
**Участник 2:** Вот, и она в переменную `?Positions` э-э поместила этот ID.
**Ведущий:** Да.
**Участник 2:** Теперь `?item` — это уже ID объекта?
**Ведущий:** Да.
**Участник 2:** Э-э, какого объекта?
**Ведущий:** На котором вы находитесь в данный момент, в контексте которого вы будете работать. Ну, вот вы переходите к экземплярам, да, вот вы открываете, вот у вас объект 268. Вот этот 268 будет в `?item`.
**Участник 2:** Он типа накладная, да?
**Ведущий:** Он типа накладная, да.
**Участник 2:** А, то есть э-э, по крайней мере, это у нас совпадает, потому что меня это смутило, потому что у нас не `?item`, до этого никак не известно, что он относится к накладной.
**Ведущий:** Ну, это, ну, я просто, да, это где-то помечал `currentTemplate`. Но вообще как бы `?item`, да, это вот объект, с которым вы сейчас работаете, как правило. Ну, в зависимости от точки входа, конечно же. То есть на форме, на правилах на форме, на вычисляемом атрибуте — это так. На списках — там по-другому. На списках там, наоборот, формируется набор айтемов, которые как бы у вас в список попадут. И там точка входа как бы, она любая может быть, вы откуда угодно можете войти. Вот. Это тоже важная вещь.
**Участник 2:** Да, ну для этого потом надо будет ещё отдельно по... поговорить...
**Ведущий:** На ролях перевёрнуто у нас. На ролях перевёрнуто. Там сейчас `?value` наоборот предустановлен, то есть он на вход подаётся как текущий э-э пользователь. Вот, а `?item` нужно вывести э-э, ID объектов, которые имеют право работать с этим э-э... э-э, выданы, короче, права для этого пользователя по контексту.
**Участник 1:** Так, понятно.
**Ведущий:** В общем, там тоже перевёрнуто.
**Участник 1:** То есть, короче, это есть куча исключений, которые...
**Ведущий:** Да. Ну, зависит от точки входа. Но `?item` и `?value` — это в итоге, в это, два зарезервированных слова, которые как бы используются практически везде.
**Участник 2:** Но имеют разное значение.
**Ведущий:** Ну...
**Участник 2:** В смысле, в смысле...
**Ведущий:** Они, да, да, да. Смысл разный, конечно же. Где-то `?value` должен принимать `true`, `false`, где-то как бы он должен принимать ID объекта, э-э, и где-то просто там какой-нибудь литерал, да, например, для вычисляемого атрибута текстового, там литерала достаточно какого-нибудь.

**[00:14:50]**

*(Возвращается к презентации.)*

**Участник 1:** Понятно, пойдёмте дальше.

**[00:14:59]**

*(Ведущий переключает на следующий слайд. Заголовок: "Запросы N-Triples". Подзаголовок: "Примеры (distinct)".)*

**Ведущий:** `distinct`, тот, о котором я говорил, `union all`, да, `union` и так далее. Ну, вот здесь вот, например, нам нужно вычислить количество позиций, да, у которых э-э, ну, там, например... э-э... ну, продукт, да, одинаковый. Ну, в смысле, не одинаковый, точнее, а не отличается. Количество уникальных продуктов в позициях. Ну, у нас вот, например, есть пример, да, там, нефтяная компания, у неё есть э-э корзина, которая как бы наполняется именно продуктами и могут быть один и тот же продукт может быть добавлен в разные позиции заказа, чтобы они могли в каждую позицию в разные регионы направить. Ну, там, бензин какой-нибудь девяносто третий, да, в это, в пять своих точек заправок отгрузку сделать, и это разные строки.
**Участник 1:** И это всё разное?
**Ведущий:** А, разные строчки? Да, в разных строчках. То есть, ну, позиции — это строчки, да, соответственно, есть ещё там `items`, номенклатура уже конкретная в каждой строчке.
**Участник 1:** То есть, другими словами, эта штука э-э смотрит...
**Ведущий:** Она вытаскивает...
**Участник 1:** ...конкретный атрибут...
**Ведущий:** ...значение атрибута.
**Участник 1:** ...в накладной. Смотрите, она...
**Ведущий:** Значение атрибута. Она вытаскивает сначала все э-э позиции, ну, точнее, она по одной итерирует, да, одну позицию вытащила, перешла, нашла `item` в ней, ну, то есть, номенклатуру. Дальше переключилась на вторую позицию, нашла `item` во второй позиции. Отработала вот эта формула полностью, на выходе сформировался итератор в `?ItemsVal`, который хранит уже э-э, набор э-э номенклатур. Номенклатуры как бы не это, не уникальные пока. `assert:distinct` добавляется, да, к формуле, соответственно, который вам выдаст э-э... который...
**Участник 1:** ...уникальные.
**Ведущий:** Да, уникальные сделает. И на выходе уже `?ItemsVal` будет содержать э-э набор, ну, то есть итератор будет содержать только уникальные значения. И дальше мы на него прикладываем вот формулу `assert:count`, который посчитает только уникальные. И вот таким образом считаем уникальные значения.
**Участник 1:** Ну это такой пример вместе с `count`-ом.
**Ведущий:** Так.
**Участник 1:** Давайте переведу. Это у вас нефтяная компания, я переведу на попроще. Без бензина. А-а... мы делаем заказ на следующий год, примерной нашей потребности, во всяких мелочах. Ну, например, нам нужно столько-то ручек, столько-то блокнотов, столько-то картриджей для таких-то принтеров, ну и так далее.
**Ведущий:** Из разных подразделений, например.
**Участник 1:** Нет, ну, говорю, да, каждое подразделение делает. Значит, соответственно, мы потом можем э-э, ну, здесь пример, понятно, слегка выколотый опять же. Но мы потом можем, допустим, сгруппировать и сказать, что вот у нас э-э карандашей простых там э-э просто H, э-э... там... При этом мы первое берём, да, `?PositionsVal`. Э-э, вот у нас там столько-то, столько-то подразделений заказало, правильно?
**Ведущий:** Да.
**Участник 1:** Вот. А второе, мы говорим, что у нас вообще-то, если мы переворачиваем на сторону позиции, то мы берём от другого, что... вернее так, подразделение такое-то заказало столько-то карандашей. Вот. А... А дальше мы говорим, что а вот э-э, теперь у нас получается, для заказа мы группируем, у нас карандашей вот таких-то, да, ну, вот, у вас же нет группировки, но мы, по крайней мере, выбрали нужные записи. Из этого можно потом, ну, другие вычисления делать.
**Ведущий:** Ну да, потом можно и суммирование построить, и всё, что угодно.
**Участник 1:** Да, и мы говорим, что заказать там столько-то, этих столько-то, этих столько-то. Правильно?
**Ведущий:** Всё правильно, да. У вас итератор на выходе есть, вы можете дальше по этому итератору уже разложить, уже просуммировать именно по нему.
**Участник 1:** Ну, это нужно садиться ещё раз, опять же, после того, как вы нам всё расскажете до конца, да, нужно некоторое время, чтобы в голове покрутилось, в подкорке. Потом сесть, ещё раз почитать и попробовать вот для себя разложить, а как это... ну, нарисовать, как это... как эти итераторы работают.
**Ведущий:** Ну да, но здесь важно как бы... смотрите, то есть итератор работает в пределах формулы. То есть вот у вас итератор вот отсюда начался, да, вот у вас первая формула, он у вас отсюда начался, то есть у вас вот здесь вот нашёлся... нашлась одна запись, ну, должна быть одна по... по сути, потому что не могут быть не уникальные атрибуты, да, то есть два атрибута не может быть с одинаковым наименованием в одном шаблоне. Вот, потом по второй тоже один итератор нашёлся, и дальше как бы у вас входит в формулу там, в следующую формулу. У вас внутри формулы раскручивается итератор полностью, то есть у вас `Positions` там по одной переключается внутри на следующую строку, здесь потом вычисляется также набор. Вот. И он проходит по всему, то есть и затем на выходе, да, он уже из формулы вот в следующую строчку выдаёт. Потом на выходе из вот этой формулы, он уже выдаёт следующую строчку и так далее, и так далее. Понятно, да? То есть у вас в пределах одной формулы итератор бегает э-э как бы, э-э, крутится, возвращаясь там на предыдущие. Как только мы вышли за пределы, всё, у вас итератор формируется как один, и он, соответственно, будет итерировать общее. Если мы говорим про `assert:count`, то, если, например, вот здесь вот... Так, что-то я далеко... Да, если вот здесь вот ещё какой-нибудь оператор, например, появился бы, да, что-то появилось бы, то он бы итерировал, вот он для каждого бы `count` считал.
**Участник 1:** А...
**Ведущий:** То есть, для каждого бы считал `count` и выводил бы как бы уже `multi-value`. В это, несколько каунтов бы сделал в `?value`. Это нужно понимать.
**Участник 1:** А... так, ещё раз. Смотрите, мы... что значит ещё одна строчка?
**Ведущий:** Ну, если у вас здесь вот, да, есть какой-нибудь оператор, например, получить э-э, там, не знаю, подразделение, да? Айтем там, подразделение какое-нибудь, там, подразделение `val`. Ага. Вот. У вас по каждому подразделению дальше... будет крутиться `count`. Да, тут нужно понимать, что как бы в пределах формулы действует итератор. У вас формула вот она общая, соответственно, вот здесь вот пойдёт итератор вот по вот этому оператору. Формула будет восприниматься как одно, это вот, вот, вот, тут тройка тоже нужно понимать, да, вот всё, что обрачено в скобках — это один аргумент, это субъект у вас вычислится. `assert:count` — это предикат, соответственно, `?value` — это объект. Вот, э-э, функтор работает так, что он берёт субъект, да, как входящую переменную, дальше выполняет функцию, и в `?value` помещает значение.
**Участник 1:** Вот.
**Ведущий:** Вот. Ну, как и здесь, да, у вас на вход вот массив, на выходе, соответственно, ой, в качестве предиката — функция, и дальше на выходе — переменная, в которую помещается значение этой функции.
**Участник 2:** А... а как мне потом вот, вот, допустим, я дальше захотел это использовать и уже просто, ну, просто, грубо говоря, в виде текста вывести? То есть, ну, допустим, мы захотели... Вот именно с этим учётом то, что у вас... Э, вот для, допустим, для подразделения `val`, допустим, что-то делали.
**Ведущий:** Так.
**Участник 2:** Вот, э-э, вот насчитали по подразделениям, везде есть количество. Ну, вот... Так. И теперь мне нужно сформировать строку, которую и выдать. Вот именно, обычно, вот в качестве вот набора. То есть если мы там `true`, `false` возвращали...
**Ведущий:** Да.
**Участник 2:** ...значит, мы можем и строчку получить. А, в которой будет написано: "подразделение такое-то, э-э, столько-то количество". Ну, неважно чего, там айтемы мы можем не расшифровывать, допустим.
**Ведущий:** Да, вы можете дальше вот здесь вот, например, какой-нибудь там переменную `count` назвать, да, у вас будет переменная `count`, а дальше вы пишете, что... Так... Ну, вот это всё оборачивается во `from`. Да, если вы подразделение. Во `from`. `from` собирается в список, а дальше есть... `list`... `list`, по-моему... `join`. Так, `join`, которая на выходе вам соединит, да, тут будет массив будет, ваш итератор и там `count`, и разделитель какой-нибудь. Ну, дальше тут можно ещё объединить, то есть `count` плюс подразделение сделать, то есть там есть этот, как его зовут, `concat`, тоже функция `string`, по-моему, она... Ну, то есть это вот как раз в документации это есть.
**Участник 1:** Хорошо.
**Ведущий:** Да, джойном объединить в одну строку все... всё, вот то, что вы насобирали в каждом итераторе.
**Участник 2:** А, хорошо, это...
**Ведущий:** Это лучше потом, потому что...
**Участник 2:** ...надо...
**Ведущий:** Это я уже в сложности ухожу, это, наверное, лучше пока отложить.
**Ведущий:** Я говорю про то, что как бы... тут механизмов миллион, которые как раз-таки можно по-разному крутить. Вот.
**Участник 1:** Так, хорошо.
**Ведущий:** Ну, общий принцип, да, то есть итератор, он действует в рамках формулы, и формула, соответственно, у вас выполняется от начала до конца. И на выходе получается результат. Вот у вас фактически субъект вот этот вот, ой, формула вот эта вся, она заменяется одним итератором, который подаётся на вход э-э, `assert:count`. И `count`, соответственно, считает на выходе количество, то, что итератор пришло от формулы. Понятно, да?
**Участник 1:** Значит... у нас... подождите, после отработки этой штуки, вот теперь смотрите. У меня вот эта вот штука отработала. Так? Э-э, что у меня на выходе?
**Ведущий:** У вас будет на выходе количество, которое вернёт, соответственно, э-э, вот этот запрос.
**Участник 1:** Не, пока не вернёт, пока, потому что `?value` пока нет.
**Ведущий:** `?value`... `?value`. `?value`. `?value`. `?value`. `?value`.
**Участник 1:** А, `?value` нет.
**Ведущий:** Ну, если `?value` не поставите, у вас, во-первых, не сохранится, да, он не позволяет, без использования `?value`, то есть контролируется. А во-вторых, `?value` как бы у вас, ну, в смысле, он `null` будет, то есть пустой, если даже если вы его не заполните, если он не это... не заполни... не заполнился, то он у вас просто...
**Участник 1:** То есть по сути дела, я сделал вычислительное поле, которое э-э мне его как бы там, ну... будет заполнять.
**Ведущий:** Да-да-да.
**Участник 1:** Понял.

**[00:25:32]**

*(Ведущий переключает на следующий слайд. Заголовок: "Запросы N-Triples". Подзаголовок: "Примеры (union)".)*

**Ведущий:** Так. Следующая. `union`.
**Участник 1:** Ну, `union` мы уже видели.
**Ведущий:** Мы рассказывали, да.
**Участник 1:** Здесь более такой пример, то есть у нас есть накладная, есть грузополучатель, есть э-э грузоотправитель, есть получатель. И, например, мы всех контрагентов хотим там посмотреть... а, сколько их. Ну вот, собственно, их объединяем, да. И у нас в контракторе будут и грузополучатели, и отправители. Ну, тут их может быть ещё больше, там, может три контрагента у нас по накладной.
**Участник 1:** Смотрите, накладная, грузополучатель, да? Мы говорим, э-э, кем, ну, условно, кем поставляется, да? И в той же накладной мы говорим, есть получатель. Мы говорим, кто получает?
**Ведущий:** Да.
**Участник 1:** Теперь мы... формула наша. Мы говорим... э-э... так. `?item ?ShippedBy ?Contractor`. Ну, контрактор, понятно, это какое-то значение, которое я должен подставить.
**Ведущий:** Это как раз-таки переменная, в которую будет складываться результаты каждой из итераций. То есть вот здесь формула независимая, она вычислится в `?Contractor` поло... такой... Вот здесь формула независимая, она вычислится, в `?Contractor` положится, и `assert:union true` затем объединит их в одну, в это, в один итератор. То есть `?Contractor` на выходе вот... вот этой вот тройки, да, всей...
**Участник 1:** Понятно.
**Ведущий:** ...это массив... э-э, этих...
**Участник 1:** Кто нам поставляет и кому поставляем мы, правильно?
**Ведущий:** Да. И, соответственно, дальше `?Contractor` мы используем в качестве этого, то есть он в `?value` положит уже...
**Участник 1:** Всё, всё.
**Ведущий:** ...свои значения, все собранные.
**Участник 1:** Отлично. Отлично. Понятно.

**[00:27:05]**

*(Ведущий переключает на следующий слайд. Заголовок: "Запросы N-Triples". Подзаголовок: "ЗАДАНИЕ 4".)*

**Ведущий:** Вот. Как-то так. Ну всё, дальше задание.

**[00:27:12]**

*(Пауза)*

**Участник 1:** В сравнении...
**Ведущий:** Можем отложить, ну, в смысле, отложить, э-э, задание вам дать в оффлайне, чтобы вы как-то посидели, подумали, покрутили. Вот это очень интересный пример, он непростой.

**[00:27:29]**

**Участник 2:** Так а давайте его отдельно, потому что это стоит реально, когда маленько уложится в голове.
**Ведущий:** Да.
**Участник 2:** Вот. А мы сейчас маленько дальше продвинемся, и у нас хотя бы запись будет, можно будет вернуться.
**Ведущий:** Угу.
**Участник 1:** А что у нас дальше?

**[00:27:42]**

*(Ведущий переключает на следующий слайд. Заголовок: "Запросы N-Triples". Подзаголовок: "ЗАДАНИЕ 4 Решение".)*

**Участник 1:** А, решение нам не надо, убираем его. Нам не надо решение. Но не надо, не надо. Давайте дальше.
**Ведущий:** Да тут... видите, оно... тут я прямо по итерациям уже в это раскладываю, да. Ну, да, это я уже...

**[00:28:03]**

*(Ведущий переключает на следующий слайд. Заголовок: "Запросы N-Triples". Подзаголовок: "ЗАДАНИЕ 5".)*

**Ведущий:** И задание пять, ещё это написать запрос, который показывает количество уникальных контрагентов, указанных на накладной.
**Участник 1:** Так, давайте тогда так сделаем.

**[00:28:11]**

*(Ведущий переключает на следующий слайд. Заголовок: "Использование N-Triples в платформе". Слайд содержит таблицу "Параметры на входе и выходе".)*

**Участник 1:** Так, стоп.
**Ведущий:** Ну и дальше вот пошло уже в использовании платформе, где как. Вот я как раз здесь расписал, да, в каких местах, где `?item`, где `?value`, то есть где вход, где выход.
**Участник 1:** Так. Так, так, понятно. То есть в вычисляемом атрибуте у нас ID текущей записи на вход, на выходе `?value` - это значение, которое вы в атрибут хотите поместить. Список, список на фи... на списке, который э-э у нас строится в качестве тройки пишется, там только `?item` в виде выходного параметра, то есть на вход ничего нету, там, по сути, можно точку входа любую взять. Вот. А на выходе будет должен быть ID записи, которую вы в списке хотите показать.
**Участник 1:** Угу.
**Ведущий:** Вот. Операциям, соответственно, есть условие понятия, да, где `?item` будет тоже текущая запись, которую вы выбираете на операцию, и `?value` как бы `true` или `false` показывать или не показывать операцию по этой записи. Ну, это что касается...
**Участник 1:** То есть показывать и не показывать? Ну, это чтобы прятать можно было.
**Ведущий:** Условия отображения именно.
**Участник 1:** А...
**Ведущий:** Ну, если у вас операция "завершить задачу", да, а задача уже закрыта, вам же нужно прятать для закрытых задач. Вот. Соответственно, вы пишете это условие только, что как бы по `?item` текущая задача открыта.
**Участник 1:** Ну вот это сейчас не запомнишь, но вы говорите, потому что потом это только слушать надо.
**Ведущий:** Потому что здесь, смотрите...
**Участник 1:** Георгий, возникает очень такой вот вопрос. А откуда мы можем взять, э-э, ну вот, смотрите, есть, как вы говорите, есть адепты, которым хочется чего-то большего. И, ну, действительно, вот там, если брать э-э, ваши выражения, ну, я не имею в виду тривиальные выражения, я имею в виду вот то, что будем так называть, а-ля Excel, да? Те функции, которые у вас есть. А, то в них я могу делать вещи, ну, достаточно простые, понятные, опять же, а-ля Excel. То есть вот есть записи, э-э, или там значения полей. Нет, значения полей конкретно. Я с ними могу что-то делать. Да. Не более того. Значения атрибута. А вот если мне нужно что-то, вот как вы там, примеры... ну вот тот же замечательный процесс, который мне будет служебный процесс, который будет запускаться, искать все задачи, которые у пользователей не выполнены, да, и, соответственно, давать им, и если, если они просрочены, то, соответственно, там, давать... посылать им напоминалку о том, что это делается. Надо, надо... у вас задачи, типа, делаете. Ну, или дальше уже продолжение банкета, что если это не помогает, там, ну, допустим, в течение недели, то тогда начинается отсылка копии ещё и руководителю подразделения. Ну вот. Я ведь кроме как N-Triple, я это не сделаю, правильно?
**Ведущий:** Ну, смотрите... С уведомлениями вообще как бы система... ситуация такая, что у нас давно функционал этот в воздухе витает, да, его уже просят там многие, да, но как бы, а-а, пока ещё не возникла идея, как её правильно сделать так, чтобы был компромисс между сложностью настройки и как бы, э-э, функциональностью. А, да, первое, что вы можете сделать — это настроить, в принципе, ну, вот как у нас сделали на прикладном уровне, просто шарики на процессе прямо.
**Участник 1:** Ну, таймеры.
**Ведущий:** Ну да, таймеры, грубо говоря, что как бы, ну там не просто таймеры нужны, там именно... ну хотя да, таймеры с вычислениями, всё правильно. Вот. Можно на задачу повесить таймеры, грубо говоря, да. Если задача не завершена, то у неё непрерывающееся событие, которые со своим временем просто будут это, альтернативно выходить и отправлять какие-то почтовые уведомления куда-то.
**Участник 1:** Да.
**Ведущий:** Вот. Э-э, но, сами понимаете, да, эти почтовые уведомления, они все будут зашиты тогда в модель процесса, и дальше, если их нужно изменить, то это вам нужно изменять модель процесса. А по старым, например, уже экземплярам запущенным, как бы, ну, уже сложнее, то есть...
**Участник 1:** Не пойдёт.
**Ведущий:** Да, не пойдёт. Соответственно, здесь для вот именно уведомительных вещей тут нужен совершенно иной механизм.
**Участник 2:** Вот.
**Ведущий:** И, ну, если мы говорим именно про этот функционал, то как бы здесь нужен отдельный совершенно механизм, э-э, который позволит прямо в онлайне, да, самим пользователям, ну, не пользователям даже, наверное, а... э-э... поддержке, да, то есть бизнес-аналитику или как его можно назвать, который, человек, который как бы отвечает там, владелец процесса, не знаю, который просто по этому процессу прямо снаружи, в рантайме, так сказать, то есть в режиме оперативной работы без изменения модели процесса может вешать какие-то события на задачи, на процесс в целом и так далее, которые позволят там делать и рассылки, и интеграции, и что-то ещё, то есть какие-то такие вот как раз-таки вещи, да, э-э, которые вообще никак на модель процесса не влияют.
**Участник 1:** Ну, вы знаете, здесь, сейчас, извините, что я перерываю, здесь, давайте вот сразу говорим, вот, э-э, те, кто, как вы говорите, владельцы процесса, они этого не сделают. Ну, не сделают, у них слишком низкий уровень. То есть это обязательно должна быть поддержка. И вы абсолютно правы, вот здесь, э-э, речь идёт о том, что создаются боковые процессы, э-э, которые там, неважно, какими способами, но смотрят на существующие процессы и потом, соответственно, выдают либо напоминалки... Это мы про напоминалки говорим, но это же масса других моментов. Ну, например, э-э, зачастую очень сложно просчитать... э-э, ну вот, здесь я всегда могу любой шаблон записи взять, правда, в рамках моего неймспейса.
**Ведущий:** Так.
**Участник 1:** В четвёрке вы, если я правильно помню, вы же сами говорили, что э-э, уже и не будет ограничений на бизнес-приложение, любой шаблон уникальный... Всё равно все шаблоны записи уникальны.
**Ведущий:** Да.
**Участник 1:** Ну, в пределах инстанса. Назван... ну, системные имена. Соответственно, я могу взять любой шаблон и, соответственно, ну, вот как-то с ними там найти одно, второе, третье, там, что-то подставить. Ну, то есть сделать такую достаточно серьёзную, в основном, конечно, поисковую, но ещё и, возможно, вычислительную штучку. Ну, там, кто-то статистику запросил какую-то странную. Я знаю, что вся информация есть, но вот я нарисовал вот эту вот... вот этот запрос. И оттуда я получил, соответственно, значение, которое я потом где-то в какой-то список или там, вновь созданный шаблон сделал. То есть мне не надо создавать чего-то там э-э, специального в процессах, там, смотреть и так далее. Это всё сбоку идёт.
**Ведущий:** Да.
**Участник 1:** Ну, например, смотрите, есть куча процессов, ну, условно, представьте себе, у нас уже куча процессов. И мне говорят: "А дайте мне, пожалуйста, статистику по тому, какие процессы, какое подразделение как выполняет. Вот где у них там задержки, там, где что и так далее. Среднее время прохождения процессов, ну и так далее".
**Ведущий:** А это уже ещё одна отдельная задача.
**Участник 1:** Да, конечно.
**Ведущий:** Поэтому тоже есть отдельный функционал, по нему даже уже наработки какие-то есть.
**Участник 1:** Да, но это... это пока функционал и наработки. Но, э-э, я к тому, что у вас же где-то есть описание классов, описание, э-э, ну, вот, то, что сегодня до перерыва я говорил,
**Ведущий:** Моделька вся есть, конечно, она это...
**Участник 1:** Да, но просто там...
**Ведущий:** Да, но просто там это...
**Участник 1:** Я пытался по ней, например, э-э, активные процессы. Ну, в смысле, что он неактивный процесс, да? Вот так-то называется, вот, но процесс неактивный. И я не нашёл, как правильно это делать. Я не нашёл, там, вот, вот has error у вас есть, например.
**Ведущий:** Да.
**Участник 1:** А вот как сказать, как правильно написать проверку, что процесс, допустим, `canceled` или `active`?
**Ведущий:** Ну, статус у него там есть.
**Участник 1:** Да, есть, а как правильно написать? Вопрос-то в этом.
**Ведущий:** Я писал `process:status`, двоеточие... ну, `process`, двоеточие, `status`. Что там?
**Ведущий:** Ну, вам нужно на вход объект.
**Участник 1:** Да.
**Ведущий:** Вот. А на выходе у вас, ну, и по... на... в смысле, на выходе... в качестве предиката — проперти, а на выходе — как бы её значение. И искомое значение вам нужно сравнить, заматчить. Если оно не матчится там на искомое значение, то есть, что он активен, то он у вас в `null` вернёт.
**Участник 1:** А-а, а значение-то какое? Как оно называется? `is active`?
**Ведущий:** А там этот, как его зовут, должен быть нумератор. Но это, я думаю, вы вряд ли, это ж всё в коде должно быть, в N-Tri лежит.
**Участник 1:** Правильно, но вот смотрите, вы...
**Ведущий:** Читать мы читаем, это называется, смотрим в книгу и ничего не видим.
**Участник 2:** Ну, вот я могу добавить то, что на Визарде я, конечно, это всё нашёл. А, но нашёл это только, ну, нечестными способами. Я просто все бинарники, все делельки скопировал себе, подключил и просто в коде C# смотрел в библиотеке, просто в библиотеке. Понятно, что я их запустить не могу.
**Ведущий:** Там сами DLL-ки не нужны, там N-Tri лежат в открытом виде. Вот, и именно они модель определяют системную.
**Участник 1:** Ну я... а я смотрел ровненько N-тришки. Ну вот, N-тришки — это как раз правильный путь, то есть именно N-тришки.
**Участник 1:** Я не совсем понял, а как правильно их всё-таки там, э-э, ну, использовать. Это же тоже, это нам-то, вам-то уже привычно, а нам-то, людям новым...
**Участник 2:** Я-я-я поэтому и привёл этот пример, то, что в C# даже не имея доступа к... к нормальному доступу кода, ну, мне только сигнатура методов, я нашёл, нашёл, как статусы называются, как их правильно передать. Всё это, и нормально фильтровалось у меня на C#.
**Ведущий:** Ну вот есть `processObject` файл, `cis.processObject.ntri`. Ну, да. Вот, если вы его откроете, здесь есть э-э, переменная `processStatus`. Есть свойство, внизу `processStatus`. Можно промотать, и вот здесь вот как раз-таки и есть её описание, что она какое оно значение принимает. Так, где это `activity`, `token`, `token`, `error`... Так, где, где, где... Надо `processStatus` искать, это наверняка какой-нибудь enum.
**Участник 2:** Это enum, да.
**Ведущий:** И вот тот вот enum как раз-таки и нужно взять.
**Участник 1:** Ну вот, а где его искать? Вот, понимаете, вот...
**Ведущий:** `process:ActiveStatus`, он прямо так и есть. Он даже в коде здесь, прямо в N-Tri в этой же присутствует. `process:ActiveStatus`.
**Участник 1:** Да. Вот. И всё?
**Ведущий:** И как надо писать? А вот прямо... ID процесса, ну, процесс у вас, он...
**Участник 1:** Ну, понятно, да, найденный...
**Ведущий:** ...в каком контексте? ID процесса — это, смотрите, вы э-э, идёте от, э-э, я так понимаю, объекта, да? То есть у вас `item` — это объект всегда, ну, в зависимости от точки использования. Я насколько понимаю, вы где-нибудь там на этой, на форме хотите, да?
**Участник 1:** Нет, вот, у меня проще. У меня есть... а... вот давайте ещё раз. Э-э, у меня же есть э-э, шаблон записи, ассоциированный с процессом, так?
**Ведущий:** Да.
**Участник 1:** У меня ID процесса же есть, когда я шаблон...
**Ведущий:** ID процесса у вас...
**Участник 1:** ...запускаю.
**Ведущий:** Да, есть, оно 100%, и оно связано с э-э, записью.
**Участник 1:** Конкретной записью, правда?
**Ведущий:** Да, да, да.
**Участник 1:** И он там у меня где, в параметре ID, наверное, записи.
**Ведущий:** Так, давайте ещё раз. В... если в процессе... если в процессе посмотреть, то у процесса есть... Сейчас я вам скажу, как это даже называется. Так, `systemType`, `container`, `token`. `systemStatus`, `status`. `parent`, `creator`. `objectApp`. Есть `processObjectApp`, вот я вижу. Но это... Вот, `businessProcessBusinessObject`. Ну, то есть запись будет выглядеть вот так вот.

**[02:06:55]**

*(Ведущий переключает окно на Google Docs и пишет пример кода.)*

**Ведущий:** Вот, смотрите. Вот так. Вот ваш процесс... это переменная, которую мы ищем. Предикат... `processBusinessObject`... Здесь `item`. Это текущий шаблон, ну, запись. И префикс, соответственно, у вас на `process` должен добавиться. Это вот такой вот префикс. Вот и всё, как бы. У вас готово, вы вытащили процесс, а дальше от процесса, если вам нужно вытащить статус, то это... так я сейчас вас не понял, что значит...
**Участник 1:** Смотрите, у нас...
**Ведущий:** ...тот процесс.
**Участник 1:** ...смотрю на формулу, первую. У вас идёт `process`.
**Ведущий:** Первая строчка. У меня идёт первая — это из `item`-а, из объекта, по заданному, по `processObjectID`, я нахожу ID процесса.
**Участник 1:** Да.
**Ведущий:** Я его нахожу, он не задан, он не задан.
**Участник 1:** Нет-нет. Да. А тогда вопрос. И дальше по этому э-э, и дальше я беру вот этот процесс, ID процесса, да...
**Ведущий:** А дальше уже по каждому из них он проитерирует и посмотрит статус, что соответствует вот этому вот... вот этому статусу, ЕНАМу. Да, `active`, вот и всё. То есть у вас на выходе и дальше, ну, в `process` вместо `process` можно сразу `?value` поставить, типа, это выходной параметр.
**Участник 1:** Ну не надо, не надо.
**Ведущий:** Вот, и он у вас выдаст все процессы, которые как бы активны по этому объекту.
**Участник 1:** Всё, понял. Это вот... так вы на форме дальше это можете использовать, то есть вы прямо на форме можете этот список построить и увидеть.
**Участник 1:** Понятно. Ну, дальше, понятно, что с этим можно играть, и наоборот. Вот, но тогда у меня, извините, Георгий, вопрос другой. Вот у меня есть определённые... ну, есть атрибуты шаблона записи, ассоциированной с процессом приёма на работу. И у нас, э-э... вашими... ну, в смысле, коммидверовцами, там есть ID экземпляра процесса, один из атрибутов.
**Ведущий:** Ну, вычисляемый атрибут, наверное.
**Участник 1:** Нет. Текстовый. Текстового окна, соответственно.
**Ведущий:** Не, ну, наверное, вычисляемый.
**Участник 1:** Нет.
**Ведущий:** А как его туда кладут?
**Участник 1:** Не знаю. Вот он у меня есть. А кто это сделал? Игорь, ты тут или не тут? Ушёл он. Ну, понятно, что это либо Игорь делал, либо это Анна делала в своё время. Э-э... потому что там ещё где-то у меня был э-э ID, в который я вот, ну, для меня было откровением, что когда я запускаю э-э, то, что называется, повторно исполняемый процесс, да... из основного процесса, то я запоминаю в этом повторно исполняемом процессе ID вызвавшего процесса.
**Ведущий:** Ну, у него есть `parent` вообще.
**Участник 1:** Вот, ну, короче...
**Ведущий:** Просто он на интерфейсе недоступен, поэтому как бы мы такой небольшой хак делаем. Передаём ID процесса внутрь. Да, это... это есть такое. То есть они, по сути, при запуске повторно используемого передают `processID` в качестве этого, как его зовут, э-э, данных на вход, да, в это, в месседжи.
**Участник 1:** Но это делается автоматически...
**Ведущий:** И записывают в определённое поле.
**Участник 1:** ...или я должен это делать сам? Потому что у меня...
**Ведущий:** Модель... оно есть. В модели оно хранится, но к нему доступа на интерфейсе отсутствует. Они это делают, чтобы лоукодом можно было пользоваться. Ну, то есть, чтобы можно было какие-то выраженьки такие простые писать, где нужно эти процессы...
**Участник 1:** Я хочу сказать, что когда у меня на этапе стоит "поместить ID", да, это просто для того, чтобы потом можно было с этой ID крутить, правильно?
**Ведущий:** Да, потому что его вытащить невозможно из... На интерфейсе нету доступа. То есть в тройке, да, в тройке легко. То есть `parentID` достать. Это вот как бы... сейчас я прямо на лету, да, вот у вас `process` достали вы. Вот, я обратно в `process` переименую. `process`. `process`. Вот, у `process`-а есть так называемый `cmw:parent`. И вот фактически мы... сюда мы поместим `parentProcess`. Это вот `parentProcessID` как бы наш.
**Участник 1:** Угу.
**Ведущий:** Ну, для `cmw` как бы, ну, отдельный этот... префикс.
**Участник 1:** Это в `logics`?
**Ведущий:** Ну, префикс `cmw` как бы, он вот именно вот такой.
**Участник 1:** Не-не, я не о том. Я о том, это от... от `logics`, от... от логики.
**Ведущий:** Это всего лишь этот, как его зовут, э-э, синоним, э-э, используемый. Можно `logics` было его назвать, то есть это вообще неважно.
**Участник 1:** Не, я не о том, я о том, это... ну, хорошо.
**Ведущий:** Это пространство доменных имён, не... не обращайте внимания на это.
**Участник 1:** Да, на логику, да.
**Ведущий:** Да, то, что тут `logics` написано, это так назвали, так назвали, то есть не обращайте внимания на это...
**Участник 1:** То есть я вместо `cmw` могу поставить свой `fgh`, правильно?
**Участник 1:** Так, вот, смотрите, есть следующее предложение. А-а... Анатолий, ну, прокомментируй, да или нет. Э-э, что можно сделать? Вы можете... я бы что предложил. Давайте, может быть, на сегодня мы закончим. Так? Я бы попросил вас прислать нам вот эти вот, ну, там, сколько у вас заданий, три?
**Ведущий:** Два.
**Участник 1:** Два.
**Ведущий:** Два задания у нас там к текущему уроку.
**Участник 1:** Да, ну, единственное, что, да, в видео они уже попали в решение, поэтому...
**Участник 2:** Не, ну не будем.
**Участник 1:** Мы же люди честные, постараемся не смотреть.
**Участник 2:** Да.
**Участник 1:** Вот. Э-э, пришлите, пожалуйста, вот два слайда тогда, вот этих двух задач. Угу. И вот этот вот замечательный документ, который вы нарисовали. Потому что меня больше интересует вот это вот, вот то, что вы нарисовали — `prefix`, `active`, `status` и так далее. С этим интересно поиграть. Вот. А-а, мы постараемся всё это сделать. Ну и дальше уже будем смотреть, когда и где будем делать следующую сессию. А, нормально?
**Участник 2:** Да, конечно. Да, я хотел бы сейчас ещё дополнительные вопросы задать, но это именно по, в принципе, поможет мне это в будущем или нет. А именно, то есть я понял то, что здесь хорошие возможности э-э, грубо говоря, это аналог реляционной алгебры. Ну, то есть как бы, если бы я... Ну, из-за того, что я по базам специалист, э-э, много, много лет проработал э-э с базами данных. Поэтому э-э, то есть я вижу, что это аналог, э-э, ну, реляционной алгебры, ну, то есть в каком-то виде. То есть, пускай это построено э-э в других терминах, это тоже алгебра. А-а, вопрос, соответственно, другой. То, что я видел, что у нас какие-то операции возможны. Но это операции, которые мы определяем над объектами. Э, следующий тогда у меня вопрос: можно ли через э-э N-Triple э-э вызвать глобальную функцию? Она не относится к объекту, она не определяется на объекте. Это это на самой системе каким-то образом создано. Э-э, вот в эту сторону переиспользование кода. Э-э, то есть вот насколько оно у вас возможно? То есть, пускай на C# была написана функция или вызов внешнего сервиса. Просто вставить его в вычисление. Вот это самое основное вещь — это вычисление. Приведу пример. Вот э-э, та задача, которая у меня есть, которую я закрыть никак не могу. Сумму прописью-то я считаю хорошо. Но если поменяли ставку, то поле, от которого я отсчитываю, оно э-э идёт э-э как вычисляемое. Соответственно, если поменяли где-то там в связанной записи ставку, автоматически поменялось это поле, суммы поменялись, но мой код не будет вызван. То есть вот как мне подписаться на изменение э-э, изменяемого поля и как вот туда включить глобальную функцию, потому что она большая, я не хотел бы каждый раз её писать руками. Это одна сторона вопроса.
**Участник 1:** Сейчас, я могу пояснить...
**Участник 2:** Георгий, вот смотрите...
**Участник 1:** Георгий, видимо, разрез...
**Участник 2:** У нас для э-э, ну, для каждой должности определяемый, существует список выплат. Ну, оклад и какие-то возможные надбавки. И Игорь в своё время подсказал, э-э, через вычисляемую коллекцию, причём он её делал таким шаманским несколько образом, и сказал, что только вот в таком... в такой последовательности оно будет работать. Не знаю, почему. Вот если вот так вот его определять как вычисляемую вот эту коллекцию, только так она будет работать. Э-э, и вот эта штука считается, да? Соответственно, там Анатолий просто добавил ещё одно поле, и к тем числам, которые мы оттуда достаём, он ещё делает вот эти вот самые, ну, функцию свою вставляет, которая число преобразует в слова. А теперь у нас... ну, решили, что пришёл человек, у него ставка 0,3 заказана, а ставок свободных 0,2. Ну, после всех там согласований, исправлений, решили, что ставка будет... ладно, он согласился не на 0,3, а на 0,2. Значит, соответственно, должно быть пересчитано у него вот это вот числа за одной вот этой функцией. Вот Анатолий спрашивает, каким образом, если бы это можно было через N-Tri вызывать, тогда понятно. Прямо в коллекцию эту вызвали, и в неё, бубух, сделали всё, что надо.
**Ведущий:** Так, ну, смотрите, я попробую по частям ответить. Тут несколько вопросов намешано.
**Участник 1:** Возможно.
**Ведущий:** То есть первое, глобальную функцию из N-Tri вызывать можно. Это можно у Игоря спокойно, через Игоря там, через нашу библиотеку эту, как её зовут, через базу знаний. Забыл уже даже. Э-э, через базу знаний получить примеры даже. То есть там эти примеры опубликованы, как там сложные, то есть у нас даже есть пример, когда на форме данные какие-то, поля обновляются в онлайне из сервиса внешнего. Ну, то есть там где-то снаружи, да, там есть информация о компьютерах, есть веб-сервис поднятый, который эту информацию выдаёт...
**Участник 1:** Вот скажите, у вас есть такая ссылка? Я я такого не...
**Участник 2:** Нет, она, если она есть, она недоступна.
**Ведущий:** Я 100% помню.
**Участник 2:** Потому что мне 404 выдаёт любые такие поиски.
**Ведущий:** Ну, значит, там либо с КБ проблема, но, то есть надо тогда ребятам сказать, чтобы они посмотрели. Но в любом случае, это в КБ выложено, прямо как бы я помню, последний раз мы это дело разбирали и смотрели.
**Участник 1:** Если есть такая возможность, если запишите, но просто пускай там Валерий или Игорь пришлют нам вот эту ссылку, будем очень благодарны.
**Ведущий:** Да, хорошо. Вызов глобальных функций из N-Tri возможен.
**Участник 1:** Ну, глобальных функций или э-э, как бы, получение данных от внешних сервисов, да?
**Ведущий:** И именно через глобальную функцию.
**Участник 1:** Угу.
**Ведущий:** То есть у вас написана глобальная функция какая-то, она там либо простым образом получает, либо C# там какой-то есть, то есть неважно. Вот, и он просто идёт, в N-Tri обращение к глобальной функции, и на выходе как бы в это, в функторе, да, выдаёт э-э значение, полученное из глобальной функции. А она что делает уже, вообще никого не важно. Вот. Соответственно, эта часть есть. Вторая часть вопроса — как подписываться на события. То есть у нас есть, первое — это триггера. Помните такие?
**Участник 1:** Да.
**Ведущий:** Да. То есть...
**Участник 1:** Ну, они у вас теперь называются "бизнес-правила".
**Ведущий:** "Бизнес-правила", да, сейчас мы уже ещё додумали, их сценариями хотим назвать, потому что бизнес-правила больше к бизнесу, а это всё-таки такие сценарии, то есть...
**Участник 1:** Согласен.
**Ведущий:** Ну, в общем... вот. Э-э, есть триггера, это первый момент. Второй, если вы хотите что-то делать на вычисляемых атрибутах, как-то подписываться на изменение вычисляемых атрибутов, то это просто бесполезная вещь, то есть это никогда не будет сделано и так не работает. То есть нужно подписываться именно на изменение исходных объектов. Если у вас что-то где-то меняется, то вы, соответственно, должны, в первую очередь, подписаться именно на них.
**Участник 1:** Э-э...
**Ведущий:** Э, я имею в виду, что... как это...
**Участник 1:** вычисляемый атрибут...
**Ведущий:** Вычисляемый атрибут, ещё раз, он не хранится в базе. На понятие там изменения вычисления такого нету события вообще. То есть, вычисляемый атрибут, он динамически выводится, да.
**Участник 1:** То есть, другими словами, когда я определяю вычисляемый атрибут, это всё-таки реально вычисляемый атрибут, это его значение вычисленное в базе не хранится.
**Ведущий:** Да.
**Участник 1:** А я что-то думал...
**Ведущий:** То есть как только вы запрашиваете по предикату этот атрибут, его значение, э-э, у вас база, да, превращает, то есть...
**Участник 1:** А...
**Ведущий:** Ну, вот я вам показывал, да, пример, то есть у вас функтор запускается, который просто вернёт вам, выполнит функцию и вернёт...
**Участник 1:** Всё...
**Ведущий:** То есть ваш запрос, по сути, который вот написан в этом квадратике, обернёт вот это `in`, `item` и так далее, значение, э-э, на выходе в `?value`, и вернёт это значение. Всё, то есть здесь всё в онлайне должно меняться.
**Участник 1:** Георгий... Георгий, вы мне э-э просто камень с души сняли. Вычисляемые атрибуты э-э в базе не хранятся. Я крупными буквами всё и пишу. Отлично.
**Ведущий:** И вот прямо их нельзя воспринимать как да, какие-то хранимые, как-то на них подписываться или что-то с значениями делать. Всё, вот, вот прямо это табу. Они могут только вычисляться в момент обращения к ним. Читаете значение, они только в этот момент могут считаться, то есть другого, других механизмов вообще нету. А подписаться на те объекты, которые хранимые и которые изменяя, при изменении которых меняется это вычисление, вот это как бы уже с помощью триггеров можно.
**Участник 1:** Что значит подписаться? Ну, вот, там на изменение атрибута, да, какого-нибудь...
**Ведущий:** Ну, смотрите, вот очень просто, вернёмся к тому примеру, который я сказал со ставкой. А-а, вот то, что я вам сказал, на самом деле получается другое. Получается, что как только я изменил значение ставки, да, то тем самым у меня вычисляемая коллекция автоматически пересчитается при её вызове.
**Ведущий:** Хм... смотрите, э-э... коллекция...
**Участник 2:** Я набираю, набираю значения. Вот у меня э-э вычисляемая коллекция, она состоит из ряда полей. Есть поля, которые вытаскивают там константы, там, значение оклада, значение э-э той-то надбавки, значение такой-то надбавки, да. Это фиксированные значения, которые я беру там из другого шаблона записи. А когда я их выдаю, я их... и у меня там есть вычисляемые поля, которые мне говорят, что, ну, вот, умножаю вот это на значение ставки и получаю уже естественное... То есть это будет вычисляться как только я начну его там выводить на экран или там в шаблон буду... шаблон... пардон, буду укладывать в документ. Я правильно вас понимаю?
**Ведущий:** Э-э, Александр, э-э, гораздо хуже ситуация. Я на экране когда смотрю, то есть я вывел все поля, в том числе и табличку выплат, которые являются дочерними, ну, для меня они, с точки зрения базы, дочерними записями. Я меняю ставку, по... ну, первый раз у меня получилось случайно, потому что у меня ставок уже не хватало, пришлось поменять. Потом смотрю, у меня не сходится рассчитанная моя сумма прописью с тем, что выводится вычисляемым полем, от которого я считал. Я просто проверил там же, просто редактирую запись, а с... где есть ставка, соответственно, в выплатах, э-э, все записи поменялись сразу же там же при показе. То есть я даже не процесс, ничего не работает, просто я меняю запись.
**Участник 1:** Но это и означает вот то, что Георгий сказал, это значит, что они действительно вычисляются по ходу, да.
**Ведущий:** Да.
**Участник 1:** Полностью. Как только они на форму попадают, всё, они должны вычислиться. Правильно, Георгий?
**Ведущий:** Да. Ну, то есть если вы, ещё раз, вычисляемые атрибуты, они работают следующим образом. У нас как бы на... есть форменные правила, да, есть там вычисляемые атрибуты. Вычисляемый атрибут, он работает, если на записи какая-то, ну, в смысле, если данные какие-то изменились на форме текущей, то вычисляемый атрибут, он также будет пересчитываться при следующем обновлении. Всё, то есть здесь всё в онлайне должно меняться.
**Участник 1:** Ну, ещё раз, вычисляемая коллекция — это тоже, это как бы нужно понимать, что это такой же атрибут, да, который тоже ничего не хранит, самой коллекции, фактически там связи не существует. Он показывает лишь виртуальный набор записей, который вы хотите как бы отобразить в данный момент. Всё, то есть там ничего нового не появляется, ничего... тут нужно понимать, что это...
**Участник 1:** Но за счёт того, что у Анатолия при изменении ставки должно было поменяться и словесное представление этих чисел.
**Ведущий:** Ну, вот вопрос, что именно? То есть у нас... А, у вас, наверное, как раз-таки работает двойная цепочка. То есть фактически...
**Участник 2:** Да, да, да.
**Ведущий:** ...двойная цепочка, здесь это зависимые правила, когда у вас сначала одно значение, потом другое. При последующих изменениях оно пересчитывается, я насколько понимаю. Только второй раз...
**Участник 2:** Нет-нет, при сохранении пересчитывается.
**Ведущий:** В том-то и дело, что...
**Участник 2:** В том-то и дело, что я не знаю, как выражением правильно вызвать э-э глобальную функцию. Я понимаю, что это легко сделать, потому что у вас достаточно хорошо ребята проработали, то есть я мог бы туда сказать, какую глобальную функцию вызвать, сказать, какой `dictionary` передать... просто в этом же выражении. И какой...
**Ведущий:** А глобальная функция где вызывается, прошу прощения?
**Участник 2:** А в процессе пока вызывается.
**Ведущий:** А, всё, тогда понятно.
**Участник 2:** Она, она много где...
**Ведущий:** Тогда, конечно, оно не пересчитает таким образом. Всё, тогда у вас только глобальная функция поможет.
**Участник 2:** Она, нет, она глобальная функция есть. Она называется "прописью".
**Ведущий:** Это правилами на форме делается.
**Участник 2:** А, а здесь не форма, нужно, чтобы в любом месте использования записи, потому что это может быть любая другая форма. То есть это должно быть выражение, именно выражение вычисляемого поля. То есть я бы сделал бы вторичное вычисляемое поле. И вот в качестве выражения использовал бы вот N-Triple или другую конструкцию. Потому что у вас явно эта возможность есть. Она, я думаю, ещё в версии до тройки была, скорее даже в двойке. Потому что раз вы это сами реализовали, значит, оно у вас есть. Просто оно не открыто и не показано в документации, как правильно вызвать.
**Ведущий:** Я вот что-то где-то не... не улавливаю всё до сих пор.
**Участник 2:** А, хорошо.
**Ведущий:** На примере взять.
**Участник 2:** Нет, а на... на примере... я... я попробую ещё раз кратко на словах. Если не получится, то ничего страшного, потому что мы долго уже работаем. А-а, глобальная функция. Она принимает один параметр, э-э, который `decimal`. Э-э, то есть входящий пакет с одним параметром, там, `dValue`. У неё исходящий параметр один - `sValue`, это строка. Она умудряется э-э, пересчитать и всё. А, соответственно, её именно как вызов сервиса, я в процесс могу вставить, передать туда э-э, число и присвоить это э-э, строковому атрибуту. Это реализовано в нескольких местах у меня, потому что у нас очень таких мест. Теперь, но при этом в качестве входного параметра я передаю вот этот `decimal`, который, э-э, то есть, э-э, числовой параметр. Это уже вычисляемое поле. Вот если бы я не вот этот вызов сервиса сделал в процессе, а я бы настроил бы ещё одно вычисляемое... просто это сделал бы вот это строковое поле вычисляемым, э-э, и там была бы простая формула написана. Э-э, `execute` типа, вот, э-э, `GlobalFunction` из какого-то солюшена, э-э, с таким-то именем, ей такой-то `dictionary`, то есть `new` э-э, `dictionary string object`, и передал бы значения. И оттуда бы принимал бы сразу, разобрал бы эту строку, которая возвращается, мне там не `dictionary` должен был бы вернуться, сразу сказал, что вот такое-то значение вернуть, и всё. Вот одной строчкой это записывается в выражении. Только я не знаю, как... какой метод вызвать ваш глобальный.
**Ведущий:** Ну, с точки зрения реализации как бы всё для этого есть, это без проблем.
**Участник 2:** Да я знаю, что оно есть. Более того, я...
**Участник 1:** Так, договорились, да?
**Ведущий:** Да-да.
**Участник 1:** Нет, всё, всё, всё, всё, всё.
**Ведущий:** Всё. Ребята передадут.
**Участник 1:** Игорь, я думаю, легко там передаст. Вот.
**Ведущий:** Вот.
**Участник 1:** Поэтому давайте вот так и сделаем, потому что уже у нас сейчас у Анатолия там уже ближе к десяти, в смысле, десятый час пошёл вечера.
**Участник 2:** Да ничего страшного. У меня ещё один вопрос есть. Э-э, один вопрос, э-э, на первый взгляд, простой. Э-э, я, разумеется, научился, как пользоваться шаблонами, и использовать C#, для того чтобы э-э в шаблон переда... из, ну, в шаблоне заполнять поля. То есть я создаю структуру объектов, всё нормально заполняется, всё уходит туда. Вообще без вопросов. А, но при этом есть отдельный механизм, когда в этот шаблон уходит текущий объект. Как мне простым способом передать в шаблон и существующий объект, на котором вызвано... то есть у меня шаблон по экспорту конкретной записи. И вот по ней он должен сработать, по-хорошему. Ну, то есть не для списка даже, для списка это отдельно можно потом обсудить. А вот именно для конкретной записи есть шаблон, как экспортировать. И там, понятно, что в фигурных скобочках я написал уже поля записи. То есть, значит, у вас есть нормальная генерация типов, либо `dynamic` хорошо используется. То есть вы это всё разбирать умеете в шаблонах. А если я передаю свой объект, тоже всё замечательно, вы разбираете. Как мне в моменте C# скрипта, привязанного при экспорте, написать, э-э, чтобы хотя бы полем этого объекта, который я буду передавать, существующий объект, который уже есть. Потом... как вот это описание получить? Я же не должен дублировать полностью структуру, а-а, шаблона записи.
**Ведущий:** Так... Ну, смотрите, у нас с шаблонами экспорта есть два механизма, да. Один там лоукодный, который просто позволяет в фигурных скобках что-то там как темплейты задавать. Вот, второй механизм через N-Triple.
**Участник 2:** Через C#.
**Ведущий:** Через C#, через C#.
**Участник 2:** Да.
**Ведущий:** Вот. Через C# вы там вообще можете сделать всё, что угодно. Вам нужно в любом случае создать, определить структуру класса, которую вы будете как бы передавать в качестве аргумента внутрь, э-э, шаблона. А шаблон немножко с другими тегами идёт.
**Участник 2:** То есть он немножко по-другому конструируется.
**Участник 1:** Можно, я всё-таки встряну, а? Я не к тому, что там, я не говорю, что проблемы нет. У меня просто, э-э, момент следующий. Первое, задача, которую сейчас рассказывает проблема Анатолия, она для нас важна. Валерия я не вижу, он, наверное, отошёл, да. Э-э, Анатолий, я попробую с Валерием договориться о какой-то сессии, может быть, там, давайте Георгия не будем мучить, с кем-нибудь другим, э-э, кто бы рассказал вам про этот вот механизм, как там правильно делать.
**Ведущий:** Да нет, надо просто пример открыть, прямо, и посмотреть, в чём проблема. Я просто как бы это... сейчас вот я слышу, что это...
**Участник 1:** Скобки — это первый механизм...
**Ведущий:** Да, скобки — это первый механизм, лоукодный.
**Участник 1:** Второй механизм через C# — это там через точку, дата там и так далее.
**Участник 2:** Да, но при этом в шаблоне... в шаблоне те же самые... Нет, в том-то и дело, что даже вот у вас пример на C#, который официально опубликован по 3.5, там используется один через точку, а другой используется именно через фигурная скобочка, и дальше пошли поля. И я вижу, то есть это именно ваш официальный пример по... именно самый стандартный, просто по использованию C#. Я ориентируюсь на него.
**Участник 1:** Это... это в КБ, я просто говорю.
**Участник 2:** Да, да.
**Ведущий:** Я в КБ, честно скажу, не знаю по поводу того, кто написал такой пример, что фигурными скобочками и C#.
**Участник 2:** Да.
**Ведущий:** Насколько это рабочий вариант, я просто таким не пользовался.
**Участник 2:** А он работал, вот как если я правильно помню в своих экспериментах.
**Ведущий:** В чём именно?
**Участник 2:** Я сомневаюсь, что он работает.
**Ведущий:** Я сомневаюсь, что он работает. Мне кажется, у вас C# отрабатывает, но фигурная скобочка так и подхватывает как бы поля, которые поля этого...
**Участник 2:** Нет.
**Ведущий:** Скажите мне...
**Участник 2:** Если вы говорите, что можно использовать фигурные скобочки и другое...
**Ведущий:** Я наоборот говорю, что фигурные скобочки используются только без C#.
**Участник 1:** То есть фигурные скобочки используются для лоукода.
**Ведущий:** Да. Смарт-теги понятия, смарт-тегов, да, они в смарт-тегах описаны уже в это, в документации по Aspose. Вот. Именно смарт-теги используются в качестве уже нормального C#-ного обрамления для как бы скрипта.
**Участник 2:** Да.
**Ведущий:** Вот.
**Участник 2:** Я просто с именами я так и не понял проблему, как бы...
**Участник 2:** С именами, ну, ну... хорошо. Э-э, там даже простая вещь. Если, вот вы говорите, просто замапировать. Там не мапируется же просто так в C#. Э-э, если писать...
**Ведущий:** Да.
**Участник 2:** ...потому что ссылка на справочник. Соответственно, я должен дальше искать из справочника эту запись.
**Ведущий:** Это само собой разумеющееся, да.
**Участник 2:** Это...
**Ведущий:** Да, да, вот я говорю, то есть это, соответственно, это не просто мапирование. Вот, э-э, поэтому я должен, чтобы заполнить эту структуру и отдать её туда, чтобы она потом работала именно только с C#, вот... вот что я ожидал. Что у меня есть объект, то, что и так бы пошло бы на экспорт, я бы мог его дополнить, либо его включить в свой объект, и к нему обратиться уже тем же самым способом в шаблоне записи, ой, в шаблоне экспорта. Обратиться к более сложному объекту, в котором есть и основная запись, и то, что я к ней понадобавлял. А в ваших примерах либо мы полностью сами всё формируем, либо полностью только запись. А вот как их скрестить без мапирования? Вот просто соединить объекты. Потому что у вас этот объект есть. Вы же это делаете как-то.
**Ведущий:** Ну, у нас... я вот просто, простых у нас способов нету, да. Всё, что на лоукоде доступно, то и доступно. В C# как бы, там всё, вы работаете через API уже как бы нормальными...
**Участник 2:** А, а хорошо, смотрите.
**Ведущий:** ...апишными методами.
**Участник 2:** А на C# у меня объект, кроме как просто `dictionary`, доступен именно как объект? Пускай как `dynamic`, вот этот тип данных, в котором...
**Ведущий:** В `dictionary`, да. В `dictionary`, у вас любая функция, она пишет...
**Участник 2:** Нет, не `dictionary`.
**Ведущий:** Нет, не `dictionary`, а вот именно вот, ну, когда он на лоукоде у вас в виде `dynamic`, то есть когда точка, дальше название свойства, точка, дальше, то есть всё расписали одним выражением. Вот такая возможность есть на C#?
**Ведущий:** Она была, точнее, она есть, но она не... сейчас, ну, не отключена, но очень не рекомендуется использовать, потому что она медленная, и её отключили. Это вот переменная `entities`, которая как бы в качестве входящего параметра в операциях существует.
**Участник 1:** Анатолий...
**Ведущий:** Вот.
**Участник 1:** Анатолий, секундочку, можно я вас перерву ненадолго?
**Участник 2:** Да, да.
**Участник 1:** Я уже, вот первое, я предлагаю, ещё раз говорю, может быть, там другую сессию, специально для Анатолия, как-нибудь там, через Валерия договоримся. Меня просто... как это... завершить надо, у меня просто другие дела. Если хотите, продолжайте, но мне действительно нужно ещё кое-что сделать. Вот. Могу я вас покинуть тогда?
**Участник 2:** А, хорошо.
**Ведущий:** Хорошо, давайте, правда, прекратим, потому что у меня-то тоже был...
**Участник 2:** Мне... мне рабочий день у меня кончится скоро.
**Ведущий:** Да.
**Участник 2:** Это я смотрю, что это...
**Ведущий:** Это нужно просто подготовить, чтобы вы прислали, э-э, допустим, кому-то, ну, тому же там э-э Георгию, например, вот, вот у меня вот так, вот я не вижу, вот где вот так, где вот так. Чтобы можно было потом от чего-то танцевать, потому что на словах я вообще ничего не понимаю. Георгий понимает больше, потому что он с этим сталкивался. А так вы уже сможете предметно задавать вопросы.
**Участник 2:** А, хорошо. А, на какой платформе я могу подготовить пример? А-а, которая доступна извне, э-э, чтобы... то есть вот... вот там, где вот тесты, то есть школа обучения, она доступна же из общего мира, ну, из внешнего.
**Ведущий:** Не школа обучения, КБ вы имеете в виду.
**Участник 2:** Нет, не на КБ, а вот там было, где...
**Ведущий:** Ну, смотрите, инстансы все, которые вам доступны, можете их использовать. Вообще никаких проблем.
**Участник 1:** А какие у нас доступны?
**Ведущий:** Вы имеете в виду наши?
**Ведущий:** Я вот не знаю, честно, я не владею ситуацией с инфраструктурой. Какая для вас развёрнута.
**Участник 1:** Понятно, давайте тогда наш...
**Ведущий:** Я тут точно не...
**Участник 1:** Есть ваши, есть наши. Давайте чуть-чуть по-другому. Анатолий, я мы же с вами не один раз говорили. Давайте так. Вы ваш вопрос пишете, да, с приложением там файлов, прочего, вы его выкладываете на сайт поддержки. Всё-таки. Вот как есть.
**Ведущий:** Это будет самый правильный путь, потому что там у нас будут и аналитики, и технические, и всё разберут. Если нужно, я подключусь.
**Участник 1:** Да, это мы уже не... не говорим о там будущих версиях, мы задаём вопрос по текущей рабочей версии. Вот. А-а, ну, и тогда уже от этого мы будем плясать, потому что вот я говорю, я сейчас с Валерием буду разговаривать по поводу... так, я примерно прикинул план, каким образом и что э-э мы у себя сделаем. Ну, моё сердце подсказывает, что к середине октября вы, конечно, за... ну, постараетесь сделать, да, но не успеете. Не потому что вы плохие, а потому что, ну, вот как бы не бывает в хорошем варианте. Э-э, но всё равно я... взял к сведению ваш, принял к сведению вашу информацию о том, что вот там, начиная с 3.6.11.28 уже можно э-э эту разработку продолжать делать и как бы с этим работать. Нам нужно к ней ещё чуть-чуть подготовиться и двигаться дальше. Угу. Э-э, момент, который там, возможно, ещё... ну, у вас, конечно, катастрофически отстаёт документация, потому что даже по 3.5 нет ничего нормального. Я вот, э-э, ну, это уже как бы беда всех, кто разрабатывает большие софтовые продукты. Ну вот, тем не менее...
**Ведущий:** Да у нас документатор просто очень глубоко взялся, и он сейчас полностью всю терминологию в порядок приводит. Прежде чем, говорит, написать документацию...
**Участник 1:** То есть вы хотите сказать, что...
**Ведущий:** ...мы взяли такого хорошего документатора, да.
**Участник 1:** ...прежде чем написать документацию 4.0...
**Ведущий:** Да.
**Участник 1:** ...не тогда, когда вы будете выдавать 6.5.
**Ведущий:** Да, да, да, да.
**Участник 1:** Потому что иначе это всё будет абсолютно бесполезно.
**Ведущий:** Ну, да, да.
**Участник 1:** Вот.
**Ведущий:** Да.
**Участник 1:** Статистика у вас будет модуль по процессу?
**Ведущий:** Э-э, не в этой версии, не в этой версии. Мы на самом деле действительно как бы вот сейчас, э-э, как раз после выпуска этой версии. Ну, просто мы уже много брать не можем, уже ни времени нету, ни довести до ума.
**Участник 1:** Не-не, я не о том. Просто то, что она у вас будет когда-то статистика.
**Ведущий:** Да, да. Она уже... она даже уже была, но её пока выпилили, потому что она...
**Участник 1:** Сырая.
**Ведущий:** ...непрезентабельная. Её быстро прикрутили, как бы, показать там, что можно. Вот, сейчас нужно её привести в порядок.
**Участник 1:** А есть вещи связанные с консолью для... для отладки, там с э-э... то, что называется, портал, консоль или личный кабинет. Это... это, я так понимаю, на следующей, да, реализации?
**Ведущий:** Да, да, да, да, да. Ну, планируется, что всё это попадёт, но я это...
**Участник 1:** Не-не, я не о том, мы же говорим...
**Ведущий:** ...убираю... Почему я говорю, расширение возможностей визуализации будет, не будет? Ну, в перспективе, я не говорю, что сейчас, понятно, что сейчас вряд ли.
**Ведущий:** Так, ну, в принципе...
**Участник 1:** Объясняю. Э-э, вот у вас там, ну, минимальная совершенно есть дашборд с очень таким простым, простым набором, э-э, графиков, допустим, которые получаются, и там только графики. Э-э, а хотелось бы всё-таки, если дашборд, то там должны быть и таблички при необходимости, которые там, ну, понятно, и другого типа графики уже более современные. Вы это тоже, наверное, как-нибудь в перспективе делать будете?
**Ведущий:** Ну, смотрите, тут, по этой работе, как по этому направлению работа ведётся как раз-таки вместе с дашбордами и панелями и рабочими столами и так далее. То есть там новый компонент, на который как раз-таки всё это пересаживается, и доработка будет. Но пока каких-то там, ну, `drill down`-ов и так далее, это всё будем уже дальше делать. То есть сейчас пока приводим в порядок то, что есть. Там нарисовал дизайнер уже экранчики, как это настраивать более удобно и так далее. Там функционал немножко прибавил, но не это, пока без кардинальных этих... без кардинальных изменений.
**Участник 1:** Ещё вопрос. Я всё время, я люблю этот вопрос задавать. Э-э, аналог DMN будет или нет?
**Ведущий:** Да, вот сейчас как раз-таки пилится аналог... не аналог даже, а прямо DMN, но пока без DRD, но таблички появятся. То есть, вот как раз я говорил в самом начале про доработанный конструктор кода. Там будет э-э, редактор выражений переключаться там в вид, да, типа литерал задать, задать выражение, задать атрибут, э-э, или задать э-э DMN-таблицу. Вот, то есть будет прямо выбор, да, вы сможете из DMN-таблицы перейти в N-Tri, N-Tri дальше продолжить редактировать. Ну, то есть вот такие вот вещи.
**Участник 1:** Ну, понятно, потому что, смотрите, здесь же, вот, я ещё раз говорю, э-э, речь идёт о формах, прежде всего, потому что там, на самом деле, э-э, на формах, особенно на стартовых формах, где зачастую определяется э-э, течение процесса. Ну, вот, я могу сразу сказать, сейчас я уже... мы уже поняли, что для того, чтобы нормально шёл процесс приёма на работу, нам нужно знать, первое, вид приёма, да, там административно-хозяйственный, административно-управленческий, учебно-вспом... Ну, в общем, короче, вот, вот это, раз. Второе, нам нужно знать, руководитель, не руководитель. Там другая цепочка согласования.
**Ведущий:** Да.
**Участник 1:** Э-э, нам нужно знать, э-э, учащийся, не учащийся.
**Ведущий:** Угу.
**Участник 1:** Это тоже разные. Нам нужно знать, э-э, ну и так далее. То есть должен целый... целый набор параметров, в зависимости от которых потом и в процессе что-то будет по-другому, и форма будет другая. То есть то, что будет видеть человек, вот он заполняет параметры, у него начинают открываться части форм. В общем, поэтому такие...
**Ведущий:** Вот.
**Участник 1:** А держать всё это в голове — это ужас.
**Ведущий:** Да.
**Участник 1:** Поэтому, если будет вот это подспорье, оно ещё в четвёрке хотя бы появится с точки зрения табличек, это будет просто замечательно.
**Ведущий:** Будет, будет. Таблички будут, они, в принципе, везде, во всех точках применения выражений и так далее, они появятся.
**Участник 1:** И вы своим маркетологам скажите, всё-таки, о том, пусть они напишут, что, э-э, у вас там написано, что поддержка кейсов уже давно. Но вы бы тоже аббревиатуру поставили. CMMN, да, или как она там правильно, CMMN, по-моему, да?
**Ведущий:** Нет, CMMN пока ещё не поддержан, это всё-таки кейс-менеджмент и CMMN — немножко две разные вещи, поэтому...
**Участник 1:** А, понятно.
**Ведущий:** Вот.
**Участник 1:** Ну, просто, вот...
**Ведущий:** Потому что...
**Участник 1:** Ну, тут зависит от того, кто...
**Ведущий:** Многие говорят, что у них есть CMMN, а на самом деле у них даже кейсов не поддерживается.
**Ведущий:** В том-то и дело. CMMN вообще — это концепция, она немножко отдельная.
**Участник 1:** Да.
**Ведущий:** Она как бы...
**Участник 1:** Ну, по крайней мере, хоть как-то написать, что, ну, там, близко к этому.

**[08:59:751]**

*(Пауза)*

**Ведущий:** Всё, спасибо большое. Ждём от вас материалов. Вот. Надеюсь, что с активацией разберутся ваши ребята.
**Ведущий:** Да уже вроде бы там, да, на финале там уже, они докрутили, сейчас тестируют.
**Участник 1:** Угу. Потому что ещё ни онлайновая не работает, ни такая.
**Ведущий:** Да, и такая, и такая заработает, всё хорошо будет. Там просто по организации не совсем разобрались, да, какие ключи, какие генерить и так далее. Вот, сегодня разбирались.
**Участник 1:** Ясно, хорошо.
**Ведущий:** Вот, поэтому всё хорошо будет.
**Участник 1:** Угу.
**Ведущий:** Всё.
**Участник 1:** Спасибо.
**Ведущий:** Да, спасибо.
**Участник 2:** Спасибо, до свидания.
**Ведущий:** Всё, всем до свидания.

*(Запись заканчивается.)*

