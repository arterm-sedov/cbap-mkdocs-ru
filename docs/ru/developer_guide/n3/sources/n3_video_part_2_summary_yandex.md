# Развёрнутое резюме

- **Цель примера:** вывести неархивные записи, где текущий пользователь является создателем записи или руководителем создателя.
- **Префиксы и URI:** в начале задаются `@prefix` для сокращения длинных URI. Ключевые префиксы: `object:` (например, `object:findProperty`, `object:alias`), `user:`, `assert:` и др.
- **Триплеты и переменные:** всё выражается триплетами СПО. Переменные (`?item`, `?container`, `?user_current`) при неизвестности запускают поиск (энумерацию), при известности работают как фильтр.
- **Поиск идентификатора свойства:** `object:findProperty` получает на вход список из двух алиасов `(алиас_шаблона, алиас_атрибута)` и отдаёт уникальный ID свойства (`obs-*`). Это нужно из‑за неуниверсальности системных имён атрибутов между шаблонами.
- **Нахождение шаблона и записей:** `?container object:alias ?nit` — ищет контейнер (шаблон) по его алиасу. Далее `?item rdfs:member ?container` — находит все записи в шаблоне.
- **Фильтрация «не архив»:** отрицание `NOT { ?item v-s:is_disabled true }` исключает заархивированные записи.
- **Текущий пользователь:** `?user_current user:current ()` получает пользователя из контекста сессии.
- **Логика `assert:union`:** субъект — список формул; каждая формула — самостоятельная проверка. Условие истинно, если выполнена хотя бы одна формула. В примере: (1) `?item ?property_creator ?user_current` (пользователь — создатель); (2) через промежуточную переменную `?user` проверяется, что `?user_current` — `v-s:manager` создателя.
- **Механика выполнения:** каждый паттерн возвращает перечислитель (энумератор). Для эффективности наиболее селективные паттерны ставятся выше, чтобы уменьшить перебор. Формулы внутри `assert:union` независимы и вычисляются отдельно.
- **Практические замечания:**
  - аккуратно относитесь к множественным значениям, избегая декартовых произведений;
  - переносите инвариантные вызовы (например, `user:current`) выше по выражению;
  - следите за читабельностью: корректное форматирование формул и списков упрощает чтение и сопровождение.

Введение и домашнее задание
• Обсуждение домашнего задания по вычислимым свойствам.
• Упоминание о простом и сложном заданиях.
Объяснение префиксов
• Объяснение использования префиксов для сокращения записей.
• Пример использования префикса «обжиг» для доступа к свойствам из определённого пространства имён.
Структура предикатов
• Разбор структуры предикатов: сабъект, предикат, объект.
• Объяснение работы предиката «обжиг проперти».
Работа с атрибутами
• Поиск идентификатора атрибута в шаблоне записи.
• Передача параметров для функции, возвращающей идентификатор.
Оптимизация запросов
• Обсуждение оптимизации запросов и порядка их выполнения.
• Важность возврата наименьшего значения генератора.
Сбор контейнера
• Сбор контейнера с субъектами, удовлетворяющими определённому условию.
• Использование предиката «обжиг толяс» для поиска субъектов.
Контекст текущего объекта
• Обсуждение контекста текущего объекта при вычислении свойств.
• Различие между известным и неизвестным контекстом.
Входные и выходные данные
• Входные данные отсутствуют, только выходное — атом.
• При работе с вычисляемыми атрибутами всегда есть входное значение атом.
Поиск записей по шаблону
• Необходимо найти все записи в контейнере шаблона, которые не являются архивными.
• Сначала определяется контейнер шаблона, затем ищутся записи внутри него.
Фильтрация записей
• Проверяется, не содержится ли запись в архиве.
• Если запись не в архиве, она не отфильтровывается.
Использование текущего пользователя
• Вычисляется текущий пользователь для определения создателя записей.
• Цель — вывести активные записи, созданные текущим пользователем.
Работа с предикатами и union
• Предикаты используются для проверки условий.
• union объединяет результаты нескольких условий.
Анализ формул
• Каждая формула состоит из триплетов, которые проверяются на истинность.
• Проверяется, является ли текущий пользователь создателем записи.
Завершение анализа
• Вторая формула состоит из двух триплетов: «а этим известен» и «пройти креатор известен».
• Подчёркивается независимость каждой формулы друг от друга.
