## Полное руководство по языку запросов N3 в платформе Comindware

Язык запросов Notation 3 (N3) — это мощный инструмент для работы с данными в платформе Comindware. Он позволяет отойти от традиционных табличных представлений и начать «разговаривать» с информацией, раскрывая весь её потенциал. Это руководство проведет вас через ключевые концепции N3, от фундаментальной философии до разбора практических примеров.

### 1. Новый взгляд на данные: от таблиц к графам

Чтобы освоить N3, необходимо изменить привычный взгляд на данные. Вместо того чтобы представлять информацию в виде жестких таблиц со строками и столбцами, представьте ее как огромный, взаимосвязанный граф или паутину отношений.

В этой модели, лежащей в основе графовых баз данных, мир описывается через последовательность простых, связанных между собой фактов. Такой подход делает формулирование сложных реляционных запросов более интуитивным и мощным. Вы больше не ищете запись в таблице, а исследуете связи между сущностями.

### 2. Атомарный строительный блок: Триплет

Вся система N3 построена на одной простой и изящной структуре — **Триплете**. Это фундаментальная единица данных, атомарный строительный блок, из которого состоит вся информация в системе.

Структура триплета аналогична простому предложению и состоит из трех частей:
*   **Субъект:** То, о чем идет речь.
*   **Предикат:** Свойство, действие или отношение, связывающее субъект с объектом.
*   **Объект:** Значение, сущность или то, на что направлено действие.

Любой факт, от простого утверждения **«мама мыла раму»** до сложного системного отношения **«ЭтотПенал содержит синийКарандаш»**, может быть представлен в виде триплета. Эта универсальность делает триплет невероятно мощной концепцией.

### 3. Основы синтаксиса N3

Синтаксис N3 напрямую отражает структуру триплета. Запрос строится из последовательности утверждений, каждое из которых описывает одну связь:

`[Субъект] [Предикат] [Объект].`

*   **Переменные:** Чтобы задать вопрос и найти неизвестное значение, используются переменные, которые начинаются со знака вопроса (например, `?user` или `?value`).
*   **Точка в конце:** Каждое полное утверждение (триплет) в N3 обязательно заканчивается точкой, как предложение в обычном языке.

### 4. Как на самом деле работают запросы: роль Итератора

Понимание механизма работы движка запросов — ключ к написанию эффективных и быстрых запросов. Система не выполняет весь запрос одновременно, а обрабатывает его последовательно, строка за строкой.

Центральное понятие здесь — **Итератор**.
1.  **Создание итератора:** Первая строка запроса создает первоначальный список всех потенциальных совпадений. Этот список и есть итератор.
2.  **Последовательная фильтрация:** Каждая последующая строка запроса не выполняет новый поиск, а фильтрует уже существующий список в итераторе, отбрасывая элементы, которые не соответствуют новому условию.

Отсюда вытекает **золотое правило эффективности N3**: *начинайте запрос с самых конкретных и ограничивающих строк*. Чем меньше будет первоначальный итератор, тем быстрее будут обработаны последующие строки и тем быстрее выполнится весь запрос.

### 5. Анатомия реального запроса: практический пример

Рассмотрим практическую задачу: подсчитать количество уникальных товаров в заказе, игнорируя дубликаты.

#### Шаг 1: Сбор всех товаров
```n3
{
    ?order cwm:p.order.positions ?position.
    ?position cwm:p.orderPosition.product ?product.
}
```
*   Фигурные скобки `{}` объединяют операции в один блок.
*   Сначала запрос находит все строки (`?position`) текущего заказа (`?order`).
*   Затем для каждой строки он находит связанный с ней товар (`?product`).
*   **Результат:** создается большой итератор, содержащий список всех товаров из всех строк заказа, включая повторения.

#### Шаг 2: Фильтрация дубликатов
```n3
... assert:distinct ?uniqueProducts.
```
*   `assert:distinct` — это специальный предикат (встроенная функция), который принимает на вход весь список из предыдущего шага.
*   Он фильтрует этот список, удаляя все дубликаты.
*   **Результат:** создается новый, чистый итератор (`?uniqueProducts`), содержащий только уникальные товары.

#### Шаг 3: Подсчет уникальных элементов
```n3
... assert:count ?value.
```
*   `assert:count` — еще одна встроенная функция, которая берет отфильтрованный список уникальных товаров.
*   Она подсчитывает количество элементов в этом списке.
*   **Результат:** итоговое число помещается в выходную переменную `?value`. Проблема решена.

### Заключение

Освоив простую силу триплета и логику работы итератора, вы открываете совершенно новый способ взаимодействия с данными. Это больше не механический поиск записей, а полноценный диалог с вашей информацией. Единственный оставшийся вопрос: что вы собираетесь построить с помощью этих знаний?