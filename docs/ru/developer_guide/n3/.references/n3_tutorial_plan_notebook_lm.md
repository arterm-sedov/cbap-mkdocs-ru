Отличная идея! Я создам для вас обучающий курс по языку N3 в Comindware Platform, используя предложенный HR-сценарий.

---

# Курс N3: Основы и Применение в Comindware Platform

## Введение

Добро пожаловать на курс по языку **Notation3 (N3)** в **Comindware Business Application Platform**! Этот курс разработан, чтобы помочь вам освоить один из наиболее мощных инструментов для работы с данными на платформе.

**Comindware Platform** – это low-code-система класса BPMS, разработанная для быстрой цифровизации и автоматизации бизнес-процессов с использованием нотации BPMN 2.0. В основе платформы лежит **графовая СУБД {{ productNameElasticData }}**, основанная на модели **RDF (Resource Description Framework)**. Это позволяет системе представлять и обрабатывать данные в виде **триплетов** (Субъект – Предикат – Объект), что обеспечивает невероятную гибкость и производительность.

В рамках **Comindware Platform** существуют два основных типа синтаксиса запросов:
*   **Expression Language**: Это фирменный язык выражений Comindware, схожий с формулами Excel. Он прост в освоении и подходит для базовой настройки системы, являясь своего рода надстройкой для упрощения RDF N3.
*   **Язык выражений RDF N3 (также называемый «Тройки»)**: Этот язык сложнее для чтения и написания, но он **более функциональный и основополагающий**. Стандарт N3 определён международным консорциумом W3C. N3 позволяет получить **доступ ко всем созданным и системным атрибутам** (в отличие от Expression Language, который показывает только наиболее часто используемые) и предоставляет **расширенные возможности работы с данными**, включая математические функции, функции для работы со списками, преобразование типов данных и расчёт времени.

Использование N3 позволяет производить вычисления со значительно большей скоростью, эффективно используя все преимущества графовой базы данных, так как он обеспечивает **поатрибутивный доступ к данным и их связям**, устраняя необходимость загрузки данных потаблично, что характерно для реляционных баз данных и SQL.

### Сквозной сценарий: Подбор персонала по навыкам

В рамках этого курса мы будем работать над практической задачей из области управления персоналом. Наша цель – разработать автоматизированное решение, которое поможет HR-специалистам **находить сотрудников, чьи навыки точно соответствуют требованиям определённых проектов**.

**Бизнес-задача:** Предположим, у нас есть база данных проектов, для каждого из которых определён набор необходимых навыков. Также у нас есть база данных сотрудников с указанием их доступных навыков. Нам необходимо создать механизм, который позволит быстро определить, **кто из сотрудников обладает всеми необходимыми навыками для конкретного проекта**, при этом набор его навыков должен **точно совпадать** с требуемым набором навыков для проекта.

Мы будем использовать следующую упрощенную модель данных, вдохновленную примером из источников:
*   **Шаблон записи «Проекты» (projects)**: Содержит атрибут «Необходимые навыки» (required_skills), который является множественным и ссылается на справочник «Навыки».
*   **Шаблон записи «Сотрудники» (employees)**: Содержит атрибут «Навыки сотрудника» (available_skills), который также является множественным и ссылается на справочник «Навыки».
*   **Шаблон записи «Навыки» (skills)**: Простой справочник, содержащий названия навыков (например, "Астрономия", "Логистика", "Программирование").

В ходе курса мы шаг за шагом реализуем N3-запрос, который будет выполнять эту проверку.

### Цели обучения

По завершении курса вы научитесь:
*   Ориентироваться в уже написанных N3-выражениях.
*   Самостоятельно создавать N3-запросы средней сложности.
*   Понимать базовые принципы работы триплетов и интерпретатора N3.
*   Эффективно использовать входные и выходные параметры запросов (`?item` и `?value`).
*   Применять различные типы присвоения значений переменным.
*   Использовать системные атрибуты в запросах.
*   Выполнять вычисления с помощью встроенных предикатов.
*   Разбираться в работе итераторов и управлять потоком выполнения запросов.
*   Применять логические условия для фильтрации данных.
*   Объединять результаты запросов в одну переменную.

### Результаты обучения

После прохождения курса вы сможете:
*   Создавать более продвинутую бизнес-логику в Comindware Platform, недоступную через визуальные инструменты.
*   Получать доступ ко всем созданным и системным атрибутам платформы.
*   Использовать расширенные функции для работы с данными, списками и временем.
*   Применять N3-запросы для автоматизации сложных HR-сценариев, таких как точный подбор сотрудников по навыкам.
*   Оптимизировать свои запросы для повышения производительности системы.

### Содержание курса

Курс состоит из следующих уроков:
*   **Урок 1: Основы N3-запросов.** Введение в синтаксис N3, триплеты, переменные, входные и выходные параметры.
*   **Урок 2: Работа с атрибутами и библиотеками.** Использование пространств имён, `object:findProperty`, системные атрибуты и встроенные предикаты.
*   **Урок 3: Управление потоком выполнения и сложные запросы.** Итераторы, преобразование коллекций, логические операторы и реализация HR-сценария.

### Ключевые понятия и сущности Comindware Platform

Для успешного прохождения курса важно ознакомиться с базовыми терминами:

*   **N3 (Notation3)**: Человекочитаемый и компактный синтаксис для записи данных RDF (Resource Description Framework) и логических выражений.
*   **RDF (Resource Description Framework)**: Стандарт W3C для описания ресурсов в вебе, используемый как базовая модель данных для графовых баз данных.
*   **Триплет (Triplet)**: Фундаментальная единица данных в модели N3/RDF, представляющая собой единичный факт, состоящий из Субъекта, Предиката и Объекта.
    *   **Субъект (Subject)**: Ресурс или сущность, которая описывается.
    *   **Предикат (Predicate)**: Описывает отношение или свойство между субъектом и объектом.
    *   **Объект (Object)**: Значение или ресурс, связанный с субъектом через предикат.
*   **Графовая база данных (Graph Database)**: База данных, использующая узлы (nodes) и рёбра (edges) для представления и хранения данных, подчёркивая связи между сущностями.
*   **Expression Language (Формулы)**: Фирменный язык выражений Comindware, похожий на Excel, служащий надстройкой для упрощения N3.
*   **Переменная (?)**: Заполнитель в N3-запросах (обозначается префиксом `?`), который представляет неизвестные значения, которые запрос должен найти или вычислить.
*   **`?item`**: Зарезервированная переменная, обычно представляющая собой входной параметр запроса – ID текущего объекта или записи в контексте выполнения запроса.
*   **`?value`**: Зарезервированная переменная, в которую помещается результат запроса или вычисления; является выходным параметром. Тип данных `?value` должен совпадать с типом данных атрибута, куда записывается результат.
*   **Пространство имён (Prefix)**: Сокращённое обозначение для длинных URI, используемое в N3 для улучшения читаемости запросов.
*   **Встроенные предикаты (Built-in Predicates)**: Специальные предикаты (функции) N3, которые выполняют вычисления или операции в памяти, а не запрашивают базу данных (например, `math:sum`, `time:dayOfWeek`). Могут работать со списками значений.
*   **`object:findProperty`**: Встроенный предикат для получения ID атрибута по его псевдониму шаблона и псевдониму атрибута. Возвращает один ID и высоко оптимизирован.
*   **Итератор (Iterator)**: Механизм выполнения N3-запросов, который предоставляет последовательность значений, позволяя последующим строкам запроса обрабатываться для каждого значения в этой последовательности. Запросы выполняются последовательно сверху вниз, в итеративном порядке.

### Начало обучения

**Предварительные требования:** Данное руководство рассчитано на пользователей с **хорошим пониманием Comindware Business Application Platform и её настроек**. Знание основ работы с шаблонами записей, атрибутами и формами будет большим преимуществом.

**Расчётная продолжительность курса:** 8 часов (включая чтение и выполнение заданий).

---

## Урок 1: Основы N3-запросов

### Введение

В этом уроке мы начнём наше погружение в мир N3, изучив его фундаментальные строительные блоки. Мы разберёмся, что такое триплеты, как они формируют основу для хранения данных в графовой базе Comindware, и каковы основные правила написания N3-запросов. Вы также познакомитесь с ключевыми переменными `?item` и `?value`, которые являются вашими "входом" и "выходом" в мир N3-запросов.

### Темы, навыки и задания урока

*   **Темы:** Структура триплетов (Субъект – Предикат – Объект), основные правила синтаксиса N3, входные и выходные параметры запроса (`?item` и `?value`).
*   **Навыки:** Понимание базовой структуры N3-запроса, написание простых запросов, использование `?item` и `?value`.
*   **Задания:** Создание простого N3-запроса для извлечения значения.

### Определения

*   **Триплет (Triplet)**: Основной синтаксический элемент N3, состоящий из трёх связанных сущностей: Субъект — Предикат — Объект. Триплет можно соотнести с простым предложением вида: *Подлежащее — Сказуемое — Дополнение*.
*   **Субъект (Subject)**: Первая часть триплета, описывающая ресурс или сущность. В контексте Comindware, это может быть запись в шаблоне записи.
*   **Предикат (Predicate)**: Вторая часть триплета, описывающая свойство или отношение между субъектом и объектом. В Comindware, это атрибут записи.
*   **Объект (Object)**: Третья часть триплета, представляющая значение свойства или связанный ресурс. В Comindware, это значение атрибута.
*   **`?item`**: Входной параметр запроса, значение которого определяется контекстом выполнения (например, ID текущей записи, для которой вычисляется атрибут).
*   **`?value`**: Выходной параметр запроса, в который помещается результат. Тип данных в `?value` должен совпадать с типом данных атрибута, куда записывается результат.

### Содержание урока

База данных Comindware использует графовую модель, основанную на RDF, где все данные хранятся в виде **набора триплетов**. Например, утверждение "Книга написана Пушкиным" в RDF-терминологии будет: Субъект — Книга, Предикат — написана, Объект — Пушкин. По тому же принципу описывается структура данных в шаблонах записей Comindware: запись – это субъект, атрибут – предикат, а значение атрибута – это объект.

**Тело запроса** N3 состоит из триплетов вида Субъект – Предикат – Объект.

**Основные правила синтаксиса N3**:
*   Каждый триплет начинается с новой строки.
*   **Переменные** объявляются с префиксом **`?`** (например, `?variable`).
*   Весь запрос заключается в фигурные скобки (**`{}`**).
*   В конце каждого триплета ставится точка (**`.`**).
*   **Интерпретатор N3 учитывает регистр символов** (`?variable` и `?Variable` — разные переменные).

**Пример простого N3-запроса:**
Давайте представим, что у нас есть запись о проекте, и нам нужно получить его название. Допустим, у проекта есть системный атрибут `cmw:name` (системные атрибуты обсудим в следующем уроке, пока просто примем это).

```n3
{
    ?item cmw:name ?projectName.
    ?projectName -> ?value.
}
```
**Пояснение:**
*   **`{ ... }`**: Весь запрос заключён в фигурные скобки.
*   **`?item cmw:name ?projectName.`**: Это наш первый триплет.
    *   `?item`: Входной параметр, который в контексте вычисляемого атрибута будет представлять собой текущую запись о проекте.
    *   `cmw:name`: Предикат, представляющий системный атрибут "имя".
    *   `?projectName`: Переменная, в которую будет присвоено значение имени проекта.
    *   `.`: Точка в конце триплета.
*   **`?projectName -> ?value.`**: Второй триплет.
    *   `?projectName`: Значение переменной `?projectName` (имя проекта) становится субъектом.
    *   `->`: Оператор присвоения значения.
    *   `?value`: Выходной параметр запроса, в который будет помещён результат – имя проекта.

Этот запрос будет выполнен для каждой записи, для которой запускается вычисление, и вернёт название этой записи в `?value`.

### Тестирование

**Задание 1.1: Получение ID текущей записи.**
В Comindware Platform вы часто будете работать с ID текущего объекта. Напишите N3-запрос, который возвращает ID текущей записи в выходной параметр `?value`.

*Подсказка:* Вам не нужно указывать предикат или объект, если вы просто хотите получить значение `?item` в `?value`.

```n3
{
    ?item -> ?value.
}
```

**Задание 1.2: Объявление и использование простой переменной.**
Создайте N3-запрос, который присваивает строковое значение `"Hello N3!"` переменной `?message` и затем помещает её в `?value`.

```n3
{
    "Hello N3!" -> ?message.
    ?message -> ?value.
}
```

### Итоги урока

В этом уроке мы заложили фундамент для работы с N3: вы узнали о концепции триплетов, базовом синтаксисе N3-запросов и научились использовать ключевые параметры `?item` и `?value`. Понимание этих основ крайне важно для построения более сложных и функциональных запросов.

---

## Урок 2: Работа с атрибутами и библиотеками

### Введение

Наш первый урок познакомил вас с базовой структурой N3-запросов. Теперь мы углубимся в то, как N3 взаимодействует с данными в Comindware Platform, включая доступ к прикладным и системным атрибутам. Вы узнаете о пространствах имён, мощном предикате `object:findProperty` и различных способах присвоения значений переменным. Эти знания позволят вам извлекать конкретные данные, необходимые для нашего HR-сценария.

### Темы, навыки и задания урока

*   **Темы:** Библиотеки пространств имён (префиксы), использование `object:findProperty` для получения ID атрибутов, системные атрибуты, различные типы присвоения значений в переменные, встроенные предикаты для работы с данными (строками, датами).
*   **Навыки:** Эффективный поиск атрибутов по системным именам, присвоение значений переменным, использование базовых встроенных функций.
*   **Задания:** Получение ID атрибута, извлечение значения конкретного атрибута записи, использование встроенных функций для манипуляций со строками.

### Определения

*   **Библиотеки пространств имён (Namespaces/Префиксы)**: Подключаемые модули (области), содержащие знания об объектах, функциях и правилах. Они позволяют обращаться к системным и прикладным атрибутам и их значениям, а также получать доступ к функциям (например, по работе с датами, списками, числами). Объявляются с помощью `@prefix`.
    *   Пример: `@prefix object: <http://comindware.com/ontology/object#>`.
*   **`object:findProperty`**: Встроенный предикат, используемый для получения ID атрибута по его псевдониму шаблона и псевдониму атрибута (например, `("TemplateAlias" "AttributeAlias") object:findProperty ?attributeId`). Он всегда возвращает один ID и высоко оптимизирован.
*   **Системные атрибуты**: Помимо прикладных (созданных вручную), у каждого объекта в платформе есть системные атрибуты, которые не всегда видны в интерфейсе, но существуют и автоматически заполняются системой. Доступ к ним осуществляется через соответствующие библиотеки пространств имён.
*   **Встроенные предикаты (Built-in Predicates)**: Сложные предикаты, содержащие функции для работы со строками, датами, математические функции и т.д. Они выполняют вычисления в памяти, а не запрашивают базу данных.

### Содержание урока

Чтобы взаимодействовать с атрибутами записей, нам нужно знать их уникальные идентификаторы (ID). В Comindware Platform это делается с помощью предиката `object:findProperty` и использования пространств имён.

**Объявление пространств имён:**
Перед использованием функций или системных атрибутов, принадлежащих определённому пространству имён, его необходимо объявить в начале запроса с помощью директивы `@prefix`.
Например, для `object:findProperty` используется пространство имён `http://comindware.com/ontology/object#`, которое часто сокращается как `object:`.

```n3
@prefix object: <http://comindware.com/ontology/object#>.
```

**Получение ID атрибута с помощью `object:findProperty`:**
Синтаксис `object:findProperty` принимает на вход два строковых литерала: системное имя шаблона и системное имя атрибута внутри этого шаблона. Результат (ID атрибута) присваивается переменной.

Пример: Получение ID атрибута `required_skills` из шаблона `projects`.
```n3
@prefix object: <http://comindware.com/ontology/object#>.
{
    ("projects" "required_skills") object:findProperty ?requiredSkillsAttrId.
    ?requiredSkillsAttrId -> ?value.
}
```
Здесь `?requiredSkillsAttrId` будет содержать уникальный ID атрибута "Необходимые навыки" в системе.

**Присвоение значений переменным (поиск данных)**:
Интерпретатор N3 может присваивать значения переменным, если одна из сущностей триплета неизвестна (обозначена `?`).
*   **Поиск объекта по субъекту и предикату**: Наиболее частый случай, когда мы знаем запись (`?item`) и атрибут (`?attributeId`), и хотим получить его значение.
    ```n3
    ?item ?attributeId ?attributeValue.
    ```
*   **Поиск субъекта по предикату и объекту**: Когда мы знаем значение (`?attributeValue`) и атрибут (`?attributeId`), и хотим найти запись, которой это значение принадлежит.
    ```n3
    ?subject ?attributeId ?attributeValue.
    ```
*   **Проверка наличия факта (Match)**: Если все три части известны, происходит проверка на полное совпадение. Запрос возвращает `true` или `false`.
    ```n3
    ?item ?attributeId "SomeValue".
    ```
    Если такой триплет существует, запрос считается успешным.

**Встроенные предикаты для работы со строками (примеры):**
Comindware N3 предлагает множество встроенных функций. Для работы со строками часто используются функции из пространства имён `cmwstring:`.

*   `cmwstring:length`: Возвращает количество символов в строке.
    ```n3
    @prefix cmwstring: <http://comindware.com/logics/string#>.
    {
        "Hello World" cmwstring:length ?len.
        ?len -> ?value.
    }
    ```
    Результат: 11
*   `cmwstring:replace`: Заменяет все вхождения заданной подстроки.
    ```n3
    @prefix cmwstring: <http://comindware.com/logics/string#>.
    {
        ("Hello World" "World" "N3") cmwstring:replace ?newString.
        ?newString -> ?value.
    }
    ```
    Результат: "Hello N3"

### HR-сценарий: Подготовка к поиску навыков

Для нашего HR-сценария нам понадобятся ID атрибутов "Необходимые навыки" (required_skills) из шаблона "Проекты" и "Навыки сотрудника" (available_skills) из шаблона "Сотрудники".

```n3
@prefix object: <http://comindware.com/ontology/object#>.
{
    ("projects" "required_skills") object:findProperty ?requiredSkillsAttrId.
    ("employees" "available_skills") object:findProperty ?availableSkillsAttrId.
    
    # Теперь мы можем использовать ?requiredSkillsAttrId и ?availableSkillsAttrId
    # для доступа к значениям этих атрибутов в других триплетах.
    
    # Пример: получение необходимых навыков для текущего проекта (?item)
    ?item ?requiredSkillsAttrId ?skillRef. # ?skillRef будет ссылкой на запись из справочника "Навыки"
    
    ?skillRef cmw:name ?skillName. # Предполагаем, что у справочника "Навыки" есть атрибут cmw:name
    ?skillName -> ?value.
}
```
*Обратите внимание: `cmw:name` – это системный атрибут, который обычно содержит отображаемое имя объекта или записи. Для его использования также потребуется объявить соответствующее пространство имён, если оно не было объявлено.*

### Тестирование

**Задание 2.1: Получение ID атрибута и его значения.**
Представьте, что у вас есть шаблон записи "Сотрудники" с атрибутом "Имя" (системное имя `cmw:name`). Напишите N3-запрос, который возвращает имя текущего сотрудника (`?item`).

```n3
@prefix object: <http://comindware.com/ontology/object#>.
@prefix cmw: <http://comindware.com/ontology/object#>. # или <http://comindware.com/logics#> в зависимости от контекста name

{
    ("employees" "Name") object:findProperty ?nameAttrId. # Предполагаем, что Name - это ваш прикладной атрибут
    # Если имя - это системный атрибут, используйте cmw:name напрямую: ?item cmw:name ?employeeName.
    
    ?item ?nameAttrId ?employeeName.
    ?employeeName -> ?value.
}
```

**Задание 2.2: Использование строковой функции.**
Напишите N3-запрос, который берёт любую строку (например, "notation3") и преобразует её в верхний регистр, возвращая результат в `?value`.

```n3
@prefix cmwentity: <http://comindware.com/ontology/entity#>.
{
    "notation3" cmwentity:toUpper ?upperCaseString.
    ?upperCaseString -> ?value.
}
```

### Итоги урока

В этом уроке вы узнали, как работать с пространствами имён и использовать `object:findProperty` для получения ID атрибутов, что является ключом к извлечению данных из Comindware Platform. Вы также ознакомились с различными видами присвоения переменных и начали использовать встроенные функции N3, что значительно расширяет ваши возможности по обработке данных. Эти навыки критически важны для реализации нашего HR-сценария.

---

## Урок 3: Управление потоком выполнения и сложные запросы

### Введение

Теперь, когда вы освоили основы N3 и работу с атрибутами, пришло время разобраться с тем, как N3 обрабатывает коллекции данных и управляет сложной логикой. В этом уроке мы изучим концепцию итераторов, мощные операторы `from {} select`, `assert:union`, `once`, `or`, а также условный оператор `if {} then {} else {}`. Все это позволит нам реализовать наш сквозной HR-сценарий по поиску сотрудников с необходимыми навыками.

### Темы, навыки и задания урока

*   **Темы:** Работа итераторов N3, преобразование итераторов в списки (`from {} select`), объединение результатов (`assert:union`), получение первого результата (`once`), логический оператор `or`, условные операторы (`if {} then {} else {}`), сортировка списков (`assert:sort`), объединение списков в строку (`cmwstring:join`).
*   **Навыки:** Управление сложными запросами, обработка коллекций данных, реализация условной логики, решение HR-задачи по подбору персонала по навыкам.
*   **Задания:** Реализация основного запроса для HR-сценария.

### Определения

*   **Итератор (Iterator)**: Механизм в N3, который при выполнении запроса может возвращать последовательность значений. Запрос выполняется последовательно сверху вниз по каждому триплету, и если строка генерирует несколько результатов, последующие строки перевыполняются для каждого из этих результатов.
*   **`from {} select ?v -> ?VList`**: Конструкция для получения типа "Список" (List). Она собирает значения из итератора в массив, который затем обрабатывается как единое целое, а не как последовательность отдельных элементов.
*   **`assert:union true`**: Оператор для объединения результатов нескольких итераторов в один. При использовании `true` как объекта, это аналогично SQL-операции "UNION ALL", включая дубликаты.
*   **`assert:distinct`**: Используется для получения уникальных значений после объединения итераторов.
*   **`once {}`**: Оператор, который выполняет запрос и возвращает только первый успешный результат, останавливая дальнейшую итерацию после нахождения совпадения. Полезно для оптимизации.
*   **`or {} or {}`**: Логический оператор "ИЛИ". Выполняет выражения последовательно, переключаясь на следующее, если предыдущее не вернуло результат, и выходит после первого успешного выполнения.
*   **`if {} then {} else {}`**: Условный оператор. Если блок `if` не выполнился и нет блока `else`, запрос прерывается, и результат будет `null`.
*   **`assert:sort`**: Используется для сортировки списков. Например, `(?list sort:stringComparer) assert:sort ?sortedList.`.
*   **`cmwstring:join`**: Объединяет строки (или элементы списка) с использованием заданного разделителя.

### Содержание урока

N3-запросы выполняются **последовательно сверху вниз по каждому триплету, в итеративном порядке**. Это означает, что если в одной строке запроса переменная получает несколько значений (создаётся итератор), то все последующие строки запроса будут выполнены для каждого из этих значений. **Чем меньше значений итераторы сформируют на первых строчках, тем легче будет выполнять весь скрипт и тем быстрее он будет выполняться**.

**Преобразование итератора в список (`from {} select`)**:
Для работы с коллекциями значений как с единым целым, например для сортировки или сравнения всего набора, используется конструкция `from {} select`.
Пример:
```n3
@prefix object: <http://comindware.com/ontology/object#>.
{
    # Получаем все значения атрибута "Название" для всех записей типа "Книга"
    ?book a object:Book.
    ?book object:name ?bookName.

    # Собираем все названия книг в список ?bookNameList
    from {
        ?book a object:Book.
        ?book object:name ?bookName.
    } select ?bookName -> ?bookNameList.

    ?bookNameList -> ?value.
}
```

**Объединение итераторов (`assert:union`)**:
Если вам нужно объединить результаты из нескольких источников или условий, используйте `assert:union`.
Пример: Получение всех возможных исполнителей задачи, включая фактически назначенных и потенциальных.
```n3
@prefix cmw: <http://comindware.com/logics#>.
@prefix task: <http://comindware.com/ontology/task#>.
{
    ?tasks a cmw:UserTask. # Получаем все задачи на исполнение
    (
        {?tasks cmw:possibleAssignee ?accounts.} # Получаем возможных исполнителей
        {?tasks cmw:assignee ?accounts.}        # Получаем назначенных исполнителей
    ) assert:union true. # Объединяем результаты
    
    ?accounts -> ?value. # Выводим список всех аккаунтов
}
```
`assert:union true` включает дубликаты. Чтобы получить только уникальные значения, используйте `assert:distinct` после объединения.

**Условные операторы (`if {} then {} else {}`)**:
Для выполнения кода в зависимости от условия. Если `if` не выполняется и `else` отсутствует, запрос прерывается.
Пример: Проверка просроченных задач.

**Реализация HR-сценария: Точное соответствие навыков**

Теперь применим изученные концепции для нашего HR-сценария: "найти проекты, для которых все необходимые навыки *точно совпадают* с навыками, которыми обладает **конкретный сотрудник**."

Для этого мы используем подход, аналогичный решению Задания 4 из источников: собрать списки значений, отсортировать их, объединить в строку и затем сравнить эти строки.

**Предположим, у нас есть:**
*   **`?item`**: текущая запись о проекте (или сотруднике, в зависимости от контекста).
*   Системное имя шаблона "Проекты": `projects`
*   Системное имя атрибута "Необходимые навыки" в "Проектах": `required_skills`
*   Системное имя шаблона "Сотрудники": `employees`
*   Системное имя атрибута "Навыки сотрудника" в "Сотрудниках": `available_skills`

**N3-запрос для проверки соответствия навыков:**

```n3
@prefix object: <http://comindware.com/ontology/object#>.
@prefix assert: <http://comindware.com/logics/assert#>.
@prefix cmwstring: <http://comindware.com/logics/string#>.
@prefix sort: <http://comindware.com/logics/sort#>.
@prefix cmw: <http://comindware.com/logics#>. # Для cmw:name или других системных атрибутов

{
    # 1. Получаем ID атрибутов для "Необходимых навыков" и "Навыков сотрудника"
    ("projects" "required_skills") object:findProperty ?requiredSkillsAttrId.
    ("employees" "available_skills") object:findProperty ?availableSkillsAttrId.
    ("skills" "name") object:findProperty ?skillNameAttrId. # ID атрибута "Название" для справочника "Навыки"

    # 2. Получаем необходимые навыки для ТЕКУЩЕГО ПРОЕКТА (?item)
    # Собираем ссылки на навыки в список
    from {
        ?item ?requiredSkillsAttrId ?requiredSkillRef. # ?item - это наш проект
        ?requiredSkillRef ?skillNameAttrId ?requiredSkillName. # Получаем название навыка
    } select ?requiredSkillName -> ?projectRequiredSkillsList.

    # 3. Сортируем список необходимых навыков проекта и объединяем в строку для сравнения
    (?projectRequiredSkillsList sort:stringComparer) assert:sort ?sortedProjectRequiredSkillsList.
    ("" ?sortedProjectRequiredSkillsList) cmwstring:join ?projectRequiredSkillsStr.

    # 4. Итерируем по всем сотрудникам, чтобы найти подходящих
    ?employee a object:Employee. # Предполагаем, что object:Employee - это класс для шаблона "Сотрудники"

    # 5. Для каждого сотрудника получаем его доступные навыки
    from {
        ?employee ?availableSkillsAttrId ?availableSkillRef.
        ?availableSkillRef ?skillNameAttrId ?availableSkillName.
    } select ?availableSkillName -> ?employeeAvailableSkillsList.

    # 6. Сортируем список доступных навыков сотрудника и объединяем в строку
    (?employeeAvailableSkillsList sort:stringComparer) assert:sort ?sortedEmployeeAvailableSkillsList.
    ("" ?sortedEmployeeAvailableSkillsList) cmwstring:join ?employeeAvailableSkillsStr.

    # 7. Сравниваем отсортированные строки навыков
    # Если строка необходимых навыков проекта ТОЧНО совпадает со строкой навыков сотрудника,
    # значит, сотрудник идеально подходит для проекта по навыкам.
    if (?projectRequiredSkillsStr == ?employeeAvailableSkillsStr) then {
        ?employee -> ?value. # Добавляем этого сотрудника в результат
    }.
    # Если это вычисляемый атрибут в шаблоне "Проект", ?value будет списком подходящих сотрудников.
    # Если это запрос в другом контексте, ?value будет содержать список ID сотрудников.
}
```

**Пояснения к HR-запросу:**
*   Первым делом мы объявляем все необходимые пространства имён для работы с объектами, ассертами, строками и сортировкой.
*   Далее мы находим ID всех трёх ключевых атрибутов: необходимых навыков проекта, доступных навыков сотрудника и названия самих навыков из справочника.
*   С помощью блока `from {} select` мы извлекаем все необходимые навыки для текущего проекта (`?item`), преобразуем их в список имен навыков (`?projectRequiredSkillsList`).
*   Этот список сортируется (`assert:sort`) и объединяется в одну строку (`cmwstring:join`). Например, навыки "Java", "SQL", "Python" превратятся в строку "JavaPythonSQL" (если разделитель пуст, как в примере из источника). Важно, чтобы сортировка была одинаковой для обоих списков, чтобы их строковые представления можно было корректно сравнить.
*   Мы начинаем итерировать по всем записям шаблона "Сотрудники" (`?employee a object:Employee.`).
*   Для каждого сотрудника мы аналогичным образом получаем его доступные навыки, сортируем их и объединяем в строку.
*   Наконец, с помощью `if {} then {}` мы сравниваем две полученные строки (строку необходимых навыков проекта и строку доступных навыков сотрудника). Если они идентичны, это означает, что набор навыков сотрудника точно совпадает с требуемым для проекта. В этом случае ID сотрудника (`?employee`) добавляется в выходной параметр `?value`.

Этот запрос вернёт список сотрудников, которые имеют **точно такой же набор навыков**, как и требуемый для проекта.

### Тестирование

**Задание 3.1: Реализация HR-сценария.**
Используя предложенный N3-запрос для HR-сценария, настройте его в качестве вычисляемого атрибута в шаблоне "Проекты" (например, атрибут "Подходящие сотрудники").
*   Создайте шаблоны "Проекты", "Сотрудники", "Навыки".
*   Наполните справочник "Навыки" несколькими навыками (например, "Java", "SQL", "Python", "UX/UI").
*   Создайте несколько записей проектов с разными наборами "Необходимых навыков".
*   Создайте несколько записей сотрудников с разными наборами "Навыков сотрудника".
*   Проверьте, как вычисляемый атрибут "Подходящие сотрудники" отображает результаты для каждого проекта.

**Задание 3.2: Использование `assert:union` и `assert:distinct`.**
Представьте, что у вас есть два списка ID задач: `?urgentTasks` и `?overdueTasks`. Напишите N3-запрос, который объединяет эти два списка и возвращает только **уникальные** ID задач в `?value`.

```n3
@prefix assert: <http://comindware.com/logics/assert#>.
{
    # Предположим, у нас есть два итератора, возвращающие ID задач
    { "task1" -> ?urgentTask. "task2" -> ?urgentTask. } ?urgentTask. # Пример итератора для срочных задач
    { "task2" -> ?overdueTask. "task3" -> ?overdueTask. } ?overdueTask. # Пример итератора для просроченных задач

    (
        { ?urgentTask -> ?taskId. }
        { ?overdueTask -> ?taskId. }
    ) assert:union true.

    ?taskId assert:distinct ?uniqueTaskId.
    ?uniqueTaskId -> ?value.
}
```

### Итоги урока

В этом уроке вы овладели сложными аспектами N3-запросов: управлением итераторами, преобразованием данных в списки, использованием мощных логических операторов и условных конструкций. Вы успешно применили эти знания для решения практической HR-задачи по сопоставлению навыков, что является отличным показателем вашего прогресса в освоении N3.

---

## Завершение курса

### Чему вы научились

Поздравляем с успешным завершением курса по N3 в Comindware Platform! Вы проделали большую работу и теперь обладаете следующими ключевыми навыками и знаниями:
*   Вы понимаете **фундаментальные принципы N3**, его роль в графовой базе данных Comindware и отличие от Expression Language.
*   Вы умеете работать с **триплетами** (Субъект-Предикат-Объект) и понимаете, как они представляют данные.
*   Вы знакомы с **основными правилами синтаксиса N3** и можете писать базовые запросы.
*   Вы освоили использование **входных (`?item`) и выходных (`?value`) параметров** запросов.
*   Вы научились использовать **пространства имён** и ключевой предикат **`object:findProperty`** для доступа к атрибутам по их системным именам.
*   Вы можете применять **различные типы присвоения значений** переменным и использовать **системные атрибуты**.
*   Вы разобрались в работе **итераторов** и умеете управлять ими для обработки коллекций данных.
*   Вы освоили **сложные конструкции запросов**, такие как `from {} select` для создания списков, `assert:union` и `assert:distinct` для объединения и фильтрации, а также логические операторы `once`, `or` и условный `if {} then {} else {}`.
*   Вы успешно реализовали **сквозной HR-сценарий по подбору персонала по навыкам**, показав практическое применение N3 для решения реальных бизнес-задач.

Эти навыки позволят вам создавать более гибкие и мощные бизнес-приложения на Comindware Platform!

### Что дальше

Ваше путешествие в мир N3 только начинается. Полученные знания являются отличной основой для дальнейшего углубления. Вы можете продолжать экспериментировать с N3, исследовать другие языки выражений платформы и более сложные возможности.

### Рекомендуемые ресурсы для самостоятельного изучения

*   **Официальная база знаний Comindware:**
    *   **Руководство по языку N3:** https://kb.comindware.ru/article.php?id=4852. Это основной справочник по синтаксису и функциям N3.
    *   **Примеры выражений на языке N3:** Раздел с множеством практических примеров N3-запросов для различных сценариев https://kb.comindware.ru/category.php?id=879.
    *   **Руководство по языку формул:** https://kb.comindware.ru/article.php?id=4999. Для задач, где Expression Language более подходит.
    *   **Руководство по скриптам на C#:** https://kb.comindware.ru/article.php?id=4864. Для ещё более сложных сценариев и интеграций.
    *   **Общие сведения об API Comindware Platform:** https://kb.comindware.ru/article.php?id=4860. Позволит понять, как платформа взаимодействует с внешними системами.
    *   **Директории файлов экземпляра ПО:** https://kb.comindware.ru/article.php?id=4620. Полезно для системных администраторов.
    *   **Настройки резервного копирования:** https://kb.comindware.ru/article.php?id=4642.
*   **Внешние ресурсы:**
    *   **W3C Resource Description Framework (RDF) и Notation3 (N3):** Официальные спецификации для глубокого понимания стандартов.
    *   **Diátaxis Framework:** Принципы структурирования технической документации. Поможет лучше понимать, почему документация построена определённым образом.
    *   **Онлайн-курсы по RDF/Semantic Web:** Многие платформы предлагают курсы по семантическим технологиям.

### Темы для дальнейшего изучения возможностей платформы

*   **Оптимизация N3-запросов**: Более глубокое изучение того, как оптимизировать запросы для максимальной производительности, включая использование `once` и раннюю фильтрацию.
*   **Работа с DMN-таблицами**: Изучение Decision Model and Notation (DMN) для упрощения сложной условной логики, особенно в формах.
*   **Интеграции с внешними системами**: Использование N3 в сценариях для обмена данными через REST API, OData, Kafka и другие протоколы.
*   **Расширенные встроенные функции**: Подробное изучение всех встроенных предикатов для работы с датами, числами, списками и другими типами данных.
*   **Написание C#-скриптов**: Изучение C# для реализации бизнес-логики, которая требует доступа к .NET-библиотекам или сложной работы с API.
*   **Разработка собственных адаптеров**: Создание кастомных адаптеров для интеграции с уникальными внешними системами.

### Примеры и идеи для самостоятельных экспериментов

1.  **Усовершенствование HR-сценария:**
    *   Измените запрос так, чтобы он находил сотрудников, которые обладают **хотя бы одним** из необходимых навыков (логика "ИЛИ").
    *   Измените запрос так, чтобы он находил сотрудников, которые обладают **всеми необходимыми навыками**, но при этом могут иметь и **дополнительные** (логика "является надмножеством"). Это будет сложнее и потребует более продвинутых техник сравнения списков.
    *   Добавьте в запрос условие по дополнительному атрибуту сотрудника, например, "найти всех подходящих сотрудников из определённого отдела".

2.  **Агрегация данных:**
    *   Напишите запрос, который подсчитывает общее количество записей определённого типа (например, количество проектов) с использованием `assert:count`.
    *   Напишите запрос, который суммирует числовые значения из коллекции (например, общую стоимость затрат по проекту) с использованием `math:sum` и `from {} select`.

3.  **Работа с датами:**
    *   Напишите запрос, который определяет, является ли дата создания записи сегодняшним днём, используя `cmwtime:isToday`.
    *   Вычислите количество рабочих дней или часов между двумя датами, используя `cmwtime:workdaysDuration` или `cmwtime:workhoursDuration`.

Удачи в ваших дальнейших исследованиях Comindware Platform и языка N3!

---

## Тест по курсу N3

Выберите один или несколько правильных ответов.

1.  Что является основной целью языка N3 в Comindware Platform?
    а) Создание пользовательского интерфейса путем перетаскивания элементов.
    б) Создание запросов средней сложности и доступ ко всем атрибутам графовой базы данных.
    в) Выполнение только простых математических операций.
    г) Упрощение синтаксиса Excel-подобных формул.

2.  Какова основная синтаксическая единица N3/RDF модели?
    а) Нода (Node)
    б) Ребро (Edge)
    в) Триплет (Triplet)
    г) Граф (Graph)

3.  Что из перечисленного является правилом синтаксиса N3?
    а) Все переменные должны начинаться с символа `$`.
    б) Весь запрос заключается в квадратные скобки `[]`.
    в) Интерпретатор N3 не учитывает регистр символов.
    г) Каждый триплет заканчивается точкой `.`.

4.  Какая из переменных используется в N3-запросах для представления входного параметра (например, ID текущей записи)?
    а) `?value`
    б) `?item`
    в) `?this`
    г) `?input`

5.  Какой встроенный предикат N3 используется для получения уникального ID атрибута по системным именам шаблона и атрибута?
    а) `assert:find`
    б) `cmw:getAttributeId`
    в) `object:findProperty`
    г) `logic:getProperty`

6.  Что делает оператор `from {} select ?v -> ?VList`?
    а) Фильтрует список по заданному условию.
    б) Сортирует элементы списка в алфавитном порядке.
    в) Собирает значения из итератора в единый список (массив).
    г) Выполняет сложение числовых значений в списке.

7.  В N3-запросе, если блок `if` не выполнился, и отсутствует блок `else`, что произойдёт с выполнением запроса?
    а) Запрос продолжит выполнение, игнорируя условие `if`.
    б) Запрос выведет ошибку.
    в) Запрос будет прерван, и результат будет `null`.
    г) Запрос автоматически выполнит `then` блок.

8.  Какой оператор N3 следует использовать для объединения результатов нескольких итераторов таким образом, чтобы включить все дубликаты (аналогично SQL `UNION ALL`)?
    а) `assert:distinct`
    б) `assert:union false`
    в) `assert:union true`
    г) `or {} or {}`

9.  Что означает последовательный и итеративный порядок выполнения N3-запросов?
    а) Запрос выполняется только один раз, независимо от количества результатов.
    б) Запрос выполняет все триплеты одновременно.
    в) Запрос выполняется строка за строкой, и если строка генерирует несколько результатов (итератор), последующие строки перевыполняются для каждого из этих результатов.
    г) Запрос требует ручного подтверждения каждого шага.

10. В HR-сценарии "Подбор персонала по навыкам", какой подход был использован для сравнения наборов навыков проекта и сотрудника?
    а) Прямое сравнение ссылок на навыки без преобразования.
    б) Подсчет количества навыков в каждом наборе и их сравнение.
    в) Сбор навыков в списки, их сортировка, объединение в строки и сравнение полученных строк.
    г) Использование оператора `assert:containsAll`.

---

## Ответы к тесту

1.  **б)** Создание запросов средней сложности и доступ ко всем атрибутам графовой базы данных.
2.  **в)** Триплет (Triplet).
3.  **г)** Каждый триплет заканчивается точкой `.`.
4.  **б)** `?item`.
5.  **в)** `object:findProperty`.
6.  **в)** Собирает значения из итератора в единый список (массив).
7.  **в)** Запрос будет прерван, и результат будет `null`.
8.  **в)** `assert:union true`.
9.  **в)** Запрос выполняется строка за строкой, и если строка генерирует несколько результатов (итератор), последующие строки перевыполняются для каждого из этих результатов.
10. **в)** Сбор навыков в списки, их сортировка, объединение в строки и сравнение полученных строк.