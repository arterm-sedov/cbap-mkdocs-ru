Ниже представлен подробный анализ и краткое изложение информации из документа "Уроки по языку N3 (Андрей Писковацкий, Георгий Польян).pdf".

### Введение в курс

Данный курс призван научить пользователей **ориентироваться в написанных выражениях** и **самостоятельно создавать запросы средней сложности на языке N3**. Курс охватывает базовые принципы работы **триплетов**, **интерпретатора**, а также предоставляет реальные примеры использования. В конце каждого урока предусмотрены задания для самостоятельной работы. Отмечено, что некоторые понятия в курсе намеренно упрощены, но это не искажает общего представления о RDF N3. Руководство рассчитано на пользователей с **хорошим пониманием Comindware Business Application Platform и ее настроек**.

В рамках Comindware Business Application Platform существуют **два типа синтаксиса запросов**:
*   **Expression Language**: Разработан специалистами Comindware, похож на язык выражений Excel, прост в освоении и является своего рода **надстройкой для упрощения RDF N3**. Его достаточно для базовой настройки системы. Примеры использования включают навигацию по связанным шаблонам записи, подсчет объектов, простые математические операции (умножение, деление) и конкатенацию строк.
*   **Язык выражений RDF N3 (также называемый «Тройки»)**: Более сложен для чтения и написания, но **является более функциональным и основополагающим**. Стандарт этого языка определен международным консорциумом W3. Компилятор переводит формулы Expression Language в запросы на «тройках», которые уже однозначно понятны системе. Чтобы облегчить работу компилятора, рекомендуется сразу писать формулы на «тройках».

**Хранение данных** в Comindware Business Application Platform основано на **графовой базе данных, использующей модель RDF**. Основная идея графовой модели заключается в том, что любой объект имеет свойства, а эти свойства содержат значения. Сущность описывается с помощью простых выражений, называемых свойствами и их значениями, в виде **триплета**.
*   Триплет состоит из трех связанных сущностей: **«Субъект – предикат - объект»**.
*   Его можно соотнести с простым предложением: **Подлежащее – Сказуемое – Дополнение**. Например, утверждение «Книга написана Пушкиным» представляется как: **субъект – Книга, предикат – написана, объект – Пушкин**.
*   В графе субъект и объект представлены как **узлы**, а предикат – как **соединительная линия со стрелкой от субъекта к объекту**.
*   В платформе это выглядит как: **запись в ШЗ (субъект), ее атрибут (предикат) и данные (объект – значение атрибута)**.
*   **Пример хранения данных в триплетах**: `id 8037 - Название - “Война и мир”`. Вся метаинформация (описание шаблонов записи, форм, объектов, типов) и атрибуты окружения (текущий пользователь, время, контекст) также хранятся в таком виде, обеспечивая единообразие и простоту доступа к данным.

**Явные преимущества** такого хранения данных включают:
1.  **Простота понимания модели данных**: Быстрое освоение создания шаблонов записи и связей между ними даже неподготовленным пользователем.
2.  **Мгновенное добавление новых шаблонов и атрибутов**: Они сразу становятся доступными для работы.
3.  **Неограниченная широта и глубина связей**: Отсутствие ограничений на количество атрибутов и связей между сущностями.
4.  **Простота и неограниченность навигации по связям**: Переход из одного справочника в другой через ссылочное поле выполняется в одну строку.

### Цели использования языка N3

Язык N3 используется для:
*   **Продвинутого использования платформы**.
*   **Доступа ко всем созданным и системным атрибутам платформы**, включая те, которые не видны в интерфейсе.
*   **Большого количества функций для работы с данными**, таких как расширенные математические функции, работа со списками, приведение к одному типу данных, расчеты времени и многое другое.

### Навыки, которые будут освоены

В рамках курса пользователи научатся следующему:
*   **Урок 1**: Понимание **триплетов**, входных и выходных параметров **Item** и **Value**, синтаксиса языка N3 и использования **переменных**.
*   **Урок 2**: Работа с **библиотеками пространств имен**, **присвоение значений переменным**, применение **системных атрибутов**, использование **built-in предикатов** и **конструкции `from`**.
*   **Урок 3**: Знакомство с работой **итератора**, а также с функциями **Assert**, **if**, **or** и **контейнерами**.

### Результаты обучения

После прохождения курса пользователи смогут:
*   **Урок 1**: Разобраться с **телом запроса**, **основными правилами синтаксиса**, понять **структуру триплетов** и освоить **входные и выходные параметры запроса (Item и Value)**.
*   **Урок 2**: Применять **разные типы присвоения значений в переменные**, использовать **системные атрибуты** в запросах и выполнять вычисления с помощью **built-in предикатов**.
*   **Урок 3**: Разобраться в работе **итератора**, применять **логические условия для фильтров** и **объединять результаты запросов в одну переменную**. Эти функции являются наиболее часто используемыми в запросах.

### Краткое изложение уроков

#### Урок 1: Триплет, параметры Item и Value, синтаксис, переменные.

*   **Триплеты** формируют **само тело запроса** и состоят из понятий **субъект, предикат, объект**. Они позволяют получать требуемые данные из графа.
*   **Основные правила синтаксиса RDF N3**:
    *   **Каждый триплет начинается с новой строки**.
    *   **Объявление переменных** осуществляется с помощью **вопросительного знака (?)**.
    *   **Всё тело запроса заключается в фигурные скобки ({})**.
    *   **В конце каждого триплета ставится точка (.)**.
    *   **Интерпретатор регистрозависим**.
*   **Переменная** определяется как **«именованное хранилище» для данных**. Имена переменных задаются пользователем и должны отражать суть хранимых данных. В триплетах, любой объект после символа `?` является переменной.
*   **Входные и выходные параметры Item и Value** являются зарезервированными переменными особого типа.
    *   **Item**: **Входной параметр запроса**. Данные, поступающие на вход, зависят от контекста выполнения выражения. Например, при написании выражения в атрибуте, в Item будет содержаться ID текущей записи.
    *   **Value**: **Выходной параметр**. В него помещаются данные, которые необходимо отобразить на выходе. Тип данных, помещенный в Value, должен **согласовываться с типом атрибута**.
*   **Присвоение переменных**: Интерпретатор понимает, какая сущность из триплета неизвестна, и присваивает в нее недостающее значение. Существует **три основных варианта присвоения значений**:
    1.  **Известны субъект и предикат**: Искомое значение – это **объект** (наиболее частый случай).
    2.  **Известны объект и предикат**: Находится **субъект** (обратное присвоение).
    3.  **ExactMatch (Точное совпадение)**: Известны все три части, происходит проверка на полное совпадение для получения уточненного значения субъекта.

#### Урок 2: Библиотеки пространств имен, присвоение переменных, применение системных атрибутов, built-in предикаты, конструкция from.

*   **Библиотеки пространств имен** (@prefix object — <http://comindware.com/ontology/object#>) – это **подключаемые модули (области), содержащие знания об объектах, функциях и правилах**. Они предоставляют доступ к системным и прикладным атрибутам, а также к различным функциям для работы с датами, списками, числами и т.д..
*   **Стандарт RDF** определяет хранение данных в виде **URI (Uniform Resource Identifier)**, которые являются последовательностью символов, идентифицирующих ресурс. Использование библиотек позволяет сокращать длинные URI предикатов, используя переменные.
*   Функция **`object:findProperty`** доступна через библиотеку `object` и позволяет **получать URI атрибутов, записывать их в переменные и использовать в запросе**. Эта функция подходит для определения **прикладных атрибутов** (созданных вручную), тогда как системные атрибуты находятся в других библиотеках.
*   **Важное правило работы интерпретатора**: Если результат триплета `false` (например, не найден предикат или совпадение значения объекта), то **интерпретатор останавливается и не продолжает выполнение запроса**.
*   **Системные атрибуты**: Помимо прикладных атрибутов, созданных вручную, у каждого объекта в платформе (процессы, шаблоны записи, группы) есть **системные атрибуты**, которые не всегда видны в интерфейсе, но существуют и автоматически заполняются системой.
*   **Built-In предикаты**: Это **сложные предикаты, содержащие функции для работы со строками, датами и т.д.**, в отличие от обычных предикатов, описывающих свойства сущностей. Пример - `cmwmath:sum` для математических функций.
*   **Конструкция `from {}`**: Используется для **преобразования типов данных на входе функций**. Например, для математической функции суммирования требуется тип данных "list". Если переменная содержит URI значений, `from {}` позволяет преобразовать их в нужный тип. Синтаксис: `from {триплеты} select ?переменная -> ?лист.`.

#### Урок 3: Итератор, Assert, if, or, контейнеры.

*   **Итератор** – это **перечислитель, поддерживающий простой перебор по группе ссылок**, таких как коллекции или ссылки со множественными значениями. Итератор **случайным образом берет первый объект из коллекции** и проверяет его на выполнение условий по всем нижестоящим триплетам. Если условие не выполняется (результат триплета `false`), запись отбрасывается, и итератор переходит к следующей записи. Итератор работает всегда и стремится проверить все уникальные значения.
*   **Конструкция `once {}`**: Используется, когда точно известно, что **итератор должен пройти по телу запроса только один раз** (нет ссылок со множественным значением или коллекций). Обертывание триплетов в `once {}` **ускоряет запрос**.
*   **Логическое И (AND)**: В N3 **по умолчанию используется конъюнкция между строками триплетов**. Если одно из условий `false`, весь запрос завершается.
*   **Проверка на пустоту**: Выполняется синтаксисом `not {?субъект ?предикат ?.}`, где точка вместо объекта означает наличие данных. Добавление `not` проверяет пустоту.
*   **Логическое ИЛИ (OR)**: Для объединения условий с помощью `ИЛИ` используется синтаксис `or {триплеты} or{триплеты}.`. Может быть несколько `or`-условий, в конце каждого перечисления `or` должна стоять точка.
*   **Условный оператор IF**: Позволяет проверить условие и выполнить действие в зависимости от результата. Синтаксис: `if {условие} then {выполняется, если условие - true} else {выполняется, если условие - false}`. Если `else` не указан и `if` не сработал, результат всей ветки будет `false` (информация не из источника).
*   **Функция `assert:union true`**: Используется, когда **необходимо объединить несколько результатов выполнения запроса в одну переменную**. Синтаксис: `({триплет} {триплет}) assert:union true.`.