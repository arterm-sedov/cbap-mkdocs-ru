Представленные источники, включая выдержки из "All notes 15.08.2025" и стенограммы YouTube-видео "Part 1", "Part 2", "n3 p1" и "n3 p2", всесторонне описывают фундаментальные концепции и практическое применение языка запросов N3 в контексте графовых баз данных.

### Структурированное Резюме по Видео и Источникам

#### 1. Фундаментальные Концепции Базы Данных
Источники подробно описывают взаимосвязь между онтологией, графовыми базами данных и триплетами, которые являются основой для хранения и обработки данных в платформе N3/RDF.

*   **Онтология**:
    *   В области информационных технологий (ИТ) онтология формально определяется как **набор объектов, их свойств и взаимосвязей между ними**.
    *   Ее основная цель – предоставить **структурированное и машиночитаемое представление конкретной предметной области или реального мира**.
    *   Основные компоненты онтологической модели включают **Объекты (сущности)**, **Характеристики/Свойства (атрибуты)** и **Взаимодействия/Отношения (связи)**. Примером является "Пенал содержит Карандаш", иллюстрирующий отношение "один-ко-многим".

*   **Графовые Базы Данных**:
    *   Представляют собой специализированный тип баз данных, использующий **графовые структуры для хранения и представления данных**, что особенно подходит для **семантических запросов**, фокусирующихся на значении и взаимосвязях.
    *   Основные компоненты: **Узлы (вершины)**, представляющие сущности или значения (например, "Человек", "Автомобиль"), и **Ребра (отношения)**, представляющие взаимосвязи между узлами (например, "владеет").
    *   **Графовые базы данных естественным образом представляют онтологические модели**.

*   **Триплеты (N3 и RDF)**:
    *   **Онтологическая модель напрямую трансформируется в фундаментальную единицу хранения данных** в графовой базе данных N3/RDF: **триплет**.
    *   Каждый триплет состоит из трех частей: **Субъект**, **Предикат** и **Объект**. Субъект — это описываемая сущность (источник стрелки), Предикат — ее свойство или отношение (сама стрелка), а Объект — это значение или связанная сущность (пункт назначения стрелки).
    *   **Направленность является важнейшим аспектом триплетов**, определяя поток отношения (например, "Человек владеет Автомобилем" отличается от "Автомобиль принадлежит Человеку"). Это диктует, какой элемент является Субъектом, а какой Объектом, что критически важно для структурирования запросов N3.

*   **Хранение Данных в N3 Базе**:
    *   **Все данные в базе данных N3, включая системные метаданные и пользовательские данные, хранятся исключительно в виде триплетных фактов**.
    *   Системные модели описываются в файлах .n3, а прикладные данные – в файлах data.n3.
    *   Платформа использует движок SQLite для транзакционных операций, но ее **основная модель данных и логика сериализации/десериализации между триплетами и реляционными представлениями являются собственной разработкой** и запатентованы.

*   **Типы Данных в Триплетах**:
    *   Данные могут быть представлены как:
        *   **Квалифицированные имена (QName)**: Сокращенные формы длинных URI для ресурсов, используемые для субъектов, предикатов и объектов.
        *   **Простые литералы (Simple Literals)**: Прямые, атомарные значения (строки, числа, булевы значения, даты).
        *   **Сложные литералы (Complex Literals)**: Коллекции фактов или упорядоченные наборы значений, включающие **Формулы ({...})** и **Списки ((...))**.

*   **Аксиомы и Выводимые Факты**:
    *   **Аксиомы (Axioms)**: Факты, которые **непосредственно хранятся** в базе данных в виде триплетов.
    *   **Выводимые факты (Derived Facts)**: Вычисляются на лету на основе аксиом и текущего контекста (например, **вычисляемые атрибуты**) и **не хранятся** в базе данных. Это гарантирует, что они всегда отражают самые актуальные базовые данные.

#### 2. Язык Запросов N3
Запросы N3 являются основным языком для определения динамического поведения и вычислений на платформе, обеспечивая гибкую и контекстно-зависимую обработку информации.

*   **Основные Принципы Запросов N3**:
    *   **Операции над триплетами**: Запросы N3 работают непосредственно со структурами триплетов.
    *   **Направленность**: Направленность связей имеет решающее значение для структурирования запросов N3.
    *   **Переменные**: Обозначаются вопросительным знаком (например, `?S`, `?P`, `?O`) и представляют неизвестные значения, которые запрос должен обнаружить.
    *   **Поиск (Search) против Сопоставления (Match)**:
        *   **Поиск (Search)**: Используется, когда одна или несколько частей триплета являются переменными. Система находит факты, соответствующие известным частям, и возвращает **итератор результатов**.
        *   **Сопоставление (Match)**: Происходит, когда все части триплета являются известными значениями. Система просто проверяет наличие этого точного факта в базе данных, возвращая `true` или `false` **без итератора**. Часто используется для валидации или условной логики.

*   **Синтаксис и Структура Запросов N3**:
    *   Включает: **Терминатор триплета (.)**, **Блоки формул ({...})**, **Списки ((...))**, **Префиксы (@prefix)**, **Комментарии (#)**, **Неявный субъект ([...])**, **Зарезервированные ключевые слова** (`a`, `is ... of`), **Присваивание (=)** и **Условный оператор (`if...else`)**.
    *   Если `if` условие ложно и нет `else` блока, выполнение запроса прекращается.

*   **Модель Выполнения Запросов N3**:
    *   Следует **последовательной и итеративной модели**: запросы выполняются сверху вниз, строка за строкой.
    *   Если строка (триплет) возвращает **итератор** (несколько значений), последующие строки **повторно выполняются для каждого значения** в этом итераторе, создавая поведение, похожее на вложенные циклы. Это означает, что механизм запросов "проходит" по графу от узла к узлу через ребра (предикаты).
    *   **Область действия итератора** ограничена формулой/блоком, в котором он был создан.
    *   **Порядок триплетов существенно влияет на производительность**. Для оптимизации запросов крайне важно начинать с **наиболее ограничивающих условий**, чтобы минимизировать размер начальных итераторов.

*   **Контекстные Переменные**:
    *   В различных контекстах запросов N3 используются зарезервированные переменные: **`item`** (обычно представляет ID текущего объекта или записи, может быть входным или выходным параметром) и **`value`** (выходной параметр, куда записывается вычисленное значение или результат запроса, его тип может варьироваться).

*   **Встроенные Предикаты и Операторы**:
    *   **`object:findProperty`**: Встроенный предикат для получения ID атрибута по его псевдониму шаблона и псевдониму атрибута, возвращает один ID и высоко оптимизирован.
    *   **`assert:union`**: Объединяет результаты нескольких итераторов в один; `assert:union true` включает дубликаты ("union all").
    *   **`ones`**: Выполняет запрос и возвращает только первый успешный результат, останавливая дальнейшую итерацию после нахождения совпадения.
    *   **`or`**: Оценивает несколько условий и возвращает `true`, если любое из них выполняется, останавливаясь после первого успешного условия.
    *   **Встроенные функции**: Специальные предикаты (например, `math:sum`, `time:dayOfWeek`), которые выполняют вычисления в памяти, а не запрашивают базу данных, могут работать со списками значений.

#### 3. Контексты Применения Запросов N3
N3 запросы используются в различных функциях платформы для определения динамического поведения.

*   **Вычисляемые атрибуты**: Динамически вычисляют значение для шаблона записи; значения не хранятся, а рассчитываются на лету при запросе. `item` является входным параметром, `value` – выходным.
*   **Фильтры списков**: Фильтруют записи, отображаемые в списке. Для них `item` является выходным параметром (IDs записей), входного `item` нет.
*   **Операции (Условное отображение)**: Контролируют условное отображение или скрытие операций (например, кнопок "Завершить задачу"). `item` – входной параметр, `value` – выходной (true/false).
*   **Бизнес-правила (Триггеры/Сценарии)**: Определяют действия, выполняемые на основе определенных событий (например, изменение поля на записи). Ранее известные как "триггеры", сейчас рассматривается переименование в "сценарии".
*   **Глобальные функции**: Позволяют вызывать внешние функции (например, написанные на C#) из запросов N3 для сложных вычислений или получения данных из внешних сервисов, что способствует повторному использованию кода.

#### 4. Оптимизация и Практические Аспекты N3 Запросов
В ходе обсуждений неоднократно подчеркивается важность оптимизации N3 запросов, а также рассматриваются возможности для дальнейшего развития платформы.

*   **Важность оптимизации**: **Порядок триплетов значительно влияет на производительность** из-за последовательного и итеративного выполнения запросов. Рекомендуется начинать с **наиболее ограничивающих условий** для минимизации размера начальных итераторов.
*   **Анализ сложных запросов**: В видео "Part 2" и "n3 p2" рассматриваются примеры, демонстрирующие использование `assert:union` для объединения результатов и `assert:count` для подсчета уникальных элементов, а также демонстрируется, как итераторы формируются и переключаются между блоками запроса, что подчеркивает необходимость понимания их поведения для написания эффективных запросов.
*   **Развитие и улучшения**: Отмечается постоянное улучшение среды разработки N3 запросов, включая новые компиляторы и редакторы для лучшей подсветки ошибок и помощи в коде. Также упоминаются планы по внедрению DMN-таблиц (Decision Model and Notation) во всех точках применения выражений для упрощения сложной условной логики, особенно в формах. Обсуждается необходимость улучшения документации, в частности, для версии 4.0, чтобы она была доступна своевременно.

Ниже представлен полный транскрипт прикрепленных видео, составленный из предоставленных источников.

---

### Транскрипт видео "Part 1"

**Георгий:** Включаем, да, если что, аудиозапись, ой, в смысле, видео. Тут запись, да, будет доступна непосредственно в этом чате, и она месяц, по-моему, держится, можно будет скачать. Ну, мы её скачаем, если что, выложим на наш внутренний ресурс. Спасибо большое. Давай себя. Так, коллеги, всё, тогда больше никого не ждём, да, начинаем. Я так понимаю, сейчас, а, его нет. Так, хорошо. Ну, коллеги, всем ещё раз добрый день, да. Меня зовут Георгий. Если, как бы, там какие-то вопросы по ходу возникают, вы не стесняйтесь, задавайте, чтобы нам, да, не это, не забывать, далеко не уходить. Вот. Я ничего страшного, отвлекусь, отвечу, постараюсь, по крайней мере, да, насколько возможно. А вот. И, собственно, там, я надеюсь, мы сегодня вот рассмотрим с вами ну первые пять тем точно, шестую там не обещаю, да, потому что у нас и материал такой, он непростой, и, как бы, вот последний, пятый урок, он уже более-менее сложный и требует там подумать на задании. Вот, собственно, весь курс там я разбил на условных шесть уроков, да. А первые мы быстренько пробежим, вот я их меньше всего люблю, конечно, да, но в любом случае там, чтобы связать, да, реальный мир там с тем, почему мы именно построиливаю базу и, как бы, как она работает. Соответственно, это полезно будет всё равно услышать ещё раз там, наверное. Э-э, соответственно, ну, давайте уже перейдём непосредственно к урокам.

Ну, всё начинается с **онтологии**, да. Что такое вообще онтология? Что в это понятие вкладывается? Ну, вообще, как бы, оно пошло от греческого, да, то есть учение о сущем, о бытии, о как таковом, о связи между это раздел философии, фактически, который там изучает там какие-то фундаментальные принципы бытия там и его а-а взаимодействия с между собой. Ну, фактически, если, да, как бы, переложить там на более понятный язык, то есть у нас нас окружают какие-то предметы, нас окружает мир, да. У нас есть там погода, есть автомобили, есть здания, дома и так далее. Есть какая-то, если ещё более приближена, предметная область, с которой мы работаем. Вот. И эта предметная область также состоит из объектов, каких-то свойств и, соответственно, вот с, как вы видите на слайде, да, тут, собственно, окружающий мир, да, это **объекты**, это их **характеристики** и это их **взаимодействие**. Если перейти уже к понятиям в информационным технологиях, да, ближе, то есть под онтологией там в информационных технологиях понимается какое-то **описание множества объектов и их там свойств и связи между собой**. Ну, то есть, недалеко ушли от общего базового понятия, да. А ну, как правило, онтологии, да, они представляются в виде ну различных нотаций в разных языках программирования, в разных инструментах и так далее. То есть приближено самое приближенное, наверное, это вот э там описание, да, классов и их свойства и методов, фактически. Как бы, ну, если взять там, да, нотации, какие существуют, их там множество там, начиная от UML каких-нибудь диаграмм классов и заканчивая там диаграмм там описание реляционных баз данных. А все они фактически относятся к описанию антологии реального мира.

Ну, давайте вот для примера просто, как бы, возьмём, да, что у нас есть какое-то яблоко там или сорт яблок, неважно. То есть, и вот у нас есть, ну, мы этому сорту или этому яблоку сопоставим какой-то класс, да, под названием яблоко. У этого класса могут быть там цвет, вкус, например, да. Ну, ну, бывают яблоки безвкусные, конечно, но это значит, что просто вкус плохой, наверное. Вот. И если, да, представить во взаимодействии, то существует там, например, человек, да, который, как вы видите, вот есть связь э-э может любить яблоки там или может иметь яблоки. То есть связь она также может характеризоваться каким-то типом. А фактически здесь мы описали модель, да, как бы взаимодействия там человека с яблоком. Ну, и есть какие-то экземпляры: конкретные яблоки или конкретные сорта. Вот. И там конкретные люди: Иван Иванович, там, я, вы, э-э, неважно, да, люди, которые любят разные яблоки, имеют там собой эти яблоки и, в общем, как-то с ними взаимодействуют.
**Георгий:** Георгий, вопрос, а-а, ну, первое, как вопросы задавать: в чате писать или голосом?
**Георгий:** Да нет, прямо так говорите, чтобы у нас немного.
**Георгий:** Теперь второй момент, вы когда сказали, что человек действительно может отношение к яблокам, да, это действие над яблоком и так далее. Я так понимаю, что э-э вот этого вот, ну, чёрточка от яблок человека, ну, в смысле, путь, он может быть множественным, каждый из них инован по-своему?
**Георгий:** Всё верно, всё верно. То есть с точки зрения именно та типизации здесь имеется в виду, что связь может быть не одна, их может быть несколько. Ну, сейчас это не так существует, да, в общем.

Давайте просто вот для примера там, чтобы там понимать, да, что мы на одной волне вот разложим там предметную область **карандаши в пенале**. Такое вот маленькие, просто задание. А-а, я сейчас перейду вот в редактор, да, ну, в такой же нотации, например, мы вот с квадратиками, грубо говоря, сейчас что-нибудь с вами нарисуем. Ну, давайте, кто, коллеги, мне поможет, да, что мы, да, это в Google Docs, неважно, это я так исключительно, чтобы быстро нарисовать, да, и сохранить.
**Анатолий:** Ну, у нас есть пенал.
**Георгий:** Вот отлично, у нас есть пенал. Это фактически будет, мы, наверное, класс здесь помечаем, что нас **класс пенал**.
**Анатолий:** Пенал. И у нас есть класс карандаш.
**Георгий:** И у нас есть класс карандаш, да. Какие-нибудь свойства им назначим обязательно сейчас. Ну, давайте, мы сейчас класс всё сделаем. Давайте. А-э, так.
**Георгий:** Карандаш.
**Георгий:** Карандаш.
**Георгий:** Ну, **класс пенал** – это у нас материал. Вот отлично, это у нас вместимость. Давайте так, вмести объём, ёмкость. Ну, ёмкость, да, как хотите. А, хватит. Я думаю, хватит. Я думаю, точно.
**Георгий:** Класс карандаш. У нас что будет?
**Анатолий:** Опять же, цвет. А-а.
**Георгий:** Ну, давайте напишем слово **состояние**. Состояние – это будет обозначать острый, тупой, вообще нетронутый. Ну, тут твёрдость у них есть. Ну, в общем, да нет, да, это состояние, да, у нас идёт твёрдость. Ну, вот в общем, какие-то мы свойства, да, обозначили.
**Георгий:** И теперь между ними связь. Связи элементарная – это у нас, э-э, значит, **карандаши э лежат, находятся в пенале**, да. А вот, вот это самый важный момент. Всё-таки, ну, от какого класса где, где свойст, где будет свойство принадлежности? А вот это вопрос, как это сказать? Давайте сейчас, ну, это это было направлена связь, коллекция и, то есть, в пенале есть коллекция карандашей, карандаш находится в таком-то пенале.
**Анатолий:** Не, мы сейчас не говорим про отображаемую часть, мы говорим сейчас про антологию как бы мира.
**Георгий:** Я бы антологию всё-таки пенал.
**Анатолий:** Пенал, пенал, пенал может содержать а множество карандашей, а карандаш принадлежат одному пеналу. То есть, связь имеет только одно направление.
**Георгий:** Ну, давайте, я немножко, да, с другой стороны зайду. То есть, не.
**Анатолий:** Можно, я тоже чуть-чуть попробую.
**Георгий:** Ну, давайте.
**Анатолий:** А я бы так сказал, карандаш может в пенале не лежать, но от этого он не исчезнет, правда? Вот. То есть карандаш вообще ничего про пенал не знает. То есть ему вообще по барабану есть пенал или нет. Он может в стакане стоять или где-то ещё, да, и может вообще в принципе существовать, а там на это, на веточ, на ниточке подвешенный, да, то есть, а там или в руке быть у человека. Вот. А именно свойство как раз-таки пенала, что он имеет возможность э-э вмещать карандаши. Вот, вот это вот важно. То есть, именно пенал, как бы. Ну, здесь дальше мы поймём, почему это важно, да, когда перейдём уже к.
**Анатолий:** Ну, наш направление какое будет: от карандашей к пеналу? Правильно?
**Георгий:** Да, да, да. Ну, мы просто агрегацию сделали, да. Фактически, как бы, говорим о том, что **в пенале, как бы, содержится один, ноль или там множество карандашей**, при этом карандаши карандаш, да, он всегда только в пенале может быть в одном. То есть, он не может там присутствовать.
**Анатолий:** Нет, у него либо ноль, либо один пенал, правда?
**Георгий:** Да, да, да, да, да, всё верно. А, обзываем это находится. Ну, давайте так, или лежит, не знаю, как, как хотите, так и называйте.
**Анатолий:** Нет, а эрна – это агрегация содержит в содержании, в содержании находится.
**Георгий:** Согласен. Так, что-то у нас здесь большая. Вот так вот, хорошо. Так, ну, с этим разобрались, в общем, мы все в одном поле находимся. Всё хорошо. Так, что это у нас вообще с преобразованием, да. Живёт, живёт нормально. Вот вопрос в том, что он почему-то о какой-то странный. Так, давайте тогда дальше к презентации нашей, и вот мы от онтологии тогда потихоньку, да, переходим к графу, и почему в принципе граф, да.

Ну, то есть, в принципе, **граф** – это такая вот абстрактная, там, если взять там математическое описание, да, это какая-то абстракция, абстрактная фигура, а которая может э, соответственно, содержать э-э набор **вершин** и в принципе между ними могут быть ещё проведены **рёбра**, так называемые парные связи. У графа есть, как бы, много разновидностей, да. Есть **связанные**, то есть, как бы, которые именно между собой связаны, да, вершины. Есть **изолированные**, которые, соответственно, не не содержат ни одной связи, да. Есть **направленные** и **ненаправленные**, то есть когда у нас есть стрелочка, да, это значит, что он направленный, как бы, граф, по крайней мере, да. Э-э, есть ненаправленные, где, в принципе, направление не задаётся. Есть **полные**, **неполные**, где между ними, собственно, между каждой из вершин, да, есть э-э связь с любой другой вершиной графа. Есть **древовидные**, кстати говоря, то есть дерево – это один из видов графа, так называемый **планарный** э-э и направленный. Ну, понятно, почему направленный, да, понятно, почему планарный. Планарный – это, как бы, когда дерево можно на плоскости разместить, и не будет пересекающихся рёбер у этого дерева, у этого графа. Вот. Соответственно, видов графов много.

Но, а как нас, как нам вообще помогает граф, да, при описании как раз-таки онтологической модели, да, и окружающего мира при создании онтологической модели окружающего мира? Фактически весь граф, да, можно разбить вот на такие вот парные, да, рёбра, которые, как бы, содержат там смежные рёбра, которые содержат пару вершин, и между ними, соответственно, ребро. В данном случае, когда мы говорим, да, что у класса есть свойства, у свойства у класса есть метод, у класса есть экземпляр, и так далее, и так далее, мы фактически произносим там три слова, да, что вот там объект какой-то, он там несёт какое-то свойство или там объект, да, связан с другим объектом. То есть, фактически, вот это отображается также в виде, то есть, легко можно отобразить в виде графа. Ну, к следующему слайду, если перейдём, да, ну, вот тоже пример, как бы, что есть **человек** какой-то, который **владеет** каким-то **автомобилем**. А если мы попробуем изобразить в виде графа, да, то фактически есть какой-то класс человек, есть какой-то класс автомобиля. У него есть свойства, что человек именно владеет именно автомобилем, не автомобиль владеет, да, и так направление здесь играет уже роль. А если немножко ниже спустимся, то конкретный Иван Иванович, да, он, как бы, является конкретным человеком, а, соответственно, ну, принадлежит, точнее, классу человек, да, является классом человек. Есть автомобиль Volvo, да, какой-то там с номерным знаком каким-нибудь, который, как бы, является классом автомобиль. А, и, соответственно, Иван Иванович владеет вот именно вот конкретным вот этим вот Volvвом. То есть, как видим, да, здесь законченный граф, а где вершинами являются какие-то экземпляры и классы, и между ними, соответственно, есть отношения, которые выражаются в каких-то там, ну, свойствах, владениях и так далее. То есть, ну, вот, собственно, наверное, на этом и всё.
**Анатолий:** Можно, можно тогда вопрос, разрешим?
**Георгий:** Да, конечно.
**Анатолий:** А, собственно говоря, почему на графе у нас возникли вот именно в данный момент возникли как класс классы, так и объекты? То есть, это, то есть, мы вот в чём этого этой картинки?
**Георгий:** А я сейчас когда перейду, да, немножко дальше, я как раз-таки в базе данных покажу и расскажу, как бы, чем отличаются, да, классы от конкретных экземпляров. Фактически, с точки зрения графа.
**Анатолий:** Отличия вы покажете, я тоже их прекрасно догадываюсь, что они отличаются. Именно меня смутило, потому что это совершенно разного уровня понятия, а когда к ним с точки зрения графа вообще никакого отношения не имеет.
**Георгий:** Я поэтому и хотел их показать, что вот вы когда граф рисуете, да, здесь всё одинаково. Есть вершины, которые являются какими-то значениями, объектами, да, объектами, инстанцами, там, их можно назвать и так далее, неважно, да. И эти вершины могут как раз-таки обозначать совершенно разное. То есть здесь может быть э-э класс, здесь может быть конкретный объект, здесь может быть конкретное значение, которое является там ссылкой ещё куда-то и так далее.
**Анатолий:** Не, э Георгий, я понимаю Анатолия, да. Понимаю, откуда его вопрос взялся. Я бы так сказал, что вот э-э то, что вы нарисовали, вообще говоря, это избыточная картинка несколько, ну, вот так подумать, и она, в принципе, вот, ну, так как мы чуть-чуть смотрели 3 там, по крайней мере, на выражение, которое у вас есть и так далее. А я бы так сказал, зная о том, что класс человек может владеть автомобилем, да, мы говорим, что вот, если вот у нас вот это вот существует, то, да, мы можем вот построить э-э выражение отношения, что у нас конкретно Иван Ива Человек владеет конкретным автомобилем марки Volma. Потому что, если бы не было верхнего, ну, верхнесть, верхнего кусочка графа, где человек владеет автомобиль, да, то тогда непонятно было, почему мы могли построить второй.
**Георгий:** Ну, всё правильно вы говорите. То есть, э-э я почему как раз-таки нанёс здесь и объекты вот для того, чтобы как раз-таки показать, да, что у вас связь она начинается от э-э, ну, как сказать, отпи от определения, от описания класса, да. То есть, у вас связь в данных она появляется вот как раз-таки от определения. И фактически, когда, ну, если перейти уже, да, на нашу систему, да, когда вы говорите о том, что у вас появляется атрибут, да, там, ссылки на какой-то там, не знаю, из проекта там, на работу, да, то вы тем самым говорите, что вы имеете возможность дальше в конкретном проекте выбрать эту работу в определённом поле. Ну, то есть, фактически, как бы, у вас есть и определения, и конкретные экземпляры этих определений. И при этом, да, у вас, как бы, как видите, они лежат все на одном уровне. То есть, вообще, вот с точки зрения базы данных, да, уже вот здесь вот не будет никаких отличий. Ну, давайте, дальше я просто немножко.
**Анатолий:** Я тогда ещё, ещё раз. Если бы всё-таки снизу было бы вот это владеев, вот только вот именно конкретно чёрточка была бы прочерчена просто другим цветом, э-э.
**Анатолий:** То была бы проекция верхней чёрточки. То есть, это у нас два мира: мир иде идей и мир сущностей. Всё, я бы услышал, о чём речь, да.
**Георгий:** Это вас смутило именно то, что одинаковые как бы связи вы представляете смешивание двух миров, то есть Пифагоров мира и другой мир, они смешались у вас в антологии. Как раз. Всё. Я согласен, что здесь немножко, наверное, пример я не это, не то, что некорректный, да, немножко излишний. Тут именно с точки зрения описательной. Ну, да, учту, учту, да. Так, ну и давайте мы просто-напросто вот наши карандаши в пенале тоже также попробуем в граф разложить, да. Давайте откроем вторую картинку. Ну, мы будем рисовать также избыточно, но давайте также избыточно нарисуем. Ну, и давайте, значит, мы говорим, так, давайте, да, вы их просто дублируете, что вы Ctrl Ctrl V, чтобы одинаковые были. Вот. А, соответственно, здесь у нас там, ну, давайте все четыре сделаем, чтобы честно было, да. Поддерживаю. Вот. Соответственно, мы здесь пишем пенал, карандаш. В левом пишем так. В левом левый верхний пишем карандаш.
**Анатолий:** Всё-таки карандаш, да.
**Георгий:** А, ну, раз мы договорились, что от карандаша пляш, карандаш. А так, там у нас будет пенал, да. Э-э, так, что мы там писали? Какое красивое слово? Ну, там пока, если слово пока опустить, то получится, у нас есть синий карандаш и пластмассовый пенал.
**Анатолий:** Нет, тут содержит. Вот содержит, да. Не, мы свойства пока не это, не берём в расчёт, мы исключительно вот попробуем, а нет, а там было Иван Иванович, соответственно, карандаш. А, вы как название. Всё, я понял, да, да, да, да. Угу. Да, хорошо. Давайте так и хочется сказать Иван Иванович, а здесь пластмассовый пенал.
**Анатолий:** Как говорил Анатолий, красота, да.
**Георгий:** Ну, и теперь осталось связи нарисовать. Содержится, да, карандаш содержится, а вот как раз-таки, наверное, наоборот. А вот он может содержаться, а может не содержаться, или это уже направление у нас здесь всё равно направленность-то есть от карандаша к пеналу у нас направлены в соответствии с нашей этой штукой, да, 0,1, а оттуда 0, бесконечность.
**Анатолий:** Ну, она двойная связь, она двунаправленная, поэтому это и есть агрегация.
**Георгий:** Ну, я бы наоборот рисовал, потому что всё-таки, если мы говорим про антологии и реальный мир, да, то вы должны, как бы, понимать, что карандаш, так как у нас ничего не знает, у него свойства пенал не будет. То есть у него не должно быть свойства пенал по идее. У пенала должно быть свойство как раз-таки набор карандашей, какие в нём. Ну, поэтому именно спор, спорный вопрос.
**Анатолий:** Ну, с точки зрения реляционной модели, да, я тоже вас понимаю прекрасно. То есть, я немало реляционных моделей, как бы, в своё время попроектировал, как бы, здесь действительно карандаша просто ставится, да, грубо говоря, поле пенал, и, как бы, заполняется, то куда он вложен. Так как оно единичное, да, ну, в смысле, однозначно должно быть определено. А, соответственно, в в графовой базе немножко по-другому.
**Анатолий:** Ну, тогда у нас получается, что мы делаем другую модель по отношению к тому, как мы нарисовали классы.
**Георгий:** Да нет, всё, всё, всё также, всё хорошо. У нас от карандаша к пеналу шло, хотя нет, у нас у нас стрелки тут нету, тут тут ромбик содержит, тут ромбик. Тут именно, именно пенал, да, содержит карандаш. Ну, хорошо, тогда будем давайте карандаш содержится в пенале, да, или как там? Ну, точнее, пенал содержит карандаш. Ну, да, давайте так, содержит, поэтому и употребили. Нету свойства текстового. Так, давайте вниз тоже её протянем. Вот. Ну, и, соответственно, наверное, наверх, да, что обе наверх, да, да, что является. Ну, и замечательно, с этим мы быстро с вами разобрались. Пойдёмте дальше.

И пойдёмте дальше. И вот дальше мы уже попадаем в наши **тройки**. То есть, мы с вами посмотрели, что такое онтологии, посмотрели, что такое графы, да, нарисовали даже наш граф один, и, соответственно, дальше графы потихоньку перетекают в так называемые уже **триплеты**. Ну, фактически, да, всё начинается с а упрощённого, там, да, представления, точнее, даже не упрощённого, наверное, а представления графа в виде **модели RDF**. А-а, ну, я не знаю, знакомы, незнакомы, да, вообще, что это, как бы, среда описания ресурсов, да, то есть **Resource Definition Framework**, а которая, в принципе, разработана была консорциумом всемирной паутины, да, и она как раз-таки представляет машиночитаемое описание, да, для м-м, как бы, моделей, вот, как онтологических моделей, связанных там с окружающим миром. В принципе, вот, если мы берём там нашу базу, берём, как бы, а наше представление, то у нас немножко упрощённое представление RDF. В принципе, оно имеет нотацию там основная нотация – это именно XML представление в виде XMLй, да. Вотes – это более упрощённое текстовое представление а модели RDF, и она, в общем, базируется там на Notation там Turtle и Notation 3. Можно, в принципе, на эти нотации тоже найти, посмотреть. Ну, сейчас не предмет, в принципе, да, около погружение в этом, да. А, соответственно, любая любой **триплет**, да, это вот тройка вот таких вот так называемых **Субъекта**, **Предиката** и **Объекта**, а которые выражают из себя, да, любой вот блок графа, который мы выделили, заключённый двумя вершинами и ребром, направленным ребром.

Ну, фактически, да, если мы говорим про там нашу модель **Иван Иванович владеет Volvo**, да, то у нас вот наш граф, который выражен, да, человек владеет автомобилем, там, Иван Иванович владеет Вольвой, там, каждый является чем, то стройка как раз-таки у нас уже будет записана вот в виде вот таким вот образом. То есть, как вы видите, у нас появились записи там в виде трёх аргументов, где первым аргументом является субъект, вторым предикат, третьим объект. В данном случае, если мы разложим наш граф на такие триплеты, да, то у нас получится по рёбрам четыре, как бы, триплета. То есть, первый, если взять верхнюю пару, где человек владеет автомобилем, то у нас есть какой-то человек, как-то владеет он какой-то есть предикат типа владения, и есть там какой-то класс, да, автомобиль, который, как бы, тоже вы в каким-то ресурсом обозначен. Соответственно, конкретный Иван Иванович, ну, я здесь его обозначил литералом Безури, да, так называемого. То есть, вообще, каждый ресурс, да, он представляет из себя согласно RDF нотации урл, ну, или ури, то есть, именно глобальный ресурс. Вот. В данном случае, Иван Иванович может быть конкретным экземпляром, имеет свои свойства и тоже может быть представлен в виде какого-то ури, да, но мы взяли просто исключительно, как бы, так, в качестве демонстрации, что а-а, как бы, есть литерал, да, он является, как бы, именно классом человек. Дальше у нас, если взять автомобиль, то есть, что у нас Volvo является классом автомобиль, да, и, соответственно, Иван Иванович, да, конкретный, владеет конкретным Volvo. То есть, нижнюю связь мы вот обозначили. Вот, коллеги, как бы, с триплетами не.
**Георгий:** Ну, понятно, да, с точки зрения, как превращаются графы в триплеты, я думаю, в принципе, никаких проблем, да, не вызывает.
**Анатолий:** Есть вопрос: направленность.
**Георгий:** Направленность.
**Анатолий:** Направление вот является. То есть, у нас получается, что субъект – это конкретный человек, а то, что он входит в какое-то сообщество, ну, скажем, вот всех человеков – это м-м, вот это уже объект будет. То есть, сообщество объекта, человек-субъект.
**Георгий:** Смотрите, на, как субъект, предикат, объект определяется. Это исключительно на основе связи, то есть, **направление связи**. Прошу прощения. То есть, если он на связь всё-таки идёт, что человек владеет автомобилем, да, то у вас, как бы, человек – это субъект должен быть, а объект – это будет автомобиль. Соответственно, предикат будет выражать именно направление связи.
**Анатолий:** Значение направления связи. Вы имеете в виду, что, если слово владеет заменило принадлежит.
**Георгий:** Если вы, да, если вы, например, принадлежит назовёте и перевернёте стрелку, то у вас будет на первом месте уже автомобиль принадлежит человеку.
**Анатолий:** А, то есть они он вроде бы направленный, но можно разворачивать спокойно.
**Георгий:** Ещё раз. То есть, он всегда направленный. В зависимости от того, как вы расположите, он всегда направленный. Вот если вы расположили так, значит направление у вас от человека к автомобилю. Если вы расположили в обратном направлении, то, как бы, будет от автомобиля к человеку.
**Анатолий:** Меня и смутило то, что всех человеков и конкретно Ивана Ивановича мы расположили так, а вот в принципе-то я согласен, что так оно и есть в понятии субъектности и объектности.
**Георгий:** Нет, ну, если у вас, как бы, претензия к модели, которую я тут запроектировал, ну, я ял.
**Анатолий:** Это вопрос, это будет, как бы, то, о чём важно будет думать, создавая объёмную модель. Потому что сама направленность она задаёт потом очень многие вещи, которые потом очень сложно будет поменять, потому что это выстроено уже в цепочку триплетов.
**Георгий:** Ну, смотрите, я здесь про направление почему как бы это немножко заостряю внимание, потому что у нас **вся база, да, она построена как раз-таки на триплетах**. И от чего, от како от как сказать, как взаимодействие между этими триплетами выстроены в базе, да, вот в настоящий момент, как эти триплеты составлены – это вот как раз-таки будет определять, как вы будете строить дальше запросы. То есть, фактически, я здесь просто как раз-таки делаю упор на то, что **направление важно, и вы когда будете делать их запросы, да, у вас субъект и объект должны быть на определённых местах, и вы должны чётко употреблять, как бы, предикат тот, который, как бы, определяется моделью**. Поэтому, если го.
**Анатолий:** Когда вы горгий, когда вы говорите слово модель, а вы говорите о чём? Модель общая, которая, как бы, ну, для конкретного, скажем так, для конкретной сборки платформы, или туда же ещё, или туда же мы ещё и включаем то, что делаем мы, наши модели?
**Георгий:** Смотрите, смотрите, именно **системная модель**, да, у нас зашита в платформу, и вы её в любом случае править не можете, и нужно чётко понимать, как она лежит. Это первое, да. Это первый момент. Второй момент, когда вы проектируете, вы тоже должны понимать, в каком направлении вы обозначили атрибут ссылку, да, и куда будет смотреть именно ссылка. То есть, не нужно понимать, что у вас атрибут ссылка, да, он направленный. Угу. Есть второй атрибут ссылка, который может быть в обратную сторону смотреть. Можно их связать там и так далее, но это именно два разных атрибута, да. И оба, как бы, имеют нужно понимать, что.
**Анатолий:** Понятно. То есть, в первую очередь мы должны говорить от должны, как это, держать в голове, что э-э нужно очень хорошо знать, как устроена ваша платформа с точки зрения определения объектов, да, да, и операций над свойствами данных объектов. Правильно?
**Георгий:** Да, вы правильно говорите. Это вот как раз-таки база, которая должна, ну, должна в голове уже быть прямо. Ну, у нас её нету. Вот сейчас мы до неё дойдём, как бы, и ну, есть определённые сложности, да, на них остановимся, наверное, дальше. Ой, ну давайте третье задание мы опять же триплеты просто сделаем из нашего, да. То есть, что у нас получилось по стрелочкам. Ну, давайте без ури, без всяких, просто попробуем. Ну, там, если. Ну, давайте так, карандаш. Давайте писать без юри. Понятно, что. Давайте, как у нас. У вас там решётка карандаш, да.
**Анатолий:** Так уже не проходит, уже не проходит.
**Георгий:** Не, правильно, правильно, правильно. Решётка пенал, согласен, да.
**Анатолий:** Решётка пенал или пенал решётка, я забыл.
**Георгий:** Давайте просто уже не будем мучиться с решётками, да. Давайте.
**Анатолий:** Пенал содержит карандаш. Угу.
**Георгий:** Ш. Ага. Дальше у нас будет синий карандаш является карандаш. Дальше пластмассовый пенал является пенал. Ну, и, соответственно, пластмассовый пенал содержит карандаш. Супер. Я просто вначале забыл, что мы стрелку перевернули для графа. Всё, красота. У нас с вами модель уже вырисовалась. Ну, можно начинать работать, в принципе.

Так, ну, и теперь начинаем самые большие интересные темы, да, касающиеся нашей базы, да, а и построение запросов. Ну, начнём с в принципе, да, чтобы строить запросы, нужно понимать, как в базе лежат данные. То есть, фактически, как бы, как я уже говорил, да, наша база представляет собой как раз-таки **RDF-граф в нотации NPLE**. А, то есть **все данные, которые у нас хранятся, – это данные в виде триплетов**. То есть, ну, набор тройных записей, так называемых ресурсов или ури, которые, как бы, в платформе рождаются в тех или иных неймспейсах. А, ну, пространствах имён, да. Пространство имён много, по модуля и там, по модулям, в общем, разбиты они по разному. Соответственно, отдельные модели, которые именно системой определяются, **системные**, так называемые, **модели**, да, они хранятся в виде наборов файлов с **расширением N3**. А они даже, наверное, в конечной сборке, как бы, в их можно открыть, посмотреть. То есть, я думаю, даже присутствует.
**Анатолий:** Ковырялись, наверное, да, смотрели уже.
**Георгий:** Смотрели, да, да. Понятно, это молодцы, не каждый так на то, на это способен. Вот. **Прикладные данные**, соответственно, прикладные метаданные и данные, то есть, ваше описание, да, метаданные, которые вы настраиваете, шаблоны записей, процессов, и прочие – соответственно, это прикладные метаданные, и данные, их инстансы, их экземпляры, они уже хранятся непосредственно, как бы, в отдельном файле **датат**. Вот. Или там наборы файлов, неважно. То есть, э-э, и, э-э, также представлены в виде набора троек.
**Анатолий:** Это они это они у вас хранятся в SQLite или где?
**Георгий:** А, ну, смотрите, es – это всего лишь движок, да. Ну, да, да. Es – это всего лишь движок, как бы, который там позволяет, ну, причём излайта нужно понимать, да, мы взяли всего лишь навсего транзакционную, транзакционный движок, то есть, как транзакции вообще управлять. **Всю модель данных полностью, как их хранить, и так далее, то есть, вот это вот граф RDF, и так далее, его нотацию, его движок именно работы с этими данными, то есть, весь logic, который, как бы, сериализует из э-э фактов там, из триплетов в какие-то реляционные данные, и обратно на формы, и так далее, да, это всё написано нами. То есть, фактически, вот на это получены патенты и так далее**. Именно это и защищали. То есть, не СУБД, да, сама именно запатентована, а именно принципы хранения и работы с данными. Угу.
**Анатолий:** Понял.
**Георгий:** Вот, фактически здесь как раз-таки и есть новаторство. Всё, и, как бы, быстрота, и так далее, и так далее. Вот. То есть, э-э, ну, если мы возьмём, да, вот сейчас интересный интересный слайд, очень много полезной информации. То есть, э-э, ну, на нём приведён обычный, так называемый, класс задачи пользовательские, ну, те, которые у вас попадают в мои задачи, да, которые вы видите и исполняете. То есть, на каждого исполнителя они падают. То есть, это, по сути, создаётся вот такой вот классом, вот таким описанный объект, у которого есть, ну, сам класс относится, да, к какому-то контейнеру itemкласс, у которого есть там, как какие-то свойства из систм, там, что он системный является, что у него есть счётчик, что у него префикс какой-то, что у него там э-э системное имя там или алиаз, да, задано, и так далее. Вот. И также у класса есть вот набор свойств. Фактически это свойство там заголовок задачи, назна назначение на кого назначено, а исполнитель, а статус задачи, дата окончания, дата начала, до какого числа сделать, там, срок её выполнения, ссылка на объект э-э это как раз-таки вот объект схема, названием шаблон.
**Анатолий:** Нет, нет, нет, шаблон записи ассоциированный с задачей, да. Ну, то почему данные строятся, как бы, у задачи, там, свой набор, да, а ещё расширение, как раз-таки, в объекте полностью всё идёт.
**Георгий:** Вот. И и так далее. То есть, есть масса пропертей, да, масса свойств. И также есть вот, как видите, да, **функторы**, так называемые. То есть, это набор функций, которые. А функ, да, набор функций, которые, как бы, ну, методы, да, по-другому. То есть, есть класс, его свойства и есть методы. Методы, соответственно, как только вы к ним обращаетесь, они вычисляются на Литу. Ну, вот, например, метод для вычисления оценки времени, причём затраченного. Тут сейчас я посмотрю. Так. Остаток. Parent child. Он вычисляет. Так. Stat complete. Remain and work. И duration. Он берёт именно затраченное фактическое время на каждую работу. Вот если работа, как бы, не закончена, точнее, закончена полностью, если статус уже completed, как бы, не осталось остатка работ, то есть того, чего нужно, если нету у работы там каких-то ещё прентов, которые должны быть это тоже не это не закончено, и так далее, и так далее, да, то он вычисляет, соответственно, сумму всех дюрейшенов, да, и если ноль, то она, соответственно, ставит ему оценочную работу.
**Анатолий:** Вопрос, да, вопрос. Как этот метод вызывать?
**Георгий:** Что ещё раз? Как вызывать? Ну, подождите, сейчас доро до троек дойдём. Мы, как бы, ещё до них не дошли. Мы просто показываем.
**Анатолий:** У меня даже раньше вот то, что мы сейчас видим, вот этот красивый текст, да, а, ну, как для любого языка, это всё-таки, ну, скажем так, язык программирования. Ну, нотация, да, а в ней есть какие-то м-м, ну, скажем так, хотя бы хоть какие-то правила. А здесь получается, вот я вижу разные буковки, разные спецсимволы, а, и, во-первых, я не знаю, что, вот, если я вижу код на C#, я значит C# или C++, или даже на том же Питоне, или даже на джаваскрипте, хоть ну, на любом, а я понимаю, что это метод, либо это просто тело, то есть выражение, которое что-то сделает. Ну, то есть, действие в целом. То есть, ну, как вот э-э просто вот на на к странице, может быть. То есть, не не обозначено методом, а вот что мы здесь видим? Это декларация, что-то в воздух заявляется, и где-то это с кем-то сохраняется, и потом что-то произойдёт. То есть, вот, что это метод, это набор м-м управляющей конструкции, то есть, то есть хоть к какой области языков программирования там относится декларативные языки, э-э, там функциональные языки, там, ну, вот объектные, и вот, вот что это?
**Георгий:** Ну, давайте так, к синтаксису я сейчас перейду, да. На самом деле, как бы, ну, как у нас, да, любой там язык запросов, ну, если говорить про именно вот эту тройку, то это пока что лишь набор фактов. Здесь фактически вы языка никакого не видите, да. То есть, я могу немножко подробнее остановиться. Язык вот здесь возникает, где появились запросы какие-то. А здесь лишь говорится о том, что вот есть так. Ой, немножко перескочил. Что есть, ну, то есть, помеченные комментарием, да. То есть, у нас есть комментарий текст. То есть, говорит о том, что это класс именно описывает класс user task. То есть, у нас объявлен вот такой вот CMW user task в качестве субъекта. И он говорится о том, что он принадлежит а э-э принадлежит. Это зарезервированный предикат а CMW-классу. Дальше запятая. Это перечисляются именно уже объекты, которые с употребляются с предикатом одним, да. То есть, через запятую синтаксис вам перечисляет именно объекты. Ну, то есть, это вот если взять вот вот эту вот первую строчку, её можно разложить на три э тройки други, как бы, как как синоним, да, аналогичные. То есть, CMW user task A CMW class. CMW user Task A container item class. CMW user task A object app. То есть, это говорит о том, что класс user Task он принадлежит к трём, как бы, каким-то отдельным, да, вышестоящим классам. Дальше через точку с запятой у нас уже подменяются к субъекту пары предикат и ээ объект. Понятно, да? Тут. То есть, мы дальше следующие, как бы, строки мы разбавляем к каждой из них. То есть, то, что через точку запятую ещё субъект. То есть, CV user task имеет а parent class как serializable. Ну, то есть, он стерилизуемый. Дальше у нас, соответственно, есть свойство, что он системный, да. У, соответственно, дальше есть у нас свойство, что у м-м этот имеет счётчик ээ, что у него отсутствует там, ну, или пустой префикс, что у него он относится к, точнее, не относится, а AS имеет там подчёркивание user task. Ну, и так далее. Соответственно, это описание класса. Это всего лишь набор, как бы, троек, которые, как бы, ну, нужно просто-напросто это согласно аа синтаксису прочитать. Ну, фактически, как бы, я вам уже рассказал, да, синтаксис, который, как бы, как разделяет, что, ну, и object property та же самая. То есть, у нас появляется предикат проти, который, как бы, через запятую фактически перечисляет объекты. То есть, или наименования пропертей, которые у этого класса существуют. Вот. Ну, тут два вида пропертей есть Object Property, есть CMW Property. Вот. Разделение здесь я вам не скажу, как оно делится, по какому принципу, да, здесь я не совсем даже, как бы, владею этой информацией. Вот. Но в любом случае, да, у вас набор пропертей, вот он как раз складывается из всех пропертей, которые здесь есть. То есть, не всех свойств, которые, как бы, вы увидите, а дальше у каждого свойства, да, может быть, вот, например, мы взяли CMWS. Вот он в качестве объекта объявлен, что такая проперти есть. Она, соответственно, тоже раскладывается. Ну, то есть, из них вообще каждая будет раскладываться, если мы посмотрим этот пакет, а на определённый набор троек. То есть, у каждой у каждого свойства есть свой набор свойств, да, что относится к object, что, а у него есть имя вот с таким вот префиксом, точнее, вот с таким вот объектом, с таким наименованием. Что наши проперти исполнитель также а описывается вот вот в этой вот константе, да, и, соответственно, как-то тут всё реализуемо, да, и как оно сериализуется, и там какой у него лиаз, и так далее. Вот. И последний уже синтаксис языка пошёл, да. Я мы до него дойдём.
**Анатолий:** Извините, вопрос. Значит, смотрите, когда вы я понимаю, что там вы описываете некий верхний уровень, да, и, в принципе, как матрёшка можно может каждый и каждое из свойств раскрываться на на другие детали, да. Соответствует ли это некому аналогу э-э, ну, возьмём база реляционные, да, что у меня эта ссылочка на другую таблицу, да, ну, как бы, которая линк идёт на другую табличку и там у меня более точно расписано всё? Так или нет?
**Георгий:** Да, можно так это назвать. То есть, фактически, ну, тут, да, табличек нету, вот, нужно понимать, что, как бы, у вас именно свойство на свойство, да, это именно раскрытие в другой табличке. То есть, фактически, у вас есть таблица, там, например, да, user task, которое есть колонки, там, какие-то из систем и так далее, и так далее.
**Анатолий:** Второй вопрос. Говори. Второй вопрос. Вот я не первый раз встречаю вас вот это вот ээ, как вы говорите, определение котек платформ Taskни, ээ, но это внутри платформа где-то зашита или это я в каком-то из файлов можно найти в платформе? Я потому что такого не видел.
**Георгий:** Если вы про вот это вот, да, то это внутри платформы всё, да, это всё внутри платформы.
**Анатолий:** Это это в файле с расширением 3 я не найду.
**Георгий:** Ну, как сказать, вот это пространство имён, да, оно просто зарезервировано, вот именно как ресурс и всё. Вот оно, вот это объявление, да, это пространство имён определённое.
**Анатолий:** То есть, другими словами, вот я читаю тогда. Давайте верхнее читаем. Command V, да. Si - это имя property. Угу. Вот с таким вот именем. Дальше у.
**Георгий:** Это не вот первая строчка это относится. То есть, это принадлежит к объектам проперти, да, да, да.
**Анатолий:** А второе у меня идёт, что ээ - это property name, да. А вот это вот у меня вот так вот оно называется. Правильно я понимаю? Да.
**Георгий:** Ну, смотрите, вот видите, у нас есть такой вот структура записи как CMW двоеточие Sни. Угу. Как я в начале говорил, да, любое, в принципе, представление там триплета, да, это, как бы, набор тройной набор, точнее, тройная запись из ресурсов. То есть, на месте каждого из аргументов присутствует ресурс. Так вот, вот это вот CMW и так далее, object, где тут ещё task есть, да, это всё синонимы. Фактически вот мы вот такую длинную запись, да, вот называем это КТП task. Объявили префиксом. После решётки всё, что идёт, это вот после двоеточия, а до него – это префикс. Ну, фактически вот вот вот это вот всё можно было заменить как task сайни. Вот и всё. И, ну, есть task сайни desрипtion тут ещё появился, как бы, после слэша такого ресурса, как бы, тоже можно префиксом объявить там, например, Sни его назвать и будет SCP. Вот. Фактически это ничем не вот этот ресурс ничем не отличается от вот этого вот, нужно понимать. Мы говорим про.
**Анатолий:** Хорошо. То есть, другими словами, мы говорим, что это у нас операция, да. Это у нас CMW S, а его имя – это вот HTTP и так далее. Так.
**Георгий:** Да. Это может быть константы какой-то. То есть, это ссылка на ресурс, который может быть константой где-то объявлен дальше, и, соответственно, мы просто-напросто в одном месте имеем возможность, как бы, там ей задавать наименование, да. Ну, локализа, как минимум, как локализация это работает. То есть, для английской для английской аудитории там по-английски показать, для русской по-русски.
**Анатолий:** Ну, понятно. То есть, получается, что у меня для ээ субъекта CMW и, да, угу, а вот я ээ слово присваивать здесь нет.
**Георгий:** Я говорю, что ээ вот если я напишу property description, да, то это вот вот вот так.
**Анатолий:** Да. Это вы определяете. Вы самостоятельно, когда вы моделируете базу, да, вы самостоятельно определяете полностью все предикаты. То есть, какие у неё могут быть, да, и как по каким правилам они живут. То есть, это вот модель, которую я вам показываю, да, это системная модель, которая вот для задачи именно так описана. То есть, фактически, что у нас есть user Task, да, у него есть набор свойств, и каждое свойство оно обладает ещё своими вот такими свойствами. То есть, у каждого свойства есть наименование desрипtion, оно, соответственно, ссылается на такой-то ресурс, ну, значение вот такое вот по такому-то ресурсу. А там уже может определяться тоже вычисляться каким-то образом ээ ээ там на основании локального на локальных настроек, да, языка. Понятно.
**Анатолий:** Вот теперь переходим к вкусному. Ну, то, что я начинал. Вот, вот у меня дальше идёт intask, да, да. А как я узнаю? Это же, я понимаю, те самые методы, правда?
**Георгий:** Да, вот давайте я чуть-чуть дальше всё-таки вот. Ну, здесь бессмысленно просто рассматривать. Здесь большой какой-то такая тройка, да, её нужно полностью разложить с самого начала, показать, как в принципе эти реза. Потому, потому что нужно с азов, так сказать, начать, да. Хорошо. Вот. Ну, я для примера ещё один привёл. То есть, всё то же самое, да, у нас вот пользователи наших системный класс, да, что есть пользователи. И, соответственно, пользователи тоже они обладают ээ, как бы, принадлежат к определённым классам вышестоящим, обладают такими же свойствами. Также у пользователя есть свои свойства, как user name, там, активность, full name, да, что у него менеджер есть, почтовый ящик, телефон, Skype, и так далее. И у каждого свойства опять же вот мы взяли user name, да, и его также разложили, что у него также есть свой набор атрибутов, свой алиаs, и так далее. Вот. И также есть набор метод. А, не будем заострять. Вот.

И следующий пункт как раз-таки уже пошёл как раз-таки рассказывать нам что такое **запросы**. Вот. Э-э, в принципе, все запросы, да, ну, как у нормального языка, они ограничены определённым **синтаксисом**. То есть, э-э, когда мы пишем тройку, когда мы пишем какой-то м-м запрос, да, у нас есть инструментарий там в виде каких-то зарезервированных слов ээ и конструкций. Ну, в данном случае, решётку, как я говорил, **комментарии**. То есть, это вот на экране такие основные используемые. Это не все на самом деле, там, собственно, их чуть-чуть больше. Вот. Но, как бы, те, которые в основном используются, и их вот я привёл.
**Анатолий:** Насколько насколько чуть-чуть больше? Раза в три, да?
**Георгий:** Ну, не сказать. На самом деле там, ну, знаки равенства, да, есть, есть некоторые, как бы, отступления там с с этим с собачкой, то есть, которыя позволяют вам задавать эти функторы. То есть, ну, это очень редко используемые вещи, поэтому я их там особо не перечислял, поэтому, как бы, пока ну.
**Анатолий:** Вы знаете, если делать выражение и не знать, как равенство, неравенство писать, ну, здесь, конечно, уже сложнее будет.
**Георгий:** Равенство, наверное, да, я сюда зря не включил. Вот. Неравенство, как бы, это уже функции там, чуть-чуть дальше я функции ещё это в отдельной табличке покажу. Хорошо. Вот, собственно, м-м, ну, самые основные. То есть, у нас принадлежность к объекту – это зарезервированное слово. Его можно, как бы, использовать там, если вам нужно проверять где-то системную модель там на принадлежность к определённому классу. То есть, **присваивание значений** из одной переменной в другую. Есть понятие **префикса**, как я уже говорил, это объявление вот этих вот урлов длинных, чтобы не длинные префиксы в запросе не не писать, да. Есть понятие объявления **переменных знаком вопроса**, да, когда вы перед каким-то лати на латинице обозначенными а цифро цифробуквенным сочетанием, да, можете, как бы, любую переменную задать. Потом есть, как бы, обязательный **терминатор триплета**, когда любой триплет должен заканчиваться именно **точкой**. А, соответственно, **формулы** у нас в **фигурные скобки**, в **обычные скобки** у нас объявляются так называемые **списки** или **массивы**, да.
**Георгий:** И есть.
**Анатолий:** А что такое объявление формулы?
**Георгий:** Это как раз-таки тот запрос, который у вас должен выполняться независимо. То есть, фактически, вот вы когда начинаете писать тройку, да, после префиксов у вас идёт открытая скобка и закрытая скобка. И в в этой скобке, да, у тебя 23 плет будет выполняться в в едином ключе, да, и он наружу выдаст, как бы, результат единый. То есть, я просто дойду сейчас до итераторов и покажу, как бы, как с чем это связано. Вот. То есть, а.
**Анатолий:** Точка запятой. Точки запятой нету? У вас она в тексте есть.
**Георгий:** Ну, это в фактах, это не в запросах. То есть, в запросах не это отсутствует запятая точка запятое, но в запросах не фигурирует. Вот. Есть **неявное использование субъекта** – это чтобы можно было сокращать там тройки, да, например, если вам нужно по объекту быстро найти субъект, он, как бы, возвращается вот в таких квадратных скобках. Ну, не совсем понятно. Я думаю, потом.
**Анатолий:** Да, да, да. Я, как бы, может быть, на опережение, но неважно.
**Георгий:** Вот давайте дальше. То есть, фактически все запросы, да, у нас также они в виде набора триплетов присутствует, ну, в смысле, пишется, и, а, у каждого запроса, да, всегда есть на вход какие-то данные, есть, соответственно, на выход. Каждый запрос он выполняется исключительно **последовательно по каждой строчке**, то есть, сверху вниз, а в в **итеративном порядке**. А, то есть, у нас результат первого первой строчки он, соответственно, если вернул несколько там итератор вернул несколько значений, он на следующую строку перейдёт сначала с первым значением отработает, да, вторую строку, затем возвращается обратно, переключается на вторую на второе значение и опять начинает по кругу все стройки перебирать.
**Анатолий:** О, это важно, да.
**Георгий:** Это очень важно. И это нужно понимать. Сейчас мы дойдём как раз-таки вот за это отвечает отдельный механизм, так называемый, да, который как раз-таки процессит все запросы. Ну, если мы рассмотрим, да, нашу тройку там, любую, какую мы написали, то есть, вот у нас есть наш код, который мы напишем, да, там, который на вход что-то получает. Ну, вот, например, **вычисляемый атрибут**, да, все, наверное, писали, все видели, да, знаете, что **item** там на вход ли, на выход. Фактически этот вычисляемый атрибут при сохранении в базу оборачивается вот в такую конструкцию **in item**, да. То есть, что на вход у него подаётся item, то есть, объект, ID объекта текущего, а на выходе у вас атрибут **value**, да, value фактически превращается. То есть, как как только система обращается к этому атрибуту, она понимает, что это функция. У вас атрибут нехранимый. Если, да, то есть, если вычисляемый, он нехранимый, и он всегда вычисляется в момент обращения. То есть, он понимает, что как только вы использовали атрибут value в качестве предиката, да, пытаетесь получить его значение, то он понимает, что это функция. Он по этой функции подаёт ID объекта на вход, дальше выполняется внутри ваш код, и, соответственно, на выход он возвращает, которая, как бы, уже а-а выводится в на интерфейс, там, куда необходимо, а где необходимо отобразить наши вычисляемые значения атрибута.

Соответственно, есть четыре вида запроса, коллеги, все видите, да.
**Анатолий:** Да, да, да, да, да.
**Георгий:** То есть, мы, да, триплеты, в принципе, да, они позволяют наш ризонер позволяет выполнять вот такие вот четыре вида запроса.
1.  **Первый вид запроса**, когда у нас объявлен понятен субъект, когда у нас понятен предикат, и при этом у нас отсутствует, ну, нам нужно найти э-э объект.
**Анатолий:** Вопрос, простите за глупый вопрос. Я обязательно ставлю или как?
**Георгий:** Нет, это всего лишь-навсего переменная. У вас это я, как бы, обозначил вопросами, да, неизвестная. А это неизвестно.
**Анатолий:** Это четыре вида запроса? Это это это фигура речи, да?
**Георгий:** Это нека схематичное обозначение всего лишь-навсего триплетов, которые у нас фигурируют в запросах. Ну, то есть, давайте я сейчас чуть-чуть назад вернусь, да. Вот возьмём мы, например, да, описание нашей аккаунт А CMW класс, да, или, ну, например, из system true, да, вот account cm true. Вот, например, если мы хотим, да, давайте вперёд. Вот. То есть, если нам нужно для определённого класса, вот для нашего аккаунт accountу, да, найти, является ли он системный, то мы пишем здесь, здесь пишем, соответственно, system наш предикат, да, а здесь мы ставим переменную. Если эта переменная, как бы, ещё не определена, то он как раз-таки пойдёт в базу. Он найдёт пару тройку, точнее, которая соответствует заданному субъекту, заданному предикату, и в э в объект в переменную поместят итератор, который будет содержать все найденные значения, совпадающие с субъектом, заданным субъектом и предикатом. Это понятно? Угу. Вот. Аналогично обратная ситуация, да. А вот если вот собственно говоря вот.
**Анатолий:** Понятно, что произойдёт дальше, если просто у нас есть неизвестно, что мы должны найти субъект. А, хорошо. Вот на первом шаге мы нашли а по субъекту с предикатом нашли набор объектов. Так. Теперь, когда мы переходим к следующей строчке, как я понимаю, у нас ээ машинка работает.
**Георгий:** Сейчас дойдём, вы спешите. Я просто если мы в качестве в качестве той же самой переменной, та той же самой переменной под за вопросиком напишем ту же самую переменную, что была в там вопросике, тот же предикат, но уже конкретный объект просто, ну, с потолка возьмём, ну, подходящего класса, что у нас получится?
2.  Получится **третий вариант**, когда у нас есть и субъект, и предикат, и объект. То есть, мы фактически говорим о том, что у нас переменная так как уже объявленная, она уже определённое значение принимает, соответственно, она будет по третьему варианту она будет **проверку наличия факта** по заданным аргументам. То есть, она будет true или false возвращать сам запрос. И если он вернёт фолс, то, соответственно, он дальше просто не пойдёт. То есть, у нас вот как раз-таки включается уже третий вид. То есть, первый вид – это поиск объектов, второй вид – это поиск субъектов, третий вид – это матч, то есть, того, что у нас все аргументы триплета заданы, да. То есть, что действительно в базе есть вот такой вот вот такая тройка, которую мы объявили.
3.  И **четвёртый** – это, ну, такой он на самом деле немножко экзотический, когда у нас только предикат есть, да. Ну, например, атрибут какой-нибудь, да, вы хотите там по ID атрибута вычислить все объекты, где этот атрибут за.
**Анатолий:** Это не это самое нормальное. Если, конечно, дополнительные условия были выше заданы, например.
**Георгий:** Если дополнительные условия, то будет, то будет у вас работать один из двух. То есть, если у вас один изтов известен.
**Анатолий:** Нет, нет, нет, если все неизвестны, вот, допустим, запрос по всей базе данных. Нужно всех э-э всех, у кого есть супружеские отношения. Вот, пожалуйста, предикат женат, или там, говори, выдаст пары сразу же.
**Георгий:** Ну, на самом деле, он выдаст. Я не знаю, что он выдаст у вас. Он у вас отдельно мужин выдаст. Он выдаст в зависимости от того, куда у вас направление стоит, да, и он туда поместит субъектов. Возьмёт там, не знаю, мужей там, объектов Джон, или наоборот, да, ну, неважно. Но они, главное, они не будут связаны в паре. Они в паре не будут связаны.
**Анатолий:** А что значит не будут в паре связаны?
**Георгий:** А потому что он выдаст в результате наборы. То есть, слева будут какие-то наборы мужей, слева справа набо.
**Анатолий:** Нет, нет, нет, нет. Он, как раз-таки, выдаёт тройку, которая совпадает. То есть, он, конечно, он вам он вам только триплеты возвращает.
**Георгий:** Трои. Это уже хорошо. Всё. Это уже проясняет. А то зачем мне отдельно мужья и жёны? Мне нужно пары. Вот. Собственно, вот таким вот образом у нас производится поиск и матчинг результатов, который, как бы, точнее, у ризенера. А теперь вот как раз-таки перейдём к тому, как это работает, да. Ну, вот, например, у нас есть такая простая тройка. Вот. Ну, всем понятно, что она делает, да. То есть, у нас мы сначала берём, берём всех, отпираем всех пользователей, да. Потом мы в пользователе Иванов Иванов Иван Иванов, да, у пользователей ищем user name, и затем этого эти это этих пользователей, у которого Иванов Иван Иванович, помещаем в восходящее значение, а.
**Анатолий:** Да, кстати, вопрос: value – это резервированное, значит, резервированно?
**Георгий:** Да, да. Value – это резервированное, а мы – это в это в основном во всех во всех запросах, во все, ну, во всех точках использования, да, зарезервировано.
**Анатолий:** А можно короткий уточняющий вопрос? Вот, потому что вот всё оно прозвучало, но каждый раз не очень точно. То есть, мы когда проходим каждый раз, когда предикат, то есть, не предикат, а триплет заканчивается, точка стоит – это означает, что сформировано где-то, ну, скажем так, в каком-то пространстве облако, как каких-то триплетов.
**Георгий:** Итератор.
**Анатолий:** Итератор. Но итератор одного чего-то просто вот у нас как вот в первой строчке написано: аккаунт. Мы получили всех, да, а потом по эти же всех, ну, раз он определён, мы уже на него накладываем условия, что там Иванов Иван Иванович.
**Георгий:** Ну, вот смотрите, создаётся нумератор по всем пользователям первым. Ну, как я говорил, да, то есть, у нас исполнение тройка выполняется сверху вниз. То есть, сначала выполняется первая строка, затем, как бы, мы переходим ко второй. В первой строке у нас аккаунт, да, создаёт так называемый **нумератор**, нумератор по всем пользователям. Ну, то есть, он все, что в аккаунт аккаунт нашёл, да, все удовлетворяющие первые записи. Так как у нас аккаунт ни разу ещё не использовался в скрипте, соответственно, он неопределённая переменная и будет отрабатывать именно поиск субъекта по заданному предикату и объекту. Вот. Субъекты мы нашли. Всё. Мы, например, объекты аккаунт нашли. В следующем триплете у нас уже задан. Здесь он будет принимать значение. То есть, когда мы переходим к следующему триплету, а, он будет принимать значение первого пользователя из списка, из нумератора. Это важно. То есть, фактически, когда у вас аккаунт сформировал нумератор, дальше он работает уже с каждым пользователем по отдельности. То есть, следующая строка фактически она будет проверяться на валидность -э-э там по возвращённому первому пользователю. Если первый пользователь у нас имеет Иванов Иван Иванович, то есть, запись вот такая вот имеется: пользователь один, ну, то есть, прямо в базе, да, лежит: пользователь один, user name у него Иванов и и, то, соответственно, мы перейдём к третьей фак третьей записи. Если у нас Иванов и Ии не найден, если это оказалось результатом отрицательным, ну, то есть, вали – это выходной параметр. И если у нас это оказалось отрицательным результатом, то у нас переключается, вот, как видите, со второй строчки на следующего пользователя, и следующий пользователь у нас там пользователь два, уже его проверяется матчинг, и так далее, пока не закончатся все. Как только они все к концу подошли, у нас в, как бы, в будет сформирован набор прошедших проверку, да, на втором этапе аккаунтов. И результат будет дальше по это по, а, ну, там, в вычисляемый атрибут или куда-то ещё в.
**Анатолий:** Перетон. Сразу, если у нас это была бы как временная, грубо говоря, временная табличка. Мы сформировали, ну, временный набор. Мы потом дальше могли бы это передать в следующем на следующее условие ставить, где это бы выступало бы в качестве уже пускай объекта, в качестве условия каких-то предикатов. Ну, то есть, пускай не value было, а а там в назовём его накопили. Вот следующий пример, он.
**Анатолий:** Вернёмся обратно на секундочку, на секундочку. Смотрите, а если у меня Иванов и и не один аккаунт?
**Георгий:** Если не один, у вас вернётся несколько человек. То есть, у вас вю запишется столько людей, сколько в базе хранится, ну, записей, да, имеется в виду. Ну, правильно, да. Столько записей у пользователях, сколько у вас на будет найдено вот таких вот троек. То есть, вот фактически аккаунт будет переключаться и искать Иванова и по вот этому предикату.
**Анатолий:** Если другими словами, он пройдёт по всему нумератору, правда?
**Георгий:** В любом слу.
**Георгий:** Да, он пройдёт по всем объектам. Он пройдёт по всем объектам. Он, если дальше второго никуда не уйдёт, он здесь в итоге, когда до последнего он здесь зайдёт, он прекращает свою деятельность, и всё. У нас будет нал содержать.
**Анатолий:** Поехали дальше. У нас будет содержать нал. То есть, отрицательные результаты.
**Георгий:** Вот здесь немножко посложнее уже пример. То есть, здесь понятно, чего происходит. Тут уже конструкция Union появилась. Ну, и, собственно, объявление массива. Так. То есть, у нас в первом взяли все задачи, все задачи, да, user Task CMW user Task, то, что мы там рассма тривали вверху, да. То есть, мы вот, вот, вот прямо, как есть, каким пользователем. У нас так. Это у нас что? Скобка. Это у нас аре. Аре.
**Анатолий:** Объявление списк. Да. Список. Арей.
**Георгий:** М-м, так. Значит, мы говорим, что смотрим э-э этой задачи, ищем всех возможных исполнителей. Правильно?
**Анатолий:** Да, всех возможных исполнителей. И отдельно, и обычных, отдельных, и обычных.
**Георгий:** Исполните.
**Анатолий:** Назначенных, назначенных.
**Георгий:** Возможных и назначенных. И всех их помещаем в акаунт. Union как раз-таки функция, которая из эроя формирует объединение. То есть, она возьмёт и эту тройку, и эту. Если хоть в одной, ну, или в обеих что-то нашлось, то оно их объединит в один итератор. И на выходе у нас ээ получится в аккаунсах итератор, как бы, из и тех, и тех.
**Анатолий:** Арт этот - это что у нас?
**Георгий:** Арт - это пакет, ээ, который содержит функцию Union, которая как раз-таки это делает. То есть, это namespace определённый, да, тоже наш командеровский. Вот. Ну, описание функции, на самом деле, какое-то приведено в руководстве разработчика, поэтому там я здесь особо не это их не публиковал. Вот. Мы их там периодически пересматриваем, расширяем, ну, как бы, сейчас оно более-менее полное. Вот. Кстати, по ним появились уже быстрые это.
**Анатолий:** Где оно? Которая лежит в КБ, да?
**Георгий:** Да, да.
**Анатолий:** Оно старое лежит 34 35 ещё не публиковали, да?
**Георгий:** Да, да. Ну, значит, ещё будет там добавлено что-нибудь. Ну, а дальше понятно, оттуда смотрим, есть ли там Иванов Иван Иванович. Если что-то мы, да, соответственно, дальше у нас, как только эта функция отработала, она получила по А, ну, ещё раз, да. То есть, у нас все задачи получаем. Мы к следующей к следующему блоку мы переходим а с первой задачей. То есть, нужно понимать, что вот здесь вот в Task теперь будет первая задача. То есть, мы взяли задачу один, из неё вытащили полни, из неё вытащили SN, и поместили в Accounts. В Accounts теперь будет объединение и того, и другого. Фактически у нас тоже это отдельный итератор, который тоже в своём множественном значении присутствует. Дальше мы начинаем сравнивать.
**Анатолий:** Извините, тоже коротенько совершенно вопрос. Вот Union и написано true. Это подразумевает это Union all или просто Union?
**Георгий:** Union all. То есть, если дважды и там, и там был один и тот же человек, то он будет дважды присутствовать в выходных данных.
**Анатолий:** Да, всё правильно. То есть, distinct, а если поставить, если false, то будет distinct, как раз.
**Георгий:** Не пробовали, не в курсе. Честно скажу. Это, как бы, конструкция она, по-моему, ну, для соблюдения именно тройки, да. Первый аргумент – это массив, на неё подаёт. Второе – это предикат, а третье, ну, в смысле, массив – это субъект, предикат – это assert union, и true – это объект. Он всего лишь-навсего говорит о том, как бы, чуть-чуть, ну, я не знаю, на самом деле, если поставить, что будет. Вот. Но есть отдельная функция distinct, которой мы пользуемся. То есть, ну, это, как бы, вот именно так работает.
**Анатолий:** Ну, с учётом того, что я смотрел, а что у вас все основные на, как это называется, определения, которые с расширением N3 – это одиннадцатый, максимум двенадцатый год в комментариях так написано. Если, если, конечно, они модифицировались потом, то хорошо бы даты поменять. А если нет, то, значит, тогда понятно, там что-то сделали потом. Проще добавить, чем смотреть, как из этого выкарабкиваться.
**Георгий:** Не, ну, это понятно, да, замечание валидное. Вопрос в том, что сейчас, в принципе, вот в 3.6, да, очень сильно там доработанный набор как раз-таки предикатов. То есть, появились новые функции, там достаточно много уже там и в выраженьках было сделано. То есть, ээ там выражения уже более такие симпатичные стали. Угу. Вот. Соответственно, их даже оптимизировали как-то. То есть, можно даже уже попробовать без троек обойтись. Ну, как бы, в любом случае, тройки для особых экстремалов всегда пригодятся. Вот. Ну, по документации чуть-чуть позже мы будем ещё и заниматься. То есть, пока что я вот.
**Анатолий:** Я понял. Ну, я просто Валерию, если он присутствует, так, на всякий случай, хотя бы э-э, ну, вот после вот этого всего, если у вас есть, как, ну, пусть какая-то там альфа-версия хотя бы того, что в 35 сделано, да, вот там вот ээ под.
**Георгий:** В 35 ничего практически не поменялось. Вот 36 там большой шаг сделали, поэтому ну да.
**Анатолий:** Вот какие-то моменты периодически присылать, чтобы смотрели. Вот 36 я не уверен, что там вообще документатор ещё до этого дошёл. Хорошо. Хотя бы вот более актуально. Так. Смотрите, Георгий, значит, другими словами, у нас в конце мы получаем, что для все задачи, которые назначены на Иванова и Ии.
**Георгий:** Смотрите, да, это в конце то, что мы получаем. Это хорошо. Но здесь важно именно, как итератор работает. То есть, здесь детали, как раз-таки, дьявол кроется в деталях. Важно то, что у нас на первом шаге, да, ээ, когда сформировался итератор по задачам, у нас, переходя ко второму блоку, эта переменная принимает значение первой задачи из итератора. То есть, ну, как любой итератор, да, у него есть метод получить значение, ой, получить следующее значение, там, и там, открыть итераторы, да, и получить следующее значение. Всё. То есть, это вот так вот любой итератор действует. Оно не знает ни о количестве, ни о чём. То есть, сколько там будет, это неважно.
**Анатолий:** Вот вы тут Task имеете в виду, да?
**Георгий:** Да, да, да. То есть, при переходе на второй блок, у нас TASK принимает какое-то значение. Дальше, когда мы переходим на третий блок, у нас тоже принимает определённое значение. И когда у вас, например, вторая строчка не дошла до конца, или там мы отработали, ой, третья, третий блок, третий блок не отработал, там вернул false, или там четвёртая строчка отработала, у вас в первую очередь будет переключаться именно account, потому что он ниже. И он, как раз-таки, сначала будет перебираться по аккаунтам. Вот. Стрелочку вы видите, да. Сначала у нас итератор переключится со второго с третьего блока на второй. То есть, фактически, мы нашли там два-три аккаунта, да, то у нас третий выполнится сначала с первым аккаунтом, потом вернётся на второй.
**Анатолий:** Смотрите, правильно ли я вас понимаю, да. А, ну, выбрали все задачи, да. Угу. Дальше начали выполнять первую строчку, та которая possible. Так. Ну, продолжайте. Как только нашли первого, мы сразу уходим на третью.
**Георгий:** Нет, мы уходим на Правильно. Мы должны там всё сделать, потому что там выражение немножко не так. Немножко не так говорю. Смотрите, я правильно пони. Тогда мы потому что вы же говорили, что вот это это формула, правильно? Я да, более сложную конструкцию вам просто показал. Как раз-таки вот здесь вот вот объединённая, да, массивом assert union true, она выполняется как единая. То есть, фактически, он выполнит вот эти два, да, с одним и тем же таском. Вот эти два выражения и s объединит. И он на выходе даст просто вам акаунтс, как бы, итератор один. То есть, вот это вот блок второй, да, его воспринимать вот эти вот эти две тройки их как единую. То есть, фактически, они выполняются под единым таском, да, под единым значением, и формируют один результат в качестве пользователей, которые, как бы, в двух, значит, в двух атрибутах лежат, да, в двух предикатах. И потом он возвращается на следующие возможно, да. И потом он и как раз вот этот итераторs, да, он уже пойдёт на следующий. То есть, когда мы на следующий блок переходим, у нас этот итератор, как бы, принимает первое значение. Task принимает тоже первое значение. И countс принимает первое значение. Как только мы ээ проитерировали по всем аккаунтам, то есть, он возвращается на этот, получает следующее значение count, и опять переходит сюда. То есть, он, как только нашёл или не нашёл Иванова, он бы, соответственно, этот проитерировал всех аккаунтов. Как только дошёл до конца, у нас происходит переключение уже Таски, и для Таски второй опять начинается цепочка итерации по аккаунтам.
**Анатолий:** О, понятно. Это вот это важный момент. Это очень важный момент с точки зрения оптимизации, это очень существенно.
**Георгий:** Так отсюда и выходит, вообще, отсюда исходят, в принципе, все методы оптимизации троек. То есть, другими словами, мы берём самый самую первую пользовательскую задачу.
**Анатолий:** Так. После чего, да, самую первую пользо, ну, не мы берём, да, итератор, ну, система берёт.
**Георгий:** Ну, я мы это система.
**Анатолий:** Система начинает итерировать по ней, да.
**Георгий:** Да.
**Анатолий:** Значит, для этой задачи находит всех возможных и назначенных, объединяет, правильно?
**Георгий:** Да.
**Анатолий:** Дальше смотрит, есть ли там перебирает каждого.
**Георгий:** Перебирает каждого в их списке, да. Каждого из них сравнивает.
**Анатолий:** О, как всё запущено-то. То есть, это такой цикл получается своеобразный. Цикл в цикле, да.
**Георгий:** То есть, если у вас ещё переменных добавляется по ходу, то по каждому будет строиться свой итератор, и каждая будет итерироваться внутри. То есть, чем глубже вы уходите, тем, как бы, у вас наверх будет раскручиваться это.
**Анатолий:** Ну, то есть, дальше смотрите, здесь а ресурсов немного на это тратится.
**Георгий:** Нет, на самом деле здесь, как раз-таки, ну, любая база данных примерно так работает. Здесь везде индексы, во-первых, да. То есть, как я там в начале указывал, да, то, что именно вся база ммм по всем ресурсам именно ссылочным вот таким вот она строит индексы. И фактически, когда у вас производится какой-то поиск, она идёт именно по индексам. То есть, здесь достаточно быстро. Вот. Ну, любая СУБД, она ж, как бы, примерно так же работает, что индексный, что хэш, ну, обычный поиск, который полным перебором, то есть, он по такому же принципу ведь идёт. Вот. Только у нас немножко транзакции на одну ступень меньше. То есть, мы не таблички тут не табличками оперируем, а именно оперируем свойствами. То есть, мы от одной вершины графа переходим к следующей, да, и её итерируем, потом следующей, и так далее, и так далее. Да, вы правы.
**Анатолий:** Это это, как раз, самый стандартный, самый классический loop join. Inner loop join.
**Георгий:** Ну, вот. То есть, вот, ну, по смыслу. То есть, условия ставятся, и идём по. То есть, мы делаем а слияние, и при этом, идя от основной, от основной. То есть, не через хэш, не мач джойны, то есть, как бы, чтобы идти наоборот от, как бы, выстраивая, потому что мы могли бы, в принципе, вообще всех для всех заданий изначально построить возможных и назначенных, и соединить это с заданиями, и выдать эти задания. Ну, то есть, развернуть задачу, если бы это чисто в реляционной алгебре решать. Вот. Ну, ну, вот здесь вот, вот, вот здесь как раз-таки существует большой потенциал там, да, для оптимизации всех запросов. То есть, **чем меньше вы получите запросов на первых строчках, ну, точнее, результатов на первых строчках, чем меньше значений итераторы у вас сформируют на первых строчках, тем легче будет выполнять весь скрипт, тем быстрее оно будет выполняться**.
**Анатолий:** Да, да.
**Георгий:** Потому что если вы, например, получите сначала всех пользователей, да, вот просто вот такой записью, вот, а потом пользователи начинаете, начнёте сравнивать, то у вас итератор в любом случае построится сначала по всем пользователей, потом просто будет матчить. А на самом деле достаточно вот, ну, в нашем примере это просто взять прямо написать, что account user name Иванов. Всё. Найди мне вот всех, а потом, а потом, а потом найти по нему где, либо он в тасках практике оса, либо это.
**Анатолий:** Перевернуть запрос.
**Георгий:** Перевернуть запрос. И тогда всё станет просто залетать, потому что аккаунт аккаунтов гораздо меньше. Вот. А как бы, ну, вот как раз это пример, да, того, что люди часто на самом деле идут как раз-таки заходят с того, что как в реляционной базе from, да, пишут сначала, вот, а потом VR начинают делать, и здесь как раз-таки нужно немножко осмысленно подходить к этому и переворачивать.
**Анатолий:** Да, да, да. Ну, мне мне понравился этот пример. Как раз, когда если удаётся догадаться, что это надо сделать по-другому, это хороший пример. Понятно.
**Георгий:** Вот. Ну, и вот, собственно, самые полезные конструкции, да, которые есть. То есть, первый же это вот **возвращающий ID атрибута** прямо такой вот очень полезный, который везде практически нужен, который по, ну, передаётся массивчик, в котором первое значение – это, да, это алиас шаблона, второй – это алиас атрибута, и finder blade. Понятно, да.
**Анатолий:** Вот если честно, вы бы вы бы слово добавили, вы там те мплейтами, ну, да, ладно. Потому что тем для меня это темпера, поэтому.
**Георгий:** Ну, да, да. Я уже не осознал, когда вы сказали. Так. **Wanz** выходит после первой успешной операции, да. То есть, если мы вернёмся назад, да, то есть, если мы вот, например, здесь написали бы ones, да, в приперерум же, то он найденный первый же задачу её бы проверил. Если она подходит, написал бы value. Если не подходит, то всё. Он бы вышел бы, и всё. Мы тогда бы написали, как tas. А, ну, то есть, не, ну, имеется в виду, что как только первый успешный результат достигнут, он выходит. Ну, тогда это нужно писать нс, а дальше в скобках вот предыдущую первую строчку, правда?
**Георгий:** Ну, здесь смотрите ещё раз. Вот если мы напишем и обернём только таску, да, первую задачу возьмёт, да, то у вас нужно понимать, что Так где, где, где, где мышка? Что-то у меня мышка сломалась. Поболтать туда-сюда, она нет, она что-то вообще отключилась, да, накрылась мышка. Ну, ладно, клавиатурой буду. А то есть если мы поставим при это на первой строчке, то он действительно найдёт первую задачу, и он, когда пойдёт дальше, он, соответственно, как бы, ну, она удовлетворяет или не удовлетворяет. Просто он либо тру или, ну, в смысле, либо её поместит, либо нет. А если мы соберём весь запрос, то нужно понимать, что он дойдёт до конца только тогда, когда хоть один пользователь удовлетворит. То есть, он одного пользователя всегда получит. То есть, зависит от того, что вы обернёте в скобке, да, такой результат и будет. То есть, либо у вас тут, как бы, на первой же таске долпустоту нужно получить, либо вам нужно именно одного пользователя найти хотя бы. Вот тогда он, как бы, вот. То есть, он даже и второй, и так далее. То есть, он все итераторы обрубит. Он именно на выходе должен один одну строку в в это, ну, то есть, понятно, да, что он итератор, как только дошёл до конца скобки и выполнил её успешно, то всё, он завершает.
**Анатолий:** Не, не, понятно. Понятно. Ну, всё так.
**Георгий:** Дальше что у нас ещё там? Так, ну, это нужно смотреть, как они написаны, да. Оры, соответственно, аналогично. У вас выполнится либо в внутри первой, либо внутри второй, и так далее. Их там неограниченное количество. Они все завершаются точкой каждый или все?
**Георгий:** Всё. Ещё раз. Вот если у нас первый не дошёл до конца в скобках выражения, да, которые у вас написано в фигурных внутри первого ора, то он переключается на второй. Если внутри второго не дошёл до конца, то третий.
**Анатолий:** Так, это значит, в конце поставит на ор в всё? Да? А если он на первом же остановился, он там нашёл значение, всё, он во второй, третий и четвёртый не заходит.
**Георгий:** Понятно. Это вот важно, потому что, когда люди пытаются он под минитёром, это не работает. Угу. То есть, он не вернёт множество. Он вернёт только там, где успешно прошёл.
**Анатолий:** Понятно.
**Георгий:** Так. Условный. Понятно. Такая. Понятно картинка. Так, так, да, тут важно в условном очень важно то, что **если у вас нету блока и у вас то есть if не выполнился, то у вас отключится вообще всё**. То есть, он считает, что тут это не конструкция, да, языка, что если за нету, то программа дальше идёт. А здесь он считает, что этого так как этого триплета нету, значит у вас, как бы, всё, ошибка какая-то. То есть, вы не описали.
**Анатолий:** Это значит, что там false вернула?
**Георгий:** А, понятно, сказал. То есть, я не могу if then писать, обязательно. Понятно.
**Георгий:** Если у вас, да, нужно продолжать, если вам нужно прервать вообще, тогда else не указываете, да, у вас просто в нул вернётся. А если у вас есть какое-то возвращаемое значение, то в обязательном порядке указывается, да. Так, типа список, да. А вот, вот предыдущему то, что про синтаксис, а насколько сама среда дружественно помогает? То есть, вот, как, вот, есть там, вот у вас достаточно неплохо пока показывает ошибки C#. Иногда, конечно, ошибается, но он показывает.
**Анатолий:** Не, он просто может показать ошибку, которой реально нет, и всё будет работать, да.
**Георгий:** Это было это с неймспейсами, особенно там проблема есть.
**Анатолий:** Неймспейсы и скрытые объекты, которые нигде не описаны. Э, ну, например, а-скрипт, вот они вот. Ну, это это нормально. Вот я уже привык. А вот ээ, вот здесь помощь в принципе при написании. То есть, что он сможет мне показать, что я даже, допустим, фигурную скобочку неправильно поставил. Потому что я же могу попытаться сократить и наставить фигурны скобочек одну за одной.
**Георгий:** Ну, смотрите, здесь, как бы, с чем это связано. По Си-шарпу или по каким-то, да, существующим там, общеизвестным языкам, тут всё просто. Есть там стандартные библиотеки, которые позволяют, в принципе, в себя на вход получать какой-то текст и выдавать, по сути, привязанный к символам ошибки. Здесь всё просто. Здесь, как бы, нужно подключить и использовать. Наша же вот эта вот штука, да, она, соответственно, это как новаторство. Мы полностью самостоятельно пишем весь компилятор. И фактически, весь синтаксис, разбор синтаксиса, пометка ошибок, и так далее, и так далее. Это тоже на нашей стороне. Соответственно, здесь, насколько полно там сможем покрыть, настолько полно, как бы, настолько полно вы это и увидите. В настоящий момент в 3.6 там, как бы, такой шаг небольшой сделан. То есть, сейчас появился, как раз-таки, нормальный там компилятор выражений, нормальный компилятор троек, там, подсказчик по тройкам, по подсказчик по выражениям. Мы сейчас ещё проектируем там F4.0. Такой будет уже вообще более более красивый и более там э-э удобный редактор кода выпущен. Вот. Но это всё там требует времени, да, и, соответственно, как бы, ждите и, в общем, до вас это дойдёт.
**Анатолий:** Вопрос когда.
**Георгий:** Тут, пожалуй, я только так могу сказать.
**Анатолий:** Это говорит вопрос: когда дойдёт полная полнота. Я вот на первых этапах, да, гарантировать в любом случае не могу. Ну, то есть, ээ это. Ну, это с практическим применением всё придёт. То есть, насколько там плотно люди начнут этим пользоваться, насколько плотно они там какие-то проблемы найдут и так далее, и так далее.
**Анатолий:** Не, не, я другом. Я к тому, что, ну, как новогодний подарок 4.0-то появится или нет?
**Георгий:** Да, конечно, конечно, конечно. Это прямо у нас запланировано уже там жёсткоруется.
**Анатолий:** И у вас вообще к октябрю было понятно, что это вы уже не сможете вот к октябрю.
**Георгий:** И прямо мы стараемся. То есть, это вот середина октября у нас дата. Она объявлена. И прямо Ну, понятно, тру, простите, опять же, что в сторону отошёл, ээ, рисовалка нормальная будет процессов, а под нормальной рисовалкой вы что понимаете?
**Анатолий:** Ну, я имею в виду, что хотя бы ближе к Комундовской. Ну, то есть, чтобы там ээ можно было нормально их ставить. Они так чуть-чуть сдвинул строчку, и всё перекорежилось.
**Георгий:** Не успеем, не успеем. Она вот сейчас в проектировке, да, нас следующая будет задача на дизайн буквально, да, и, как бы, это пойдёт уже чуть-чуть дальше.
**Анатолий:** Понятно. Последний вопрос. Там много очень работы с предложением, кстати. А, смотрите, вы ещё там процессную часть же делаете для документирования процесса, да. Разработка процесса и так далее. Она-то будет в этом году или нет? Так.
**Георгий:** Если вы говорите про описательную, имеется в виду именно описание процессов, ну, там описание процессов, там, где, ну, условно, некий аналог Enterprise Pro to Architecture. Я бы так сказал, там, ну, я же помню ваши же слова, там, и слова того же Максима о том, что который Ивас Викторович о том, что это отд ельный модуль, который вы делаете, в котором можно будет всё это.
**Анатолий:** Отдельный продукт, я бы сказал бы, да.
**Георгий:** Да, да, да. Нет, вот, ну, отдельный модуль, вот продукт, вот который, соответственно, там, вот вы хотите до конца года, потому что вы даже не представляете, насколько не хватает нормальной вот этой вот ээ нормального документирования, потому что, ну, как, особенно при командной работе, групповой работе, при нашей удалёнке, так, с пользователями, там, с участниками процесса обсуждать, ну, понятно, да, как там инструкции все эти создавать, как писать всю эту историю, потому что получается, что каждый у себя в голове начинает хранить. Вы никогда не задумывались о том, чтобы нарисовать для формы э маленький BPMN процесс, где будет чётко расписано, что, где, когда, потому что при сложной форме там так и получается: в зависимости от кучи условий, от разных условий, там разные могут появляться там объекты на форме, а по-разному потом процесс пойдёт, и так далее, и так далее. И это, в общем-то, такой достаточно серьёзный процесс, и его надо будет описывать где-то отдельно, где-то писать, ну, в общем, это вот это я так просто высказался. Поэтому очень хочется, чтобы оно появилось. Всё.
**Анатолий:** Пойдёмте дальше.
**Георгий:** Ну, давайте, ответа не ждёте, да.
**Анатолий:** Не, не, я это я просто крик, это крик души.
**Георгий:** Так. Теперь select и прочее. Я так понимаю, Vlist – это переменная типа список, я так понимаю, да.
**Георгий:** Это говори.
**Анатолий:** Да, это просто переменная. Это на выходе будет массив.
**Георгий:** Именно вот, вот, как вот считаете, что вот вот эти вот круглые скобки, да, да, что ж такое-то? Возьмите у кого-нибудь мышку. Вот. Считайте, что вот круглые скобки в первом же первой строчке, да, это вот, как бы, массив, который из нескольких значений состоит. Вот лист она возвращает именно массив, и она, главное, что не. То есть, нужно понимать, что тут не будет итератора. Вот лист – это массив, который имеет именно одну итерацию, да. Он полностью как массив переменную хранит.
**Анатолий:** Нет, ну, это понятно. И название переменных это здесь чисто условное.
**Георгий:** Ну, здесь важно, что, то есть, когда вам нужно работать именно с пакетом данных, да, потому что итератор он, как раз-таки, когда вы переменной обращаетесь, он берёт из итератора значение по одному. То есть, в конкретный в момент времени, да, запрос выполняется запрос с конкретным значением, а если вам нужно именно с пачкой данных поработать, вот здесь, как раз-таки, и полезно. Ну, например, просуммировать, да, вот сумма работает, как раз-таки, с листом. Она вам на выходе, то есть, если вы, например, сумму сделаете просто переменную, не не лист, да, то она вам просто вернёт набор там тех же самых значений итератора, которые, как бы, в единичном значении на каждый каждый раз, переходя к сумме, будут.
**Анатолий:** Ну, вот здесь у вас только маленькая собака зарыта. Ээ, если мне память не изменяет, для того, чтобы я ту же сумму оператора, это мне нужно не забыть ээ правильно обозвать, не обозвать, а вставить строчку, где будет сказано, откуда я беру вот эту математику.
**Георгий:** Да, вам сначала нужно собрать все числа, которые, как бы, сформировать именно список, или что.
**Анатолий:** Математику объявить, что функция у меня берётся оттуда, что масс и там вверху должно быть а.
**Георгий:** Ну, имеется в виду префикс правильный задать, да, есть масс наш, есть масс, который вытриорковский. Их там два тоже, это тоже, да, особенность. Ну, и вы её уже знаете. То есть, объявление префиксов оно тоже, как бы, важно.
**Анатолий:** Ну, да, я, кстати, не могу понять, но, опять же, никто не может мне сказать, где что лучше. Я, правда, не спрашивал.
**Георгий:** Вот не. У нас просто есть отдельные операции, которые работают с другими типами. То есть, в Патриорговске он работает там с числами, да, в основном, по-моему, даты ещё там у него как-то, а у нас ещё там длительности, там строковые и так далее. Он как-то под как-то отдельно ещё там это больше меньше может тоже стро также assert, наверное, где-то у нас тоже определён скорее.
**Анатолий:** Assert – это только наш.
**Георгий:** То есть, вот он как раз-таки и и каунты содержит, то есть, по количеству, чтобы можно было вводить, и, ну, всё, что необходимо, собственно.
**Анатолий:** Понятно, понятно. На прикладном уровне.
**Георгий:** Ну, и Union вот тот же самый, да. То есть, у вас массив должен быть формул. В каждой формуле у вас должна быть переменная одинаково названа. И он тогда эту переменную просто объединит. Угу.
**Анатолий:** Вот у меня я собственно предложение-то не успел озвучить, если не сложно может может быть мы где-то 15:00 до четырёх сделаем перерыв.
**Георгий:** А у нас уже всё. Я думаю, я вам сейчас задачу А нет, ну, наверное, сейчас я посмотрю, сколько. Я-то хотел как раз задачу. Вот смотрите, там я не знаю, доводил до вас Валерий или нет, но вот есть такая очень насущная.
**Анатолий:** Тут ещё немало тут задания, да, да, да.
**Георгий:** У меня просто есть ээ вот нормальная совершенно задача, которую хотелось бы понять, как решить. А, значит, у меня есть список активных приёмов на работу, угу. И он у меня определяется, собственно, там, либо кандидат принят, либо кандидат не принят. Ну, это вот я делаю просто в настройках списка. Но на самом деле, на самом деле, вот, если не равно вот ни одному из этих двух значений, значит, что он активный. Но дальше в процессе пути выяснилось, что там ни одна собака смогла подрасти, и, соответственно, часть задач пришлось снять, ну, остановить, да, сделать процессу. Угу. Да, они по системе я вижу, что процесс снят, но они у меня всё равно в списке показываются. И меня кадры мучают, потому что они видят этот список активный, говорят: "А что с этими?" Я говорю: "Они сняты." "А уберите." А я не знаю, как их убрать по статусу ограничить. А где я статус возьму?
**Анатолий:** Ну, у каждой задачи есть статус. Правильно? Он где у нас определяется? В 3, правда?
**Георгий:** Да.
**Анатолий:** А вот я не мог, не смог найти кусочка, где у меня вот условно, если вы мне вот возьмёте и вот на экране там, ну, условно скажете, что вот вам нужно проверять вот на это, что статус процесса, допустим, да. Потому что я могу, ну, вот у меня как? У меня есть ээ так у меня есть шаблон записи, у меня есть запись ассоциирована с конкретным процессом, да. Она же и с задачей ассоциирована.
**Георгий:** А с какой? Ну, с той, которая вам нужна. То есть, у вас запись по объекту есть. Текущая задача в C# есть такой метод получить текущую задачу.
**Анатолий:** Соответственно, смотри. У меня задач уже нет. У меня процесс консолидирован. Георгий, смотри, сце. Какой статусы? Наши прикладные. Они идут там, не знаю, на подписании. До этого, не знаю, при приёма. Они руками зашли в экземпляр и нажали заканцелить. У тебя по этой кнопке никакой статус бизнесовый не поменялся, да. А он, как бы, нужно исключить его из списка приёмов. Угу.
**Георгий:** Вот это.
**Анатолий:** Да, причём там даже смешнее. Потому что у нас ээ А как? Ну, мы в своё время объяснили инициаторам, что они имеют такое право кнопки тогда уже не ну не было кнопок специальных. Там было кнопки раньше были необходимы, ну, специально там остановить процесс, а потом, значит, с какой-то версией 35 там уже было сказано: "Нет, это прямо напрямую делается, и всё." Так вот они убивали процесс, который был запущен из основного процесса. То есть, основной процесс живой, его никак не собьёшь. То есть, я пробовал его удалить, он говорит: "А у меня ничего нет." Давай, давай, давай.
**Анатолий:** А, и вот тут такая получается несколько сложная задача, что мне надо найти процессы, вернее так, есть запись в шаблоне, да, у которой статус не принят и не не принят, да, вот. Ну, в смысле, вот два статуса убираем, вот какие-то другие статусы есть. Но у процесса, который ассоциирован с этой записью, у него он может быть снят сам. То есть, это номер один, тогда его не надо показывать. И у него может быть, ну, это же не порождённо, это же или порождённый, Игорь, как правильно сказать здесь? Тот процесс, который он запустил, связаны, связано, и причём он может быть связан с другой с другим шаблоном записи, ну, нет, ну, неважно. И связанный другой процесс. Вот, который консервирован. Вот этих, вот этих вот ребят мне надо убрать из списка. Вот, я не знаю, каким образом написать энтришку на эту тему, совершенно понятия не имею.
**Георгий:** Ну, давайте отдельно сядем просто и напишем. Проблем нет.
**Анатолий:** Вариант, да. А я вам добавлю ещё один момент. Вот. И надо с такими процессами, потому что я сам так убивал процессы. Ну, иногда просто тестировал и убивал. У меня ставки заканчивались. Я не мог потом тестировать, что заканчивалось.
**Георгий:** Не очень понял ставки.
**Анатолий:** Ограничения по ставкам. У меня не пропускал дальше процесс, потому что я убивал предыдущие полставки, выделял, ну, на выделялся, больше ставок не осталось.
**Георгий:** А это ваша бизнесовая логика.
**Анатолий:** Это бизнесовая логика.
**Георгий:** Если у вас ставки, как бы, там, не возвраща.
**Анатолий:** Это. А там аналогичное условие расчёта ставок должно быть. А тоже на то, что не должны учитываться те, которые ещё не приняты, или которые, ну, то есть, ну, которые выброшены. Про.
**Георгий:** Ну, да, сегодня. Давайте, коллеги. Я сегодня Александр написал концеп.
**Анатолий:** Ну, не сегодня, я не про это, а про бизнесовую идею. То есть, вы использовали плохой там паттерн, плохой сценарий. Убивать экземпляры процессов бизнес-пользователи вообще не должны. Если вы хотите дать возможность там инициатору директору в какой-то момент времени там, находясь между статусами B и C, прекратить приём, вы должны в этот приём вынести ему определённую кнопку, которая называется "Прекратить", дать на неё права, на неё написать там, не знаю, это будет какой-то запуск процесса, или это будет C#, или ещё что-нибудь, который сходит в бизнес-данные, вам убьёт сам эти процессы, да, там уже через месседжи скинет оттуда ставки и сделает всё, что вам нужно. И тогда у вас и тройки не потребуются.
**Анатолий:** Согласен. Игорь, согласен, что на самом деле э Валерия, это вот вам, да, э-э, что если честно, я бы вот хотел, ну, некую сессию провести с вами, ну, как с с как это называется, с высокоуровневыми консультантами, вот. Потому что какие-то моменты, вот мы на них уже, ну, не обожглись, а какие-то мы видим, что можно сделать лучше, можно сделать по-другому, а просто хотелось бы там, скажем, условно недели через две-три, так вот лучше две, конечно, сесть, э сказать: "Вот мы видим вот это" Какие ваши рекомендации? Что вы видите здесь неправильного с нашей стороны, неправильных подходов? Вот, чтобы чуть-чуть там мозги прочистили. Вот, вот это вот, как бы, просто пожелание. А давайте вернёмся к.
**Георгий:** Нормально или нет?
**Анатолий:** Валерий.
**Валерий:** Ну, Валери есть.
**Анатолий:** Ну, на это нормально, ну, надо перечень сформувать вот таких.
**Георгий:** Я записываю, записываю, да.
**Анатолий:** Надо подготовить примерчики. Игорь, это не то, что там прийти с: "А давайте, а что у нас есть?" Ну, давайте мы сейчас будем вспоминать. Нет. Понятно, что заранее подготовить, там показать и так далее. Вот. Второй момент – это то, что всё-таки я так как ещё там я посмотрел не так мало. Мы можем сделать перерыв на минут на 10-12, потому что.
**Георгий:** Да, конечно. Вот давайте тогда мы как просто затормозим запись пока откроем, а потом сюда же вернёмся просто пешком.
**Анатолий:** Всё, договорились. Тогда спасибо.
**Георгий:** Всё. Всем до свидания.

### Транскрипт видео "Part 2"

**Георгий:** Можем такую штуку сделать. Всё, запись пошла. Можем тогда продолжать за. Да. Ну, вот, есть примеров несколько примеров я тут привёл на разные операторы, да, чтобы можно было как-то их там посмотреть. Вот тут, собственно, что что имеется в виду, да. Вот нам нужно посмотреть, что Да, у нас есть там текущий шаблон, да, в котором есть в котором есть атрибут регион, да, и есть какая как какое-то подразделение там, ну, грубо говоря, там, не знаю, можно назвать там магазином, да, который в этом регионе существует. Вот. И нам нужно просто проверить, что, например, как бы, вот в это задан в заданный регион, да, при при задании региона на текущей форме, да, я, как бы, это у меня есть хоть один магазин в этом регионе выбранном. Вот. И фактически true или false должно вернуться. И вот я как раз-таки здесь, да, использую. Но мне не нужно доставать все реги, все магазины этого региона. То есть, как только я первый регион, первый магазин нашёл, то есть, как только в чек упал, там итератор получился хоть один, да, у нас меня, соответственно, мы выходим.
**Анатолий:** Чек – это тоже, я так понимаю, это зарезервированное слово?
**Георгий:** Нет, нет, нет, это тоже переменная. Я её просто чек назвал. Зарезервированно – это вот, как я говорил, то есть, это **item**, да, текущий объект и **value** – это и выходной параметр. Так, секундочку, секундочку. Вот сейчас первое сверху понятно. Ну, бизнес-структура – это другой шаблон записи, правильно? Угу. Угу. Соответственно, мы говорим, что у нас э-э так, так, мы получаем текущий регион. И дальше мы вытаскиваем по региону все, ну, в переменную чек, просто в магазины. Item – это служебное, правильно?
**Анатолий:** Да, да, да, да. Мы говорим, что мы получаем original. Угу.
**Георгий:** Так, ам – это что у нас? Если как, ну, для сущности, как это у нас, ну, вызвали?
**Анатолий:** Ам – это текущий объект, а текущий объект. То есть, мы получаем просто ID объекта. Правильно говорю?
**Георгий:** Да, да, да, ну, item – это ID текущего объекта, да. Вот. А, соответственно, мы запоминаем значение в original. И дальше мы смотрим 2 э совпадает ли? Ну, да, тут может быть несколько регионов. Ну, в общем случае, да. То есть, у нас регионов множественная может быть. То есть, итератор может быть не только одной записи. Вот он перейдёт, проверит первую. Если это в первом регионе хоть один магазин есть, соответственно, он тогда в это выйдет. Ну, то есть, он его поста этот итератор переключит на первый магазин, и пойдёт дальше в The Ones. И если он, соответственно, вышел с этим итератором, всё, он запоминает Wall, как бы, и снаружи будет только одно значение использовать. А дальше, как бы, итератор уже не перейдёт, не переключится. Вот. Если Rinwall у нас, как бы, если у нас в регионе не нашлось магазина, он перейдёт к к следующему. Если ни к одному не перейдёт, то он выйдет просто с пустым валим. Я понимаю.
**Анатолий:** Вот у меня слово чек ээ. Забейте на чек. Я его назвал чек просто, как бы, и всё. Я понимаю. Я просто говорю, что у нас неважно, как он называется, да, это перемен. Что на выходе мы получаем значение либо пусто, либо мы получаем, соответственно, ээ этот самый регион или true или false. Что мы получаем?
**Георгий:** Можно назвать его не, ну, true или false мы получаем на выходе. Что на выходе у нас будет вот если мы говорим про выход из функции нашей, ну, в смысле, нашего скрипта, то у нас только true или n. То есть, если у нас ничего вот здесь вот не нашлось, да, ни одного магазина, то он вернёт нал. Но это равносильно.
**Анатолий:** Это понятно, да. Да, да, да. Это пустое значение. Да, да. Это пустое значение.
**Георгий:** Если хоть один нашёл, он просто true вернёт одно значение. Потому что, как бы, итератор один раз только сработает. То есть, он не будет несколько раз проитерироваться и каждый раз true записывать в value. А присваиваем значение, да, это вот вот этот оператор присваиванию значения. Это вот если я так true присваиваю значение. Так true я кладу в value.
**Анатолий:** True вы кладёте в value. Правильно? Ну, а если у меня нул?
**Георгий:** А нул у вас будет только в том случае, если не дойдёт вообще до true положить. То есть, у вас если вот здесь вот ничего не находится, он вообще отрубается. Он прерывает выполнение. Всё.
**Анатолий:** Я то есть итератор он работает именно так, что если у нас итерации как бы идёт на каждой строчке хоть одно там матчит или находит ээ этот. Я понял. Я не обратил внимания, что у нас я фигурную скобку вверху первую и закрывающую. Всё понятно теперь.
**Георгий:** Да, да. Вот, вот теперь всё понятно. То есть, мы просто либо либо возвращаем. А, да, либо либо, да, либо нал у нас будет. Всё. Поехали дальше. Тай. Вот. Ну, опять же, ор наш, да. Сайни, полосайни. То есть, он вернёт либо оттуда, либо оттуда. То есть, не два вместе, а либо-либо. Ну, кстати, вот именно для задачи, для пособл Сайни и Сайни, это достаточно, потому что они вместе не могут существовать. У нас либо есть назначенный, как бы, тогда пособл уже пустые становятся, либо у нас только пособл безназначенный. Понятно. Поэтому пример, который был раньше, он может совсем. Он просто, да, как бы, вернёт то же самое, что и ор, по сути. Пойдёмте дальше. Угу. Так. Дальше. If. Так. If. Так. Здесь отступ с отступами беда, конечно. Он что-то слетает.
**Анатолий:** Не страшно, не страшно.
**Георгий:** Ну, в общем, если у нас заполнено dueate, то, как бы, сравни, что duate, ну, получи все задачи, которых duate duate больше, чем сейчас. То есть, это, как бы, это, ну, понятно, не просроченные, да. Понятно. И, соответственно, если там, соответственно, отсутствует, да, да. Если дюдот отсутствует, то мы просто возвращаем, как бы, задачу, что она тоже не просрочена. Ну, то есть, это не это не просроченные задачи. Вот. Ну, потому что, если.
**Анатолий:** А зачем так сложно?
**Георгий:** Не, ну, это я для примера вам проконструирую. Можно было упростить, конечно же. Можно было сделать нету. Ну, можно же было просто сказать, что если ээ задачи больше. А, ну, я понял. Вам это можно было сделать просто задачу меньше, да, и not сделать, и всё. И, как бы, одной строчкой.
**Анатолий:** Тут не надо ифов ничего.
**Георгий:** Я вам, как бы, для примера показываю. Раз это может быть неудачное использование. Но конструкцию именно, как она должем. Если мы else выбросим, то вообще тогда эта задача, да, она не попадёт. То есть, фактически у вас на этих задачах итератор будет прерываться. Даже если дальше что-то у вас будет, да, какая-то обработка, то нужно понимать, что оно никуда не пойдёт. Вот. То есть, то есть, другим слами ничего не вернёт. У кого due date не задан, да, он тогда, как бы, вообще никуда не включит. Никогда. Каких условиях? Всё. Пошли дальше. Мы возьмём на. Так. Да. Тут from сум как раз диаметром полтора. Ну, то есть, у нас есть там вопроса вторая какая-нибудь накладная, на которой мы сейчас находимся, да. Мы полуции накладной там какие-нибудь строки типа коллекции. Угу. И вот мы так в этих самых. Не обращайте внимания.
**Анатолий:** Ну, бывает. Заодно мы вам помогаем на на литу, на лету. Всё правильно. А, ну, то есть, мы из получаем сначала позиции, из позиции получаем атрибут сумму, и, соответственно, сумма вал у нас собирается в список. Угу. Вот на выходе нужно понимать, итератор принимает только одно значение. Значение – это массив. Этот массив в качестве этого, как его зовут, аргумента, да, субъекта мы подаём на функцию масс. То есть, входящее будет – это массив, и он на выходе выдаёт сумму массива. На самом деле, как бы, вот.
**Георгий:** Ну, по-хорошему, да. Мас, вот там 2, 3, 5. Не, не, это понятно, понятно. Вы массив, как бы, задаёте, и вот вот вот так вот именно мас работает, да. Ну, вот в круглых скобках – это массив считается. То есть, лист. Понятно, понятно. Так. Соответственно, оно именно так и работает. Угу. Давайте дальше. Следующий. Так. Каунт. Каунт, соответственно, работает не с массивом, а работает просто с формулой. То есть, у вас в скобках есть какая-то формула на входе, да, и он посчитает, сколько значений оно вернёт на выходе.
**Анатолий:** А, но он, ну, сколько позици он работает с итератором, правда?
**Георгий:** А, да, он именно итератор считает. То есть, у него на выходе формируется итератор, который вот там в position будет, и он считает количество, которое вернул этот итератор. Конечно, красиво было бы вот у вас первое и потом, ну, имеется в виду первая строчка накладная позиции накладной, да, и дальше просто сказать, что так positions сразу count, и всё. Ну, первое тут нужно понимать, да, вот эта вот строчка она не возвращает никаких данных. Имеется в виду, это вот positions будет хранить одно лишь значение ID атрибута, чтобы его потом использовать в качестве предиката для получения данных. А, понял.
**Анатолий:** То есть, у вас item – это ID объекта, а это ID атрибута. Поэтому вы, когда здесь указываете, у вас именно конструкция, что данные, как бы, в базе они хранятся. То есть, когда вы там на форме что-то заполняете, да, у вас хране ID объекта, ID атрибута, значение ID объекта, ID атрибута, значение. И вот таких вот троек, да, по форме там 30 штук у вас сохраняется сразу. Ну, сколько атрибутов на форме, столько, как бы, и таких троек сохранится в базе. Вот. И, как бы, именно вот вот этот вот запрос, да, он, как бы, спрашивает, он понимает, что item у вас задан ID объекта – это как входящий. Positions у вас вы его здесь нашли. Вот. И, соответственно, у вас отрабатывает поиск ээ значений по заданному субъекту и объекту. Угу. Можно ещё раз. А вот вот когда у нас это отрабатывает? Вот раз первое. У нас есть ээ накладная. По накладная – это у нас что? Шаблон записи.
**Георгий:** Шаблон записи.
**Анатолий:** А позиция накладной – это её свойство.
**Георгий:** Это атрибут, да.
**Анатолий:** Атрибут. Мы говорим, что ищем у этого атрибута позиции или что? Вы про какую строку пока?
**Георгий:** Вот которая круглыя скобках, да. Вот это вот. Это ищет не атрибут, ой, не значение. Ну, нашу базу помните.
**Анатолий:** Слушай, ну, давай подумаю. Помним. Сейчас я открою хоть что-нибудь тогда. Запится процесс создания.

**Георгий:** Так вот видите, у нас есть ID. Угу. Вот. Вот именно вот это ID вернётся вот в этот вот это вот вот вот вот вот в эту переменную. Вот. Вот в эту ID ээ того атрибута, который я за. То есть, там было указано это системное имя. Я указал системное имя. Вернулся системное имя. Это системное имя шаблона и системное имя атрибута. Вот вы задали вот коллекция вот здесь, да. Вы её коллекцию здесь задаёте, и системное имя шаблона, который, как бы, вот в котором она находится. Вот она в в переменную positions а поместила этот ID. Теперь она должна поместить ID. А теперь item – это это уже ID объекта. Э-э, какого объекта? На котором вы находитесь в данный момент, в контексте которого вы будете работать. Ну, вот вы переходите к экземплярам, да. Вот вы открываете, вот у вас объект 268. Вот этот 268 будет в айтеми. О. Ну, он типа накладная, да.
**Анатолий:** Он типа накладная. Да.
**Георгий:** А, то есть, по крайней мере, это у нас совпадает, потому что мне смутило, потому что у нас не не айтем до этого никак неизвестно, что он относится к накладной. Ну, это, ну, я просто, да, ты где-то помечал current template. Ну, вообще, как бы, item, да, это вот объект, с которым вы сейчас работаете. Как правило. Ну, зависит от точки входа, конечно же. То есть, на на форуме, на правилах на форме, на вычисляемом атрибуте – это так. На списках там по-другому. На списках там наоборот формируется набор айтемов, которые, как бы, у вас в список попадут. И там точка входа, как бы, она любая может быть. Вы откуда угодно можете зайти. Вот это тоже важная вещь, да. Ну, это потом надо будет ещё отдельно по.
**Анатолий:** На ролях перевёрнуто. У нас на ролях перевёрнуто. Там сейчас валию наоборот предустановлен. То есть, он на вход подаётся как текущий пользователь. Вот ам нужно вывести как ID объектов, которые имеют право работать с этим. Для это выданы, в общем, права для этого пользователя по контексту. Угу.
**Георгий:** В общем, там тоже перевёрнуто.
**Анатолий:** Так, понятно. То есть, короче, это есть куча исключений, которые.
**Георгий:** Да, ну, зависит от точки входа. Но в айтем ивали – это в итоге в это в два зарезервированных слова, которые, как бы, используется практически везде. Ну, имеют разные значение. Ну, смысл они они.
**Анатолий:** Да, да, да. Смысл разный, конечно. Где-то value должен принимать true false, где-то, как бы, он должен принимать ID объекта, ээ и где-то просто там какой-нибудь литерал, да, например, для в вычисляемого атрибута текстового, там литерала достаточно какого-нибудь.
**Георгий:** Понятно. Пойдёмте дальше. Вот двадцать шестой distinct, тот, о котором и говорил. Union all, да. Union и так далее. Ну, вот здесь вот, например, нам нужно вычислить количество позиций, да, у которых, ну, там, например, ээ ну продукт, да, в одинаковый. Ну, в смысле, не одинаковый, точнее, а не отличается количество уникальных продуктов в позициях четы. Ну, у нас вот, например, есть пример, да, там нефтяная компания. У неё есть ээ корзина, которая, как бы, наполняется именно по продуктами, и могут быть один и тот же продукт может быть добавлен в разные позиции заказа, чтобы они могли в каждую позицию в разный регион направить. Ну, там бензин какой-нибудь девяносто третий, да, в это в пять своих точек заправок отгрузку сделать. Это разные стройки. И это всё разное. А а разные строчки, да, в разных строчках. То есть, ну, позиции – это строчки, да. Соответственно, есть ещё вот там items номенклатура уже конкретная в каждой строчке. То есть, другими словами, эта штука а смотрит конкретный конкретный атрибут. У нас потом в накладнучение атрибута она вытаскивает сначала в позиции, ну, точнее, она по одной итерирует, да, одну позицию вытащила, перешла, нашла айтем в ней, ну, то есть, номенклатуру. Дальше переключилась на вторую позицию, нашла айтем во второй позиции. Отработала вот эта формула полностью. На выходе сформировался итератор в items ээ, который хранит уже э набор номенклатур. Номенклатуры, как бы, не это, не уникальный пока. Assert distinct добавляется, да, к формуле, соответственно, который вам выдаст.
**Анатолий:** Которой, да, уникальный сделает.
**Георгий:** И на выходе уже item будет содержать набор, ну, то есть, итератор будет содержать только уникальные значения. И дальше мы на него прикладываем вот формулу assert count, который посчитает только уникальные. И вот таким образом считаем уникальные значения. Ну, это такой пример вместе с каунтом. Так.
**Анатолий:** Давайте переведу. Это у вас нефтяная компания, я переведу на попроще. Бензина мы делаем заказ на следующий год, примерные наши потребности во всяких мелочах. Ну, например, там нам нужно столько-то ручек, столько-то блокнотов, столько-то картриджей для таких-то принтеров. Ну, и так далее, разных подразделений. Например.
**Георгий:** Не, ну, говорю, да, каждое подразделение делает, значит, соответственно, мы потом можем, а, ну, здесь пример понятен, но слегка выколотый, опять же. Но мы потом можем, допустим, сгруппировать и сказать, что вот у нас аа карандашей простых там просто H там это мы первую берём, да, position, ээ вот у нас там столько-то столько-то подразделений заказало. Правильно?
**Анатолий:** Да. Вот. А второе мы говорим, что у нас вообще-то, если мы переворачиваем на сторону позиции, то мы берём от другого, что вернее так подразделение такое, это заказалось столько-то карандашей. Вот. Угу. H. А дальше мы говорим, что А вот теперь у нас получается для заказай вот таких-то, да, ну, вот у вас же нет группировки. Но мы, по крайней мере, выбрали нужные записи. Из этого можно потом, ну, другие вычисления делать.
**Георгий:** Ну, да, потом можно и суммирование построить, и всё, что заказать там столько-то этих, столько-то этих, столько-то.
**Анатолий:** Правильно? Всё правильно. Да.
**Георгий:** У вас итератор на выходе есть. Вы можете дальше по этому итератору уже разложить, уже просуммировать именно по нему. Ну, это нужно садиться ещё раз, опять же, после того, как вы нам всё расскажете до конца, да, нужно некоторое время, чтобы в голове покрутилось в подкорке, потом сесть ещё раз почитать и попробовать вот для себя разложить, а как это вот, ну, нарисовать, как это как эти итераторы работают.
**Анатолий:** Ну, да, ну, здесь важно, как бы, смотрите, то есть, итератор работает в пределах формулы. То есть, вот у вас итератор вот отсюда начался, да, вот у вас первая формула, он у вас отсюда начался. То есть, у вас вот здесь вот нашёлся, нашлась одна запись, ну, должна быть одна, по сути, потому что не могут быть не уникальные атрибуты, да. То есть, два атрибута не может быть с одинаковым наименованием в одном шаблоне. Вот. Потом во второй тоже один итератор нашёлся, и дальше, как бы, у вас за это входит в формулу, там, следующую формулу у вас внутри формулы раскручивается итератор полностью. То есть, у вас positions там по одной переключается внутри на следующую строку. Здесь потом вычисляется также набор, вот, и он проходит по всему. То есть, и затем на выходе, да, он уже из формулы вот в следующую строчку выдаёт, потом на выходе из вот этой формулы он уже выдаёт следующую строчку. И так далее, и так далее. Понятно, да? Ну, то есть, у вас в пределах одной формулы итератор бегает ээ, как бы, это крутится, возвращаясь там на предыдущие. Как только мы вышли за пределы, всё, у вас итератор формируется как один, и он, соответственно, будет итерировать общее. Если мы говорим про Count, ну, если, например, вот вот здесь вот так что далеко, да, если вот здесь вот ещё какой-нибудь оператор, например, появился бы, да, что-то появилось бы, то он бы итерировал вот он для каждого бы каунт считал. То есть, он для каждого бы считал каунт и выводил бы, как бы, уже мультивалью в это несколько каунтов бы сделал value – это нужно понимать.
**Анатолий:** А так, ещё раз, смотрите. Мы что значит ещё одна строчка?
**Георгий:** Что мы, если у вас вот есть вот, да, есть какой-нибудь оператор, например, получить там, не знаю, подразделение, да, айтем там подразделение, какое-нибудь подразделение и так далее, там подразделение вал. Ага. Вот у вас по каждому подразделению дальше. А, понятно.
**Анатолий:** Будут будут будет крутиться каунт, да.
**Георгий:** Тут нужно понимать, что, как бы, в пределах формулы действует итератор. У вас формула вот она общая, соответственно, вот здесь вот пойдёт итератор вот по вот этому оператору. Формула будет восприниматься как одно. Это вот вот вот тут тройка тоже нужно понимать, да, вот всё, что обрачено в скобках – это один аргумент. Это субъект. У вас вычислится ass count – это предикат. Соответственно, value – это объект. Вот функ, да, как входящие переменную, дальше выполняет функцию и value помещает значение. Вот. Ну, как и здесь, да, у вас на вход массив, на выходе, соответственно, ой, в качестве предиката функция, и дальше на выходе переменная, в которую помещается значение этой функции.
**Анатолий:** А а как мне потом вот вот допустим я дальше захотел это использовать и уже просто ну просто грубо говоря в виде текста вывести то есть ну допустим мы захотели вот именно с с этим учётом то что у вас вот для того что мы для подразделения вал допустим что-то делали то есть если такждение вот вот насчитали по подразделениям везде есть количество ну так и теперь мне нужно вот сформировать строку которую выдать вот именно обычно вот в качестве вот набора то есть если мы там true false возвращали значит мы можем и строчку получить а в которой будет написано подразделение такое-то а столько-то количество ну неважно чего там айтемы мы можем не расшифровывать допустим да.
**Георгий:** Вы можете дальше вот здесь вот, например, какой-нибудь там переменную аккаунт назвать, да. У вас будет переменная аккаунта. Дальше вы пишите, что так, ну, вот это всё оборачивается from подразделение fromром соб ирается список, а дальше есть лист. Тогда двадцатип. Лист, по-моему, join. Так, join, которая на выходе вам соединит. Да, тут будет массив, будет ваш итератор, и там каунт, и разделитель какой-нибудь. Ну, дальше тут можно ещё объединить. То есть, count плюс подразделение сделать. То есть, там есть этот, как его зовут, конкат, тоже функция string, по-моему. Она, ну, то есть, это вот как раз в документации это есть.
**Анатолий:** Хорошо. И джойном объединить в одну строку все всё вот то что вы насобирали в каждом итераторе.
**Георгий:** А, хорошо. Это это лучше потом, потому что надо это я уже в сложности ухожу, это, наверное, лучше правда отложить.
**Анатолий:** Ну, я говорю про то, что, как бы, тут механизмов миллион, которые, как раз-таки, можно по-разному крутить. Вот.
**Георгий:** Так, хорошо. Но общий принцип, да, то есть, итератор он действует в рамках формулы, и формула, соответственно, у вас выполняется от начала до конца, и на выходе получается результаты. Вот у вас фактически субъект вот этот вот, ой, формула вот эта вся, она заменяется одним итератором, который подаётся на вход assert count, и который, соответственно, считает на выходе количества, то что итератору пришло от формулы.
**Анатолий:** Понятно. Значит, у нас подождите, после отработки этой штуки, вот теперь смотрите, у меня за за вот эта вот штука отработала. Так. А что у меня на выходе?
**Георгий:** У вас будет на выходе количество, которое вернёт, соответственно, вот этот запрос. Вот пока не вернёт, пока. Потому что value пока нет слова нет, да. Ну, value я пере. А в конце нет. Ну, хорошо. Нет. Если value не поставите, у вас на выходе у вас, во-первых, не сохранится, да, он не позволяет без использования. То есть, контролируется. А во-вторых, ли, как бы, у вас, ну, в смысле, он нал будет. То есть, пустой. И даже если вы его не заполните, если он не это, не заполне не заполнился.
**Анатолий:** Я сделал вычисляемое поле, которое ээ мне его, как бы, там, ну, будет заполнять.
**Георгий:** Да, да, да. Понятно. Хорошо. Пойдёмте дальше. Вот двадцать седьмой. Так. Следующее июньон. Он. Ну, июньон мы уже видели, да. Мы рассказывали, да. Ну, здесь более такой пример. То есть, у нас есть накладная, есть грузополучатель, есть грузоотправители, есть получатели. Например, мы всех контрагентов хотим там посмотреть. А сколько их? Ну, вот, собственно, их объединяем, да, и у нас в контракторе будут их грузополучатели и откроители. Ну, тут их может быть ещё больше там три контрагента у нас по накладной. Смотрим. Смотрите.
**Георгий:** Накладная грузополуча. Да. Мы говорим, а кем, ну, условно, кем поставляется, да, и в той же накладной мы говорим, есть получатель. Мы говорим, кто получает. Теперь мы формула наша. Мы говорим, а так, item shift by contractor, ну, контрактор понятно, это какое-то значение, которое я должен подставить. Это как раз-таки переменная, в которую будет складываться результаты каждого из итераций. То есть, вот здесь формула независимая, она вычислится в контрактор, да, такой. Вот здесь формула независимая, она вычислится в контрактор, положится, и assert union затем объединит их в одну в это в один итератор. То есть, контрактор на выходе вот вот этой вот тройки, да, всей.
**Анатолий:** Понятно. Это массив на вход, кто нам поставляет и кому поставляем мы, правильно?
**Георгий:** И, соответственно, дальше контрактор мы используем в качестве этого. То есть, он релижит уже в это свои значения все собранные тичеты. Поня. Пойдёмте дальше, пожалуйста. Вот как-то так. Ну, всё. Дальше задание изделие. Почему оно сравнение? Можем отложить, ну, в смысле, отложить задание вам дать в оффлайне, чтобы вы как-то посидели, подумали, покрутили. Вот это очень интересный пример. Он непростой.
**Анатолий:** Так, давайте его отдельно, потому что это стоит реально, когда маленько уложится в голове. Вот. А мы сейчас маленько дальше продвинемся, и у нас хотя бы запись будет, и можно будет вернуться.
**Георгий:** А что у нас дальше? Вот. А решение нам не надо. Убираем его. Нам не надо решение. Ну, не надо, не надо. Давайте дальше. Видите, да, тут видите, оно тут что? У меня, кстати, что интересно было. А, ну, тут я прямо по итерациям уже это раскладываю, да. Угу. То есть, ну, да, это я уже задание пять ещё это написать запрос, который показывает количество уникальных контрагентов указанных. Так, давайте тогда так сделаем. Так, стоп. Ну, и дальше вот пошло уже в использование платформе, где как. Вот я как раз здесь расписал, да, в каких местах где item, где value. То есть, где вход, где выход.
**Анатолий:** Так, так, так, понятно. То есть, в вычисляемом атрибуте у нас ID текущей записи на вход. На выходе value – это значение, которое вы в атрибут хотите поместить. Угу. Список.
**Георгий:** Список на на список фильтр на списке, который у нас трой в качестве тройки пишется. Там только айтем в виде выходного параметра. То есть, на вход ничего нету. Там, по сути, можно точку входа любую взять. Вот. А на выходе будет должен быть ID запись, который вы в списке хотите показать. Угу. Вот. Операция, соответственно, есть условия понятия, да, где item будет тоже текущая запись, которую вы выбираете на операции. И value, как бы, true или false. Показывать или не показывать операцию по этой записи. Вот. Ну, это, ну, это чтобы прятать можно было условия отображения именно.
**Анатолий:** А, ну, если у вас операция завершить задачу, да, показывать показывать операцию, у вас операция завершить задачу, а задача уже закрыто. Вам же нужно прятать для для закрытых задач.
**Георгий:** Вот. Соответственно, вы пишете условие, только что, как бы, по айтему текущая задача открыта. Ну, вот это сейчас не запомнишь.
**Анатолий:** Но вы говорите, потому что потом это только слушать надо. Потому что здесь смотрите, Георгий, возникает очень такой вот вопрос: "А-а, а откуда мы можем взять?" Ээ, ну, вот смотрите, у есть, как вы говорите, есть адепты, ээ, которым хочется чего-то большего. Ну, действительно, вот там, если брать ваши выражения, ну, я не имею в виду антричное выражение, я имею в виду вот то, что будем так называть аля Excel, да, те функции, которые у вас есть, то в них я могу делать вещи, ну, достаточно простые. Понятно, опять же, аля Excel. То есть, вот есть записи, или там значение полей.
**Георгий:** Нет, значение полей конкретно. Я с ними могу что-то делать, да, не более того. Значение атрибута.
**Анатолий:** А вот если мне нужно что-то вот, как вы там примеры, ну, вот, допустим, тот же замечательный процесс, который мне будет служебный процесс, который будет запускаться, искать все задачи, которые у пользователей не выполнены, да. Угу. И, соответственно, давайте им и если если они просрочены, то, соответственно, там, или там, ну, да, просрочены, соответственно, посылать им напоминалку о том, что это делается.
**Георгий:** Надо, надо.
**Анатолий:** У вас задачи типа делаете, ну, или дальше уже продолжение банкета, что если это не помогает, там, допустим, в течение недели, то тогда начинается отсылка копии ещё и руководителю подразделения. Ну, вот, я ведь кроме как ээ я это не сделаю, правильно?
**Георгий:** Ну, смотрите, с уведомлениями вообще, как бы, ситуация такая, что у нас давно функционал этот в воздухе витает, да. Его уже просят там многие, да, но, как бы, пока ещё не возникла идеи, как её правильно сделать, так чтобы был компромисс между сложностью настройки и удобством, ну, в смысле, функциональностью. Ну, да.
**Анатолий:** Первое, что вы можете сделать, – это настроить, в принципе, ну, вот, как у нас сделали на прикладном уровне, просто шарики на процессе прямо, ну, таймеры, ну, да.
**Георгий:** Таймеры, грубо говоря, что, как бы, ну, там не просто таймеры нужны, там именно, ну, хотя, да, таймеры с вычислениями. Всё правильно.
**Анатолий:** Ну, можно на промежуточное событие куда я там ставлю там всякие штучки, правильно?
**Георгий:** Ну, вы на задачу можете просто эти таймеры повесить, грубо говоря, да. Если эта задача не завершена, то у неё непрерывающие события, которые со своим временем просто будут это альтернативно выходить и отправлять какие-то почтовые уведомления куда-то, да. Вот. Но сами понимаете, да, эти почтовые уведомления, они все будут зашиты тогда в модель процесса, и дальше если их нужно изменить, то это вам нужно изменять модель процесса. А по старым, например, уже экземплярам запущенным, как бы, ну, уже сложнее. То не пойдёт, да.
**Анатолий:** Не пойдёт.
**Георгий:** Соответственно, здесь для вот именно уведомтельных вещей тут нужен совершенно иной механизм. Вот. Ну, если мы говорим именно про этот функционал, то, как бы, здесь нужен отдельный совершенно механизм ээ, который позволит прямо в онлайне, да, самим пользовате, ну, не пользователям даже, наверное, а а поддержке, да, то есть, бизнес-аналитику, или как его можно назвать, который человек, который, как бы, отвечает там, владелец процесса, не знаю, который просто по этому процессу прямо снаружи, в рантайме, так сказать, то есть, в режиме оперативной работы без изменения модели процесса может вешать какие-то события на задачи, на процесс в целом, и так далее, которые позволят там делать и рассылки, и интеграции, и что-то ещё. То есть, какие-то такие вот, как раз-таки, вещи, да, а которые вообще никак на модель процесса не влияют.
**Анатолий:** Ну, вы знаете, здесь сейчас из что прерываю. Здесь давайте вот сразу говорим, вот те, кто, как говорится, владельцы процесса, они этого не сделают. Но не сделают. У них слишком низкий уровень. То есть, это обязательно должна быть поддержка. И вы абсолютно правы. Вот здесь речь идёт о том, что создаются боковые процессы, которые там неважно какими способами, но смотрят на существующие процессы. И потом, соответственно, выдают либо напоминалки. Это мы про напоминалки говорим. Но вот у нас же ещё масса других моментов. Ну, например, зачастую очень сложно просчитать, ну, вот здесь я всегда могу любой шаблон записи взять, правда, в рамках моего.
**Георгий:** Так, в четвёрке вы, если я правильно помню, вы же сами говорили, что у же и не будет ограничений на бизнес-приложение. Любой шаблон уникальный. Всё равно все шаблоны записи уникальны в пределах инстан.
**Анатолий:** Ну, системные имена. Угу. Соответственно, я могу взять любой шаблон, а и, соответственно, ну, вот, как-то с ними там найти одно, второе, третье, там, что-то подставить. Ну, то есть, сделать такую достаточно серьёзную, в основном, конечно, поисковую, но ещё и, возможно, вычислительную штучку. Ну, там, кто-то статистику запросил какую-то странную. Я знаю, что вся информация есть, но вот я нарисовал вот эту вот вот этот запрос, и оттуда я получил, соответственно, значение, которое я потом где-то в какой-то список, или там вновь созданный шаблон сделал. То есть, мне не надо создавать чего-то там специального в процессах, там смотреть, и так далее. Это всё сбоку идёт. Ну, например, смотрите, есть куча процессов, ну, условно, представьте себе, у нас уже куча процессов, и мне говорят: "А дайте мне, пожалуйста, статистику по тому, какие процессы, какое подразделение, как выполняется. Вот, где у них там задержки, там, где что, и так далее. Среднее время прохождения процессов, ну, и так далее."
**Георгий:** А это уже ещё отдельная задача, да, конечно. Поэтому тоже есть отдельный функционал. По нему даже уже наработки какие-то есть, да. Ну, это это пока функционалы, наработки, но у я к тому, что у вас же где-то есть описание классов, описание ээ, ну, вот то, что сегодня до перерыва я говорил, моделька вся есть.
**Анатолий:** Конечно, она так, да, ну, просто там это.
**Георгий:** Да, она лежит, но я пытался по ней, например, активные процессы, ну, в смысле, что он неактивный процесс, да, вот так-то называется. Вот. Но процесс неактивный, и я не нашёл, как правильно это делать. Я не нашёл там вот вот error у вас есть пример, да, а вот как сказать, как правильно написать проверку, что процесс, допустим, cancel или активный. Ну, статус у него там есть процес статус. Правильно написать вопрос-то в этом? Я писал процесс статус двоеточие, ну, в смысле, процесс двоеточия status. Что там?
**Георгий:** Ну, вам нужно на вход объект, да. Вот. А на выходе у. Ну, и в смысле на выходе в качестве предиката пропертия, а на выходе, как бы, её значение и искомое значение вам нужно сравнить замачить. Если оно не мачится там на искомое значение, то есть, что он активен, то он вас в нал вернёт. А значение-то какое? Как оно называется? Exactive?
**Георгий:** А там этот, как его зовут, должен быть нумератор. Ну, это я думаю, вы навряд ли это же всё в коде должно быть. В Н3 лежит сейчас. Я подомою.
**Анатолий:** В том дело, понимаете, читать мы читаем, это называется смотрим в книгу и ничего не видим. Ну, вот я могу добавить то, что наша я, конечно, это всё нашёл, а, но нашёл это только, ну, практически, ну, нечестными способами. Я просто все бинарники, все делельки скопировал себе, подключил, и просто в коде C# смотрел библиотеки. Просто библиотеки. Поня понятно, что я их запустить не могу. Там сами вибделельки не нужны. Там Н3 лежат в открытом виде. Вот именно они модель определяют в системную. Ну, а я а я смотрел ровненько интрижки.
**Георгий:** Ну, вот я се вот тришки как раз – это правильный путь. То есть, именно да.
**Анатолий:** Но я не совсем поняла, а как правильно их всё-таки там, ну, использовать? Это же тоже. Это вам тоже привычно, а нам-то людям.
**Георгий:** Я я я поэтому и привёл этот пример то, что в C# даже не имея доступа к нормального доступа к коду, помните, только сигнатура методов, я нашёл нашёл, как статусы называются, как их правильно передать. Всё это и нормально фильтровалось у меня на C#. Ну, вот есть object file process object, да. Вот если вы его откроете, здесь есть переменная process status, есть свойство внизу process status. Можно промотать. И вот здесь вот как раз-таки есть её описание, что она какое она значение принимает. Так. Где это activity token? Token erp. Вот так. Где, где, где. Эх, пролистал что?
**Анатолий:** А, вот, нашёл, да. Нашёл, нашёл. System. А, property name вижу. Property type process status.
**Георгий:** Вот. На них надо просто статус искать. Это наверняка какой-нибудь Янам. Это Янам, да. И вот вот этот вот Янам как раз-таки и нужно взять.
**Анатолий:** Ну, вот, а где его искать? Вот вот процесс active status. Он прямо так и есть. Он даже в кодесь прямо в 3 в этой же присутствует.
**Георгий:** Process activity. Process двоеточия с большой буквой activity с большой буквой status. Да. Вот и всё. И как надо писать? А вот прямо ID процесса. Ну, процесс у вас, ну, понятно, да. На в каком контексте ID процесс – это смотрите, вы а вы идёте от, я так понимаю, объекта, да. То есть, у вас item – это объект всегда. Вы, ну, в зависимости от точки использования. Я, насколько понимаю, вы где-нибудь там на этой на форме хотите, да.
**Анатолий:** Нет, вот смотрите, вот вот у меня проще. У меня есть верно. Вот давайте ещё раз ээ у меня же есть ээ шаблон записи ассоциированный с процессом. Так. Так. У меня ID процесса же есть. Ко гда шаблон записи ID запускается, ID ID процесса у вас ээ есть. Ну, это 100%. И он связан с записью обно с конкретной записью, правда?
**Георгий:** Да, правда.
**Анатолий:** И он там у меня где в параметре ID, наверное, записи.
**Георгий:** Так, давайте ещё раз. В если в процессе, если в процессе посмотреть, то у процесса есть. Сейчас я вам скажу, даже, как называется. Так. System container token system status. Status creator. Object. Process. Business process. Business. Ну, то есть, запись будет выглядеть вот так вот. Давайте сейчас переключусь. Вот. Ну, вы куда её? А, ну, вот, вот смотрите, я открываю шаблон записи, да. То есть, у вас будет вот так вот выглядеть ваш процесс. Это переменную, которую мы ищем. Лучше оставить предикат process object. Угу. Здесь item – это текущий шаблон, ну, запись. И префикс, соответственно, у вас на процесс должен добавиться. Это вот такой вот префикс. Вот и всё. У вас готово. Вы вытащили процесс. А дальше от процесса, если вам нужно вытащить статус, то это.
**Анатолий:** Ну, это я должен про ID иметь, правда?
**Георгий:** Ну, про ID вот я уже нашёл его.
**Анатолий:** Нене, вы, я говорю, process ID должен быть, правда? Так. Я сейчас вас не понял. Что значит?
**Георгий:** Смотрите, у нас вот смотрим на формулу. Первое у вас идёт процесс. Первая стро.
**Анатолий:** У меня идёт первое – это из айтема, из объекта, и по заданному object ID я нахожу ID процесса, да.
**Георгий:** Я его нахожу. Его он не задан. Он не задан, да. Да.
**Анатолий:** А тогда вопрос, да.
**Георгий:** И дальше по этому и дальше я беру вот этот процесс ID процесса, да, а дальше уже по каждому из них он проэтерирует, и посмотрит статус, что соответствует вот в этому вот этому статусу поенам, да, activity. Вот и всё. То есть, у вас на выходе и дальше, ну, процесс вместо процесс можно сразу value поставить, типа это выходной параметр, надо не надо. Вот. И он у вас выдаст все процессы, которые, как бы, активны по этому объекту, да. Всё понятно. Это вот вы на форме дальше это можете использовать. То есть, вы прямо на форуме можете этот список построить и увидеть.
**Анатолий:** Понятно. Ну, дальше понятно, что с этим можно играть, и и наоборот уйти, но тогда у меня, извините, Георгий, вопрос другой. Вот у меня есть определённые, ну, есть атрибуты шаблона записи ассоциированного с процессом приёма на работу, и у нас ээ вашими, скорее всего, ну, в смысле, комидровцами там есть ID экземпляра процесса один из атрибутов другого места, другого, ну, вычисляемый атрибут, наверное.
**Георгий:** Нет, нет. Одного окна. Соответственно, ээ.
**Анатолий:** То вот не, ну, он, наверное, вычисляемый. Нет, а как его туда кладут? Не знаю. Вот он у меня есть. А кто это сделал? Игорь, ты тут или не тут? Ушёл он. Ну, понятно, что это либо Игорь делал, либо это Анна делала в своё время. А потому что там ещё где-то у меня был ID, в который я за. Вот. Ну, вот для меня было откровением, что когда я запускаю ээ то, что называется повторно исполняемый процесс, да, из основного процесса, то я запоминаю в этом повторно исполняемом процессе ID вызвавшего процесса.
**Георгий:** Ну, у него есть вообще вот, ну, короче, просто он на интерфейсе недоступен, поэтому, как бы, мы такой небольшой хак делаем: передаём ID процесса внутрь, да. Это бы это есть такое. То есть, они по сути при запуске повторно используемого, а, передают процесс ID в качестве этого, как его зовут, данных на вход, да, в это в месседже. Но это это делали.
**Анатолий:** Я должен это сам записывать. Что ещё раз? Это делается автоматически или я должен это делать сам? Потому что у меня в модели оно есть. В модели оно хранится, но к нему доступные интерфейсы отсутствуют. Они это делают, чтобы лоукодом можно было пользоваться, ну, то есть, чтобы можно было какие-то выраженьки такие простые писать, где нужно.
**Георгий:** Вы хотите сказать, что когда у меня там из этапа стоит поместить ID, да, то есть, это просто для того, чтобы потом можно было дируть, правильно?
**Анатолий:** Да, потому что его вытащить невозможно из на интерфейсе нету доступа. То есть, в тройки, да, в тройке легко. То есть, parent ID. Сейчас я прямо налету, да. Вот у вас процесс достали вы. Давайте обратно в процесс переименуем. Process process. Вот у процесса есть, так называемый, CMW parent. Вот. И фактически мы это будет сюда мы поместим parent pro. Это вот про ID, как бы, наш. Угу. Вот для CMW, как бы, ну, отдельно этот префикс. Угу. Это Logic. Ну, префикс CMW, как бы, он вот именно вот такой.
**Анатолий:** Не, ну, я к тому, что это отложи от от логики. Ну, это всего лишь это, как его зовут, ээ синоним используемый. Можно logic было его назвать. То есть, это вообще не.
**Георгий:** Не я не о том, не о том. Это, ну, это пространство доменных имён. Не обращайте внимания на это. А на логику, да. Логики, да. То что тут logic написано – это как назвали, так назвали. То есть, не обращайте внимания настав. Так вот смотрите, есть следующее предложение, а, пожалуйста, Анатолий, ну, прокомментируй.
**Анатолий:** Даня. Что можно сделать? Вы можете. Я бы что предложил? Давайте может быть на сегодня мы закончим. Угу. Так. Я бы попросил вас прислать нам вот эти вот, ну, там, сколько у вас заданий? Три. Два задания у нас там. Два к текущему уроку, да. Ну, единственное, что, да, в видео они уже попали в решение, поэтому не посмотревать не будем. Подсмотреть не будем. Честные люди. Постараемся не смотреть. Вот. Пришлите, пожалуйста, вот два слайда тогда вот этих двух задач. Угу. И вот этот вот замечательный документ, который вы нарисовали. Потому что меня больше интересует вот это вот вот то, что вы нарисовали: prefix active status и так далее. С этим интересно поиграть. Вот. А мы постараемся всё это сделать. Ну,

### Транскрипт видео "n3 p1"

**Георгий:** Всё, пропал. Здесь ничего неще. Что ты хочешь увидеть? Там ничего не видеть. Ничего не увидишь. Да, реально. Единственный вариант – это фотать ходить и потом видео слайдов. Ну, так нормально, да. Всё равно видео потом опять будет.
**Анатолий:** Вообще, ну, да, да. Ну, что, начнём.
**Георгий:** Начнём. Задавайте вопросы, что про что стаёт. Вообще просит что, да. Смотри, в чём суть. Мы и для клиентов, и отдельный суббот попросил это нам нужно. Мы вот это не будем виде клиентов, поэтому мы на основе этого сделаем как бы осуждать, ну, как несколько ста есть потребность, чтобы люди и клиенты и.
**Анатолий:** Давайте закроем клиенты, не люди. В частности, Сургут совсем не люди, да.
**Георгий:** Ну, а могли, во-первых, уметь понимать тройки. Понимали из чего они состоят, как они работают. Ну, и в идеальном случае могли вметь их писать, научиться. То есть, пришёл человек.
**Анатолий:** Читать, потом сначала читать, потом писать, да. А потом уже можно много писать.
**Георгий:** Вот э-э, ну, мы, как бы, себе оставим честь там определить, какой у нас входной порог, да. То есть, какие, ну, требуются знания, чтобы вообще вот начинать понимать это.
**Анатолий:** Я думаю, что надо изначально высказать тогда про графовую базу, да.
**Георгий:** Ну, да, да, да. Мы пообщались, потому что даже там тому же Андрею Вахиду до этого они вообще как-то тройки пофиг на поменять адишны как тройки там на таком уровне. А когда вот на прошлой неделе чуть-чуть про базу там Георгий рассказал, у них в голове что-то начало укладываться.
**Анатолий:** Укладываться, да.
**Георгий:** Поэтому, видимо, да, вот **объяснить, как работают базы – это первый шаг**. Первое, что нужно знать. А дальше уже по ходу дела. То есть, можем что-то ещё. То есть, не, ну, сначала база, потом, как бы, за неё всё больше особо ничего.
**Георгий:** Давай, что.
**Анатолий:** Да.
**Георгий:** Ну, что, короче, **графовая база** у нас, да, да. Граф все знают, что такое граф. У нас **направленный**, да. Вот есть узел, все знают стрелочка, узел.
**Анатолий:** Лучше из математики понятие, да.
**Георгий:** Да, это обычное понятие. Бывает граф не направленный, когда стрелочки нет. Бывает направленный. В нашем случае графы направлены. Вот это номер один. Вообще **про наш граф можно почитать на V3or.org**. Это стандартный **семантический граф, который построен на базисах RDF**. Так из Resource Definition Frame. Вот. Там есть словарик и так далее. Хранится у нас граф в виде **триплетов**. То есть, если мы здесь вот для простоты назовём +1 2 3 4 6, так сделаем так. У нас будет написано: каждый трид – это вот 1 2 3 4 5.
**Анатолий:** Если вопросы есть, спрашивайте самые тупые. Если вы сейчас понимание отвалите, сейчас будете ещё 2 часа сидеть.
**Георгий:** Вот собственно этот граф описан вот тремя триплетами, да. Каждый триплет – это просто, на самом деле, связь, откуда выходит стрелочка, стрелочки, ну, то есть, сама это второй, и, как бы, куда она приходит. По RDFу это называется **subject**, **predicate**, **object**.
**Анатолий:** Что есть что? Что есть что? Subject – это subject, predicка, а что? То есть, первая часть называется subject, это предикат, это object, предикати. Я я не написал, да, ну, ладно.
**Георгий:** Граморна, да, SP, стандартный триплет, или SPO в сокращении. Оно называется subject, да, стандартный триплет. На них описываются такие вот направленные графы. Элементарно. То есть, ну, понятно, да, что можно любой такой граф описать эту фиг. Угу.
**Анатолий:** Ну, пример какой, может, более понятно? Вам понятно? Или вы? Ну, да, пример нужен. Боле.
**Георгий:** Ну, конечно, сейчас скажем, да. То есть, теперь давайте поговорим о конкретных рапах, которые надо более простом языком. Ну, на более простой язык сейчас перейдём, потом перейдём к нашим, которые у нас словотся. То есть, def сейчас пока не говорим, да. Обычно три клетки видят так. Вот **самый простой – это мама мыло раму**. То есть, мама у нас понятно, да, subject. Было приникать к маму, object. Вот. Дальше можно поставить так. Папа смотрел.
**Анатолий:** На этом месте мало, а то, что он ориентированный со стрелочкой – это какое свойство даёт? Вот так вот то, что лево – это право.
**Георгий:** Сейчас ещё более понятно там назовём. То есть, более такой понятно. Там, например, там **Миша сын Вася**. Ну, такого, как кривое, да. То есть, по сути, это у Миши есть сын Вася. Да. Это вот это направление в обратную сторону не работает. То есть, просто так нельзя сказать, что у Вася сын Мишка. На эту сторону, да, можно сказать вот так вот: Вася папа Миша. То есть, это называется **инверсные предикаты**. Обратный предикат. Когда у тебя в одну сторону отношения есть, соответственно, если ты его инвертируешь, в другое отношение. У нас это есть тоже. То есть, объект, свойства и как значение, назначение.
**Анатолий:** Ну, по сути, да. Здесь два объекта.
**Георгий:** Здесь, в том-то смысл. Ну, здесь у тебя референс. То есть, если посмотреть на нашу платформу, так работают референс филды, да, когда у вас, грубо говоря, одна один какой-то record type ссылается на другой record type. Вот так работает. А есть обратные ссылки, да, по которым вот и вы им тоже даёте название. На самом деле, при настройке платформы, вот по сути, вот выставляете одного PR-карту другого property название. В базе это хранится, на самом деле, один раз всего лишь. Вот. То есть, само это отношение.
**Анатолий:** Есть вопросы? Пока есть, да. Вопросы по таким, это самые базовые сейчас вы что-то не понимаете, как будете.
**Георгий:** А как определяется порядок? Без разницы. Порядка. Порядка фактов нету. То есть, от того, что вот так вот написано, то есть, вот в таком порядке, ну, строчка один, там, это строчка два, это строчка три. Без разницы. Граф целиком загружается. То есть, когда переменна мест слагаемые не меняется. Ещё вот это называют в простейшем случае фактом. Если это хранится в базе, например, ну, или вводим фактом. Если остановится, то есть, это вот данность. Мотора.
**Анатолий:** Тоже слова. Угу. Ясно, пока.
**Георгий:** Ну, пока так. Теперь дальше, как бы, не всё подряд можно запихать в subjectка object. У нас есть разные типы внутренние, да, скажем так, взл. То есть, самый простой тип, который у нас есть – это базовый, так сказать, **qualified name**. По RDFу это вообще по RDFу любая фигня, которая здесь написана, она должна в ур превращаться и однозначно резовываться.
**Анатолий:** URL знаете, да?
**Георгий:** Ну, URL знаете. Все понятие URL адрес браузер. Вот. И однозначно определяться этим узлом. Вот. То есть, просто так абстрактного папу обычно не пишут, да. То есть, пишут какого-то конкретного длинный уровн такой и там, да, соответственно, как можно сказать. То есть, у нас есть всякие там идентификаторы, а-а там наши понятия классов и прочие штуки. Вот они это вот в в URL обычно превращаются. И это называется **qualified name**. Fly qualified name. То есть, ну, и они, как бы, в тройках они, как бы, синтаксис строек такой обычно. То есть, никто не любит писать вот так вот фигак типа тамт двоеточие там www commander.com, потому что у нас такая надо com там/ology с user и там 42. Никто такую фигню не пишет, да. Все любят **префиксы**. То есть, вот там вот, если вот, ну, вот это написать там, что хранится там, это вот по сути вот это subject так записывается. Предикат тоже записался. Ну, то есть, если.
**Анатолий:** А пример вот реально пример вот с платформы. Вот что какой subject в платформе?
**Георгий:** Да, ну ты открой экран сразу покажи. Есть. Вот я вот здесь могу открыть, а здесь вот тут даже речь не о субъектах, а вот вот таких вот ресурсах. Потому что вот таким ресурсом можно описать и subject, и предикат, и object. Предикат вообще только таким ресурсом описывается, только таким ресурсом. Subject простым типом тоже обычно не описы простым типом что-то. Ну, какой-нибудь любой трой, просто, где примеры в этом, как его, в примерах открой, да, эти центр, где они. Ну, вот лестк не нем, а где команда свежется он, где любой открываешь. Ну, да.
**Георгий:** Что у нас тут есть? **object:findProperty**. Вот, как бы, да. Object – это вот это вот префикс. То есть, вот полное имя, если без сокращения префи писать, то было что там дальше, да. Object. То есть, это антология объектов наших. Решётка и что там, какой слотка про. Это вот прямо полное настоящее имя предиката, на самом деле, которое там написано в базе, записано в базе, да. То здесь сейчас про сложные типы сабжектов тоже поговорю. Вот в скобочках – это тоже subject, предикат – это object find property, и справа знак вопроса performance – это специальный тип объекта. Вот этот object find property он через префикс расшифровывается полностью вот так. Угу. Для того, чтобы такие не писать вдлинющие слова, как бы, всё равно они никому не нужны, не читаемые. Вот просто сокращённая форма записывает, что вот objectчия find property, да. Namespace, если брать программирования аналог, то есть, это область, где лежат знания, скажем, да, об этих словах. В данном случае про property в базе, наверное, всё-таки не лежит.
**Георгий:** Без разницы. Мы про базу не говорим сейчас. Это про определение тройк. То есть, как бы, да, какие слова использовать можно. Вот это вот самый такой базовый, во что разрешится. А дальше бывает, значит, следующих типов сабжекты обычно либо **сложные литералы**, о которых чуть позже, либо вот такие же точно. А **объекты** – это обычно там либо **value типа**, либо тоже такие value типа – это, например, дата, это, например, число, это строка, и так далее. То есть, если мы говорим про какую-то нашу заявку, когда мы subject у неё будет что-нибудь там ттттыт user anology, ну, то есть, здесьва наши это бла-бла, да, user, где есть здесь почему-то нет не учитывается с там решётка – это типа такой без разницы. И, значит, какая-то конкретная заявка. Когда мы откроем, открой конкретную заявку такую, пофиг какую. Вот это вот ID. Вот видите, 1861, так заканчивается. То вот на самом деле это будет вот в тройках, если записать, то это будет user objects там двоеточие что там стна, ну, там 1861. Вот эта фигня полностью вот этот объект это это root этого объекта. То есть, основное понятие про него. Дальше у него есть тут два свойства: title и русское название. То есть, там будет записано вот это не знаю, там, ну, там какой-то будет пробчи 42. Ну, вот так же, как проб – это какой-то претенс. И дальше написано там низкий. То есть, вот так вот лежит знание о том, что вот здесь вот проб 43 проб 43 про 42.
**Анатолий:** Открой, пожалуйста, атрибуты, да, дишники, да, айдишники.
**Георгий:** Атрибут. Ну, вон она, да, оп, O на самом деле 11 и O23. То есть, у них там префикс О, там object property сокраще. Как бы я назвал 50 42. Без зна.
**Анатолий:** Без разницы, как вы префикс назовёте.
**Георгий:** Это важно только в контексте этого три файла. Видели там собачка префикс и расшифровка. То есть, можно назвать, как хочешь. У нас просто есть какие-то устоявшиеся, лучше вязать их, чтобы, ну, всех читать одинаково. Вот. То есть, как бы, про объект лежит так. Дальше вы видели, наверное, в описании самих свойств есть **алиасы**. Вот эти, да.
**Анатолий:** Описание свойств, прождения про что это?
**Георгий:** По вот атрибуты системные. А вот, ну, да, асса – это системное имя, там, да, то самое. Обычно, как бы, никто вот это ОП-42 ОП-43 не запоминает, ну, что ж нереально запомнить. Все юзают эти аляасы, чтобы как раз из Алиаса понять это оп 4243.
**Анатолий:** Зачем ты пошёл сюда? Больше аляс показать. Ну, все поняли, о чём. Системный он справа, ну, ас системно, да.
**Георгий:** Вот. То есть, чтобы в троечках вот в этих воспользоваться вот этим системным именем, по нему найти OP-42, потому что для доступа в базе надо брать ОП42.
**Анатолий:** Так системное имя сделано для упрощения, да?
**Георгий:** Для упрощения, да. И вот тут специальная есть такая штука, чтобы его найти, вот видишь, workpl слева такая в скобочка object find property, про которую мы говорили, и workpl. Вот это вот эта конструкция я потом объясню, как это работает. Она достанет ОП там 42 ОП-43 тот самый нужный О по двум аляасам. Первый аляс – это контейнер, ну, этого дата дата recordкоord type, или как он тут называется у вас? Как по-русски называется?
**Анатолий:** Ну, имя шаблона.
**Георгий:** Имя шаблона, да. Системное имя шаблона, системное имя атрибута. Короче, он, когда, ну, начинает типа вардироваться, да, вот вот и тогда он берёт LP вот это самые, да. То есть, это для простоты, это просто для простоты. Но он не начинает валидироваться дальше, как работает, да. Ну, в общем, как бы, про типы понятно, что вот есть длинные урлы, есть простые типы, как вот строчка, дата, что там, длительность, число, что ещё есть бу булин значение, да. False в вот эти все типы есть. Они все описаны в этом документе, который Кости делал. Подумаю точно знаю.

Вот таким образом просто вот в виде таких триплеток всё это и лежит в базе данных. Вот пока оно просто лежит, пока мы не говорим о том, как мы это достаём. Вот на этом этапе понятно?
**Анатолий:** Угу.
**Георгий:** Всем, да.
**Анатолий:** Непонятные с трудом. Ну, спрашивай сейчас дальше поедем.
**Георгий:** Давай, как бы, это. Я предлагаю им вообще пример привести: вот есть шаблон у тебя какой-нибудь, да, и немножко разложить, как шаблон лежит. Ну, то есть, что у него есть, что у него есть класс шаблон, что они ни хрена не понимают изначально, что такое find, откуда он достаётся. Это мы сейчас.
**Анатолий:** Ну, хорошо, про метаинформацию, да. Вот ту форму, которую мы открывали, открой, пожалуйста, атрибут.
**Георгий:** Атрибут или форму?
**Анатолий:** Ну, атрибут, атрибут любой, да, открой какой-то атрибут.
**Георгий:** Вот то, что мы здесь всё видим, это тоже лежит в базе, на самом деле, в виде таких же точных преклетов. Для начала, да. То есть, где-то написано, что вот этот, как он там назывался, ОП, ну, хрен с ним, будем считать, что О 42, да. Там где-то написано, что OP42 тип данных, там, type, там, ну, это тоже волшебные все слова, вот такие же суровые, потому что это системно волшебное определение. Потом написано опять ОП 42.
**Анатолий:** Кстати, сейчас за одно сокращение, а зачем она уро? Ну, всё лежит, если ещё, а почему? Просто. Зачем?
**Георгий:** Потому что это семантик стандарт DF. Зачем тебя улаго? Ну, конечно, у тебя даже простые типы это там XSD в принципе простых типах ты тоже можешь найти и символизовать урол. Даже вот эти числа – это там уролов, который в котором все простые числа находятся, потом там решёточка два – это простое число два, там три – это простое число три. То есть, просто для сокращения простые типы их выкинули, ну, не надо их реализовывать. Вот. А так они все тоже, что там имя, да, там дальше написано name, ну, и тут уже простой тип стринга, то что написано там system name, тоже там строчка. Угу. Формат отображения обычный текст, ну, там дисплей, скорее всего. Ну, и тут спецовое имя какого-то дисплей тайпа, скорее всего, и то.
**Анатолий:** Так, а если то есть, если мы сами соём, который у тебя объявлена отдельно и так далее.
**Георгий:** То есть, вся вся фишка, полная онтология, как она разложена. Так вот, спрашивай. Это в урлах лежит только вот такие вот системы, да, прикладные вещи. Ну, как в урлах лежит всё то, что является, как бы, сложным типом каким-то, да, например, который надо опи писать. Ну, формат отображения – это непростой тип, да. Это не просто какой-то вот здесь текст написан, а это вот там, на самом деле, ID и имя, как минимум, да. То есть, это два. То есть, каждый объект тут описывается двумя свойствами: именем отображения и идентификатором, да, каким-то волшебным там своим урлом тоже. Вот. Вот это вот имя и системное имя – это простые штуки, да. Это просто стринга. Угу.
**Анатолий:** То есть, строчка формат отображения уже, ну, да, формат отображения уже.
**Георгий:** Потому что, ну, то что всё, что в дропдауне, на самом деле, такой хинт небольшой, всё, что в дропдаунах вот в этих – это уже сразу сложный тип, потому что у них у всех есть идентификатор и имя, как минимум. Ну, это почему? Это обычные тексты. Это а дальше локализация, ну, это для чего нуженка и почему? Потому что ты же не будешь просто идентификатор отображать. Они нечитаемые, как бы. Поэтому у нас все справочники, все справочники сделаны тоже сложными объектами, ID, имя, там тоже введён формат, там, display type, да, у него какой- это класс, соответственно, display type – это у него, соответственно, там значение такое есть, значение такое, значение такое. И значения эти они там совсем, как бы, такие системные, ну, для программистов, да, читаемые программисты, не людьми. И вот эти все галочки они тоже там написаны. Ну, то есть, вот мы для выпадаю делаем отдельные шаблоны. Также здесь вот для этих выпадает, ну, тоже система есть провочники. Так.
**Анатолий:** Ну, и что я это расписал? И что ты хотел это?
**Георгий:** Ну, я хочу, чтобы поняли, как лежит вообще метамодель. Ну, вся эта, да, метаинформация, так называемая. Метаинформация – это описание структуры данных, описание форм, описание вот этих вот панелек, там, вообще описание всей фигни. Это называется метаинформация. У нас вот она вся тоже в этом графе и лежит. Собственно, всё в том же. Угу. Вот. Ну, соответственно, про вот этот OP-42 будет где-то написано, что на самом деле там, как этот ОА, я тоже точно помню. ОА43 там какой-нибудь – это Object Tab, да. Это тот самый вот этот вот шаблон, да, object 43 что-нибудь типа там has property 42. То есть, таким образом, вот это первойство оно прицеплено к шаблону. Как бы, пока на тройках понятно, да. Пока задня сама по себе читае читается понятно. Там ещё прочитать у тебя нет никаких там экземпляров простых без выражений читать.
**Анатолий:** Ну, есть экзамплы почитать в этом в документе от Кости. Там есть один, ну, то есть, те же самые примеры есть. Просто тексты почитайте их, чтобы там не забредать новых там яблоко зелёное.
**Георгий:** В в Костиновом документе, как раз-таки, там абстрактно всё. То есть, отношение в реальном мире. А в системе вот чего не хватает-то людям. Ну, там при инсталляции огромное количество три файлов туда инсталлируется. Там описана система. Её можно прямо вот реально открыть и почитать там на описание всех классов, всех базовых. Ну, куда ты поинсталлировать себе на машину можешь. Мы вот так можем просто какую-нибудь базу открыть на тройках, но посмотреть, ну, метаинформацию почитать можем.
**Анатолий:** А просто базу мы не можем. Базы нет.
**Георгий:** Ну, там был раньше несколько уровневый интерфейс покверить.
**Анатолий:** А почитать, а как? Что ты будешь считать? У тебя будет просто со строчками просто.
**Георгий:** Ну, а потом вот когда мы начнём типа синтаксис записывать, да, вот так было бы понятне. То есть, вот у нас конкретно база, да, на экране, как ээ, ну, тебе словарь словарь нужен, наверное, да. То есть, ну, в этом три файле есть словарь в этих entry файлах, которые представляется система. Это как раз и есть словарь. То есть, можно хранить дальше, как бы, сам где тройки хранятся. Они хранятся, как бы, статические некоторые вмеem. Это вообще там базовая конфигурация нашей платформы, которая не меняется от билда. Ну, то есть, как бы, от пользователя не меняется. Она может быть изменена при апгрейде каком-то, да, при новой версии на ка. Например, что, ну, там, например, написано, что у атрибута вот такой набор параметров, да, новые параметры от Балды туда он не добавится никак. Нельзя на на рантайме в реалтайме сейчас добавить этот параметр. Чтобы его добавить, надо сначала пойти там программистам его добавить, поддержать вот здесь вот его обработки и так далее. Угу. Вот. Вот такие вещи они там и лежат. То есть, там написано, что, например, у объектов бывают свойства, да, что у процессов ещё что-то бывает и так далее. Там тоже это всё описано. По сути, это такая первого уровня там, ну, или второго, да.
**Анатолий:** Ну, в сущности, системы и свойст. Ну, да, вот шаблон процесса, у него такие есть настройки. Роли, все эти там. Ну, по сути, да, весь конфигуратор там написан, да, на самом деле.
**Георгий:** Ну, что, по кверям или да, или что-то ещё такое скажешь. Ну, я не знаю, спрашивайте, да, спрашивайте. Хватит, не хватит. Объекты нужно разложить, как по проктям лежат. Ну, я до этого раскладывал. То есть, по сути, этот объект он ничем не отличае. Вот этот объект ничем не отличается от всех других объектов в системе с точки зрения хранения. Вот это вот набор свойств у него, конечно, будет у каждого объекта свой, да. Угу. Вот. И вы его, как бы, вот здесь вот задаёте. Вот конфигуратор, какие у него свойства. Ну, вот я когда пишу тройку, да, я получается не могу от вот взять какой-нибудь system name. Нет, не не ож. Сейчас, сейчас сформулирую. Вот, допустим, у нас есть ээ роль какая-то, да, бывает у юзера. Угу. То есть, я вот так не могу, да. Я не могу сначала в в объекте написать юзера, да, потом его роль, да, и в объекте он не найдёт, да, получается сейчас. Ну, блин, какая задача? Задачу пытаешься решить, да, что ж ты за человек-то такой старого старого больного конкретно.
**Анатолий:** Да, допустим, да, user, да, уже, да, сверху пришёл, да, потом короче, у меня есть какой-то, да, system, допустим, его ээ роль, да, ну, допустим, как-то ты нашёл проро, да, да, да, ну, вот, скорее всего, проро это уже будет без знака вопросиков, роль – это, скорее всего, А, да, да, да, да, да, вот будет, как раз-таки, вот этот с двоеточием, да, с двоеточием, то есть, это известное слово, да, вот, и получается, сюда, да, валют, но у меня ничего нету также. Чему это найдёт?
**Георгий:** А он мне найдёт сейчас все, в общем, все все роли, которые этому юзеру выпадаю. Пере наверное, Пётр там, потому что роль свойство.
**Анатолий:** Хорошо, без разницы, как лежит эта тройка в базе, то ты можешь её найти. Угу.
**Георгий:** У тебя просто вот это have property, то же самое здесь, там, да, там, или там что-то ещё, когда мы от обратного просто идём, когда тут сейчас короче, пример, да, я найду. Короче, ты уже на запросы пошёл.
**Анатолий:** Запросы нужно вот сейчас ещё не дошёл. Там по базе понятно, как как в базе лежат данные вообще.
**Георгий:** То есть, так просто сейчас мы будем по ним искать в запросах, да. Надо, чтобы вы просто понимали, что они лежат в тройках, они связаны между собой, да, что у тебя в одной тройке вот это вот будет там, грубо говоря, subject, а в другой тройке оно object. Оно в конце лежит, да. Вот таким образом весь граф строится по тройкам. То есть, так лежат и как и данные, и как конфигурация системы.
**Анатолий:** Могут быть, быть предикато?
**Георгий:** Могут быть, да, самый, да. То есть, на самом деле, все три варианта возможны, да. Вот здесь 42 – это subject. Вот здесь 42 – это object, да. А в самом объекте, в каком-то, который вот здесь вот был создан, что это у тебя приоритет какой-нибудь, то есть, будет написано там user object там 15, без разницы, o 42, и тут написано там значение. И тот же самый ОК42 оказался на месте предикатов. Но это специфично конкретно для атрибутов. Очевидно, что атрибуто предикатость всегда так. Вообще, любой может быть поменяться. Низкий может быть низкий в центр не пишут.
**Анатолий:** Не, да, не начало. Центр – это простой тип. Ну, это простой тип. У него нет своего.
**Георгий:** Знакомые названия. Ограничений в базе на это, как бы, а по-моему, нету. Ну, ну, нету, по-моему, да, не делали. Ну, только если мы сверху чуть-чуть закрышку поставили. Главное, вот сюда вот точно писать не стоит. Бесполезно, да, потому что, ну, плохо. А в subject иногда бывает пишет. Ну, в базе такого нет ограничения, что не писать. Мы сверху может быть на уровне платформы это запретили на всякий случай, чтобы, ну, как бы, люди фиг писали. Ну, потому что зачем тебе слово низкие описывает, да. Тебе надо какой-то объект описывать, а слово низкие описывать ни что. Угу. Кроме слова ничего не.
**Анатолий:** То есть, или там 15 января? Какой смысл описывать что-то про? Не описание.
**Георгий:** Не, ну, вот list of valтре list of values – это сложный тип. Это уже не простой тип. List of values в трекере в том же, да, чуть другая была онтология. То есть, там было написано, что у тебя там, если мы значение этого list of wes где-то поищем, то будет написано там по 15 42 LV там 41 будет написано, что LV 41 name там ID, ну, ID в интаржнее как-то, да. Угу.
**Анатолий:** Понятно, или не очень?
**Георгий:** Спрашивай.
**Анатолий:** Как-то пока расключит. Принцип понятен, а как оно работает, я сейчас пока полю.
**Георгий:** Ну, то, как работает, сейчас можно посмотреть на предмете запросов. Вот. Ну, как бы, ожидать, что оно с первого раза уложится людям, которые с графами не работали, я бы не ожидал. Потому что довольно сложная вещь, изменения, как бы, мышления. А не работа. Ну, в SQL ты представляешь себе, как, Да. Вот это не SQL, да. Там SQL у тебя в подличках данные лежат. Тут они лежат вот эти. Представь себе табличку из трёх колонок, по сути, да. И вот вся база описывается в табличке в одной из трёх колонок.
**Анатолий:** Нет, SP прямо тройка не описываесь у тебя первая колонка, правильно, а вторая предикат, третья.
**Георгий:** То есть, объект, свойства объекта и значения этого свойства. Едем.
**Анатолий:** Знаете, на запросы получается, поэтому тройка называется, потому что три свойства, три три узла. Одно.
**Георгий:** Три слова находит.
**Анатолий:** И это одна запись, да?
**Георгий:** А вот это вот это важно, что я это понял. И в базе миллионы вот этих записей. Некоторые из них описывают это самое. Интерфейс-то вообще всё так описывается. Вот этими.
**Анатолий:** Одна тройка, один объект получается?
**Георгий:** Одна запись, одна тройка – это одна запись, да, один факт. Его тройку он называет фактом, да. То есть, чтобы тройка не называть на лица. Ну, да, это вкреке реализовали вертикальные структуры для этого, для устрения.
**Анатолий:** За что едем?
**Георгий:** Ну, понятно, да, тут оно работа. Всё работало. Надо спира. Так.
**Анатолий:** Дальше, короче. Я не зря сказал факт слово, да.
**Георгий:** На самом деле, факты они бывают у нас двух видов: **аксиомы** и те, которые **вывелись на основании других аксиомов**. Как понять? То есть, аксиомы – это то, что лежит прямо в базе данных и пропечатано, сохранено. Выводимые факты – это то, что на основании вот этих аксиом, ну, и того, что скормили там сверху из контекста вызова, например, да. То есть, текущий пользователь, время вызова, да, локализация сервера. Вот это вот окружающий контекст выполнения запросов. Вот он всегда присутствует, да. Вот можно навыводить новые факты, да. То есть, и так, собственно, реализованы э того, что реализовано – это **выводимые атрибуты**, **вычисляемые свойства**. Здесь вот в атрибутах есть такая фигня: вычисляемые свойства.
**Анатолий:** Вычисляемые. Ну, просто что вычисляем, покажи атрибут.
**Георгий:** Вычисля. Вычисляем. Такой же текстовый сделай. Ну, тест. Ну, тест, да. Всё. Давайте простое выражение. Потом сразу уже форматное произведение. Ну, я вон ещё что, поварите на поле другое. Есть там такое, да.
**Анатолий:** Не, ну, что я хотел, чтобы ты сохранил его. Посмотрели. Я иди вытащит. Там есть, есть, а он тоже, да, есть, есть. Точно.
**Георгий:** Да. Это ставить редача не можем на запись с. Ну, камеру можно двигать. Не видно только. Он у тебя видишь с большой буквы title, а ты там с маленькой написал. Это важно.
**Анатолий:** Ну, сфоткайте там. Всё. Ничего не видно. Не видно.
**Георгий:** Сш большой. Угу. Ну, там, по крайней мере, красно, да, да. Красный. Ну, его в один оформле. Вот title, видите, айдишник 1861. Поменяй на S. Ну, добавь что-нибудь.
**Анатолий:** Что-нибудь такое. Что добавить? Ну, буквы.
**Георгий:** Давай бах. Работает. Да. Это вычисляем. Это это вычисляется нали. Не вычисляется. Вот применительно к понятиям, которые вот сейчас тоже сказал, да, аксиомы – это вот это вот low 434 1861. Это в базе лежит то, что написано. А новое то, что вычисляется – это вот это вот тест заложение. Он в базе не хранится. Угу. То есть он он thefly, как бы, когда мы запрашиваем объект, нам дай нам объект с его свойствами. Он находит, что есть такое свойство, это свойство вычисляемое. Он его вычисляет.
**Анатолий:** Как он его, допустим, если я вычисляемое там выгружает, он каждый раз подгружает, да, вычисляет, да.
**Георгий:** Каждый раз он захвает, да. Здесь надо быть осторожным, например, в таблицу. То есть, почему так за. А чтобы реально времени учили, чтобы реально, да. Потому что есть некоторые вещи, которые, ну, вот нет событий, по которым ты можешь перечис перевысчитывать там что-то. Но даже если есть события, то что тебе нужно какое-то сложное выражение, оно изначально в реальном времени не в реальном, без разницы. Его изначально оно собирается из двух других. Угу. Вот ты не можешь его, как бы, ну, иначе ты пользователя заставишь вводить, как бы, первое, второе, и потом ещё сборную солянку из первого и второго, да, чтобы сохранить это полученное значение. Ну, можно и сохранить. Не проблема. То есть, это выражение, которое мы сейчас написали, его в разных местах можно написать. Оно будет работать везде, и будет работать. Получили значение, кое-д вычислили. Нам его сохранить надо.
**Анатолий:** Можно, да? Чтобы в базу-то уже как правило, как да отдельные атрибуты туда записывать, что ли, или что? Вопрос как.
**Георгий:** Когда сохранить, да. То есть, вопрос сначала ты говоришь, надо. Мы получили и сохранили. Ты же не в вакууме его получил и сохранил. Ты или кнопку нажал, или в процессе куда-то пришёл. В зависимости от того, где это находится, ты туда и прописываешь этот сервер. Сейчас вот там кнопка одна save, да. Вот что-то тут форме мы сейчас сохраним, он никудато значение не не запишет. То есть, надо написать правило какое-то, да.
**Анатолий:** Сделать отдельный атрибут.
**Георгий:** Не обязательно, не обязательно. Если мы говорим про настройку вот этой вот балалайки. Пойди, пожалуйста, Серёж. Скопируй оттуда, ну, закать вот это вот выражение. Давай. Ну, вот скопируй себе бульфер отмена. Удали его нахрен отсюда. Сделай его невычисляемым. Угу. Пошли настройки формы, да. Мы уже отклонились. Я так. Блин. Правила для формы я не знаю. Валер, ты для себя это откровение? Для меня не откровения. Я просто хочу понять, как это.
**Анатолий:** Валер, ты, как бы, это отклонение вообще от курса.
**Георгий:** Этом. Значит, правило напиши. Ну, да, действие – это хорошо. Правило напиши. Ну, то есть, просто эмти, эмти от теста, да. То есть, выполнять это правило, когда поле тест пустое. А само выражение вы выбери там этот самый. Добавил тест значение выражение. Выражение – это надо эту фигню написать, которую. Ага. Всё. Хранить. Ну, теперь видишь, тут нету, да. То есть, если ты, по идее, там что-то где-то поменяешь, он должен подставить там пять, опять сломаешь. Ну, в общем, ну, обычно он сюда подставляет, да. И ты нажмёшь save, и он сохранит.
**Анатолий:** А, ну, понятно. То есть, это такая динамика. Самые.
**Георгий:** То есть, это то же самое вычисление, только сделанное через правила получается, да.
**Анатолий:** Да. Вычисление одно и то же работает. Всё одно и то же. Внутри просто место, где вызывается другое, да.
**Георгий:** То есть, в одном случае, как бы, написано, что это свойство вообще всегда вычисляемое, в другом случае у тебя просто одно из правил отрабатывает, вычисляет это же значение и пихает его вот по форме вчени. Ну, смысле. Так это где вот эти вычисления используются? Вот, ну, то то и то, где вы это увидите, да. Вот это вот, а, ну, часть примеров мы уже посмотрели. То же самое есть какие-то для там триггеро, для чего там ещё, для триггеров каких-то там, да, для всякой такой фигни. Это выражение, написанные на нашем псевдоязыке, вот этом, да, там, аля Экселя, и подобное. Внутри это всё всегда транслируется в тройки. В тройках есть специфические запросы, которые как раз в этих твоих примерах, да, примера. Что такое запрос?
**Анатолий:** Запрос – это тройка.
**Георгий:** В общем случае, тройка, да. Вот для того, чтобы запрос работал, надо, чтобы тройка умела не только вот эти урлы там поддерживать, да, там какие-то простейшие типы. А есть так называемые **сложные типы**. Вот этой фигни **комплекс литерал**. Комплексный тирал. У нас сам по себе двух типов. Один называется **формула** и обозначается вот фигурными скобочками, что он находится в формуле. В формуле находится набор фактов, там, ну, или стейтментов. То есть, они факт стейтмент одинаковы называется. То есть, набор триплетов. То есть, ещё раз, триплет – это прямо subject-object. А вот эта формула – это, короче, Т1 Т Т в определённых точках. Вот это вот первый тип сложных литералов. И **второй тип сложных литералов – это лист**. Вот если мы с вами, как бы, определим, что вот этот вот элемент, он в общем случае у нас базовый тип имеет Q name там, или name, ну, или просто name мы его назовём, что вот этот и это и это не штука, да.
**Анатолий:** Лист – это просто набор этих у порядочных порядку, да.
**Георгий:** Картащи через точку-то уже не лист. Вот так каждый триплет через точку. В листе просто через пробел. Не через запятую, да. То это получается свойство, ну, почему свойство. Это просто перечисление такое вот. Просто перечисление каких какой-то коллекции, не коллекции. Что хочешь, назови. Не.
**Анатолий:** Вот что-то про, ну, - это вот базовый тип для вот этого субъекта, предиката и обжект. Считаем, что у всех базовый тип, просто слово там, ну, слово в качестве, могут быть как значения, так и какие-нибудь типа те сложные ти, да. Урлы. Ур.
**Георгий:** Сейчас. Алло.
**Георгий:** Да, да. Не, сейчас неудобно. Через часа два. Да. Спасибо. Видно, да. Потом принимать будет экзамен, да, по билетам. То есть, вот здесь вот в этом примере, я не знаю, видно вам или нет. Вот здесь слева написано work item и workpl через пробел. Это вот пример с такой фигни списка. Где ещё какая строчка? Ну, просто при выдели вот так.
**Анатолий:** А где третий? Какой третий?
**Георгий:** Это не тройка. Это тут, ну, тут может быть сколько тебе там пять. Сколько хочешь. Лучше больше 128 не используется. Функция union тоже она принимает же внутрь этих скобочки, и всё это формула. Это формула. Это список в списке просто перечисление там, ну, 30 сабжектов подряд лежат, да. А так, а а формула стейтменты – это тройки. Ну, вот помнишь, он тот же самый там и набор формы. Давай две формы соединить.
**Анатолий:** А что применительно ты где? Зачем ты знал конкретно? Блин, тройку. Вот тройках сейчас будешь это применять. Формула то.
**Георгий:** А, подожди. Так ещё раз. Вот тут это что? Вот конкретно выделена строчка. Всё. Тройкам лист или это лист?
**Анатолий:** Да, вот это лист.
**Георгий:** Вот это лист. Work items знак вопроса property знак вопроса. Для чего лист используется? Самое самое. То есть, сейчас короче, короткое отступление. Предикаты бывают не только те, которые в базе хранятся, но и те, которые наши программисты, ну, и другие программисты сделали. Короче, умными. И они работают через C#. Они не в базу ходят, а что-нибудь вычисляют. Умеют вычислять там, складывать там, и так далее. Типичный пример такой фигни. Так вот, 1 2 3, мас, сум, и сюда вот эта фигня в X выведет очень конкретное число. Слева у тебя лист. Угу. Вот это предикат, который не пойдёт в базу, а посчитает памяти. Ну, и вы это положите. Угу. Это один из таких простых.
**Анатолий:** Он как как у него название? Ну, вот кого? У него у.
**Георгий:** Ну, вот это префикс, префикс, да, какой-то. Ну, посмотрите там стандартных префиксах есть. Смотрите, вот, ну, это наш сум. Наш не работает. Нет, это не наш. Это это это акц именновский должен быть. Ну, дело в том, что мы расширили. У них там понятие это математическое было только для чисел. А мы захотели сделать и для дат. То есть, нам надо просумировать дату и длительность, например, да. Или поэтому мы с вами массу, который такой у нас умный, догадывается какого типа аргумент ему отдали и складывается. Ну, то есть, это не префиксом мы потянули библиотеку каких-то этих предикатов, да. Да. Они называются buildины. То есть, build предикаты. Такие предикаты, которые что-то сами умеют считать. Это build предикаты специальные. Угу.
**Анатолий:** Понятно. Список понятен. Просто мне понятно, что ты мне говоришь это более-менее. Это чуть-чуть меньше.
**Георгий:** Валерий. Понятно. Ну, вот, вот, как бы, частный случай списка, вот так. Список.
**Анатолий:** Я просто не очень понимаю, что значит 1 2 3 чиселка.
**Георгий:** 1 2 3, сумма 1 2 3 значение. Правильно.
**Анатолий:** Список значения?
**Георгий:** Список. Вот смотри, вот у тебя там тройка есть subject, predicка, и object. У них значение n. Ты можешь взять эти n и сложить, допустим. Это и есть вот эти 1 2 3 - это n + n + n. А у тебя s = 1, p = 2 = 3. Ну, без плюс, просто n, а потом он поставил просто функцию суммирования этих значений. То есть, ты можешь это один из примеров, как бы, обратиться к списку 2че. А как вот это сверху хрень работает? Про у нас, по-моему, тоже работает. Это перемножение, да. Вот сюда восемь получится, по-любому. В общем, смотри, в общем, в базе данные лежат, как тройки. И запросы базу мы тоже пишем в таком же формате. Но посерединке может быть какая-то там операция. И мы с таким образом находимся в том числе будем искать. Можем что-то вычислять. Для операции вычисления нужно несколько чисел предоставить.
**Анатолий:** А вот эти три строки сверху – это просто ты подтягиваешь библиотеки, которые содержат эти функции.
**Георгий:** Ну, да, ты говоришь: "Подтяни мне вот математические операции." А, то есть, там их может быть и не три, может быть больше, да, там, пять-шесть. Сколько надо использовать нужную математику. Ты не притягиваешь, а вот если у тебя функция, она что, как будет? Она тоже значение этих приплетов возьмёт? Или как?
**Георгий:** Вот такая функция. Вот у тебя там в фигурных скобочках формула. Формула, да. Она как будет работать? Ну, формула – это, как бы, способ. То есть, если лист – это способ, так сказать, перечислить просто какие-то отдельные имена там, или циферки, или строчки там, ну, текст имеется в виду, да. То вот это – это способ перечислить набор триплетов, да, передать куда-то. Так вот.
**Анатолий:** И как это практически применяется?
**Георгий:** Ну, например, практическое применение. Вот есть волшебная запись, пишет from select что-то там. Оно, кстати, создаст вот у нас открывается кавычка, вот она закрывается.
**Анатолий:** Нет, она здесь закрывается.
**Георгий:** Заканчивается на селекте. Он семь. Вот вот а вот он зак. Да, да. Вот внутри этих фигурных это стоит. Ну, то есть, факты такие же, скажем. То есть, я просто не вижу от что там написано, чего мы таким образом делаем. Что лист лист лист триплетов. То есть, лист там сабжектов. Это вот это такой, который, да, вот такой вот, да. А лист триплетов – это вот через фигурные скобки.
**Анатолий:** Зачем такое нужно? Ну, вот в качестве примера. Вот один из примеров вот этих. Ну, мы сейчас что-нибудь попроще возьмём, да. Смотри, у тебя есть вот этот front select, да. Ты нужно указать, из чего выборку делать. Я сейчас, чтобы это вычислить, тебе нужно какие-то сложные несколько операций сделать, чтобы это. Да, я сейчас объясню на другом примере. На самом деле, как рез, вот здесь реально не все тройки, которые там используются. На самом деле, это огрызок тройки, да. На самом деле, целая тройка – это вот вот такая. Это subject, предикат у него сокращение вот такое, и object у него вот такой. А у нас такое используется?
**Георгий:** Да, используется. Просто, когда вы создаёте выражение, вот эта часть она всегда предопределена, поэтому её нигде, ну, не отсвечивает. И вы всегда задаёте вот эту часть. А вот эта она предопределена. Я сейчас объясню, какая понятная была. Вот как это следует читать. Вот это – это просто там синтаксический сахар, так называемый, на предикат log implies. Это то, что которое, ну, можно почитать Новотриоргии. Но читать следует так: из вот этой фигни следует вот эта фигня. Любят ещё это называть конъюнкции, это дизъюнкции, если совсем хочется почитать. Если у вас рынок не хватает из этого. Вот это самый простой кат. Что в этом impli log impli является посерединке, посерединке. Вот. То есть, пока понятно. Из какой-то вот левой фигни следует правая фигня. Левая фигня, ну, задаётся набором стейтментов. И правая фигня задаётся набором стейтментов. Чтобы такое самое простое сюда предложить для чего в нашей базе реализации рассках вещах объясню, что сразу в базу. То есть, например, из ящика яблоко зелёная, знаете такая контекстная переменная now.
**Георгий:** Да, видели где-нибудь там? Вот. Ну, о'кей. Можно такое выражение написать. Например, вот этот now, который там пока не будем говорить. Таким образом туда пришёл. Без разницы. Now, а week – есть такой у нас предикат тоже из нашего домена время, по-моему, да. Из время пишет Friday. Следует, что мы ещё можем так сказать now сразу и напишем сразу больше 18. Больше тоже просто можно так написать. Но здесь, по-моему, так писать нельзя, поэтому да. Поэтому здесь лучше напишем почисле мас. Ну, и для образано, да. То есть, есть специальная форма записи констант для даты времени. Можете просмотреть. Пока вот что написано. Опять же, вот левая часть выражения конъюнкция. Вот правая дезюнкция. Что выводится? Выводится, что всем пора идти домой, да. Вот. Ну, такая новая новый новая тройка выводится, да, по сути. Как будто она присутствует. Когда она валидная эта тройка? Когда вот эта штука отработает, скажет, что правда все эти условия совест. Что здесь написано? Взять now, который, как бы, в каждый момент выполнения запроса будет свой, да. То есть, час нау один, через час нау другой, в пятнице нау третий. Дальше из этого now с помощью волшебного нашего такого же билтына, как мак там, всё прочее, есть такой, ну, то есть, day of week. И проверяется с константой пятницы. То есть, если сегодня пятница, если так считает, да. Потом берётся у now забирается время дня, кладётся в переменную тай, и потом этот фиг – это булевая такая лты, да.
**Анатолий:** Во. Какой дету. Первый day of week. Он возвращает, на самом деле, число. Но так как у нас парсиру умный.
**Георгий:** То есть, вот это можно было бы записать более длинно, как люди иногда пишут: записать кут, потом со day, да. Можно написать, потом бы на можно было бы написать day равно равно friday. Такая константы. Просто, наверное, как где-нибудь есть, ну, или там число пять. Я не знаю, как его назвали пять. Вот. То есть, по сути, можно и так было расписать.
**Анатолий:** С вопросиками – это переменные, да?
**Георгий:** С вопросиками – это переменные, да. Пётр, тут вопрос больше в том, что у тебя часть этих троек возвращает данные, а часть просто, как бы, это чётко сравнивает. Это не зависит от тройки. Я сейчас чуть позже расскажу, да, что как как как вот здесь каждая конкретная штука работает. Я сейчас чуть позже расскажу, потому что это ва сломается сейчас. Вы пока держитесь, или вообще уже уплыли? Вот это понятно. То есть, да.
**Анатолий:** Дальше, если ты в другой какой-нибудь тройке там спросишь, вот это сейчас выражение является правдой или нет, ну, то есть, домой пора или не пора. И в случае, если это сработают все условия, что типа день недели пятница, что время больше, чем 18:00, значит, пора. Если нет, значит, это не выявится просто. Не не скажут здесь false. Ничего. Просто нет. Это неправда. Такое. То есть.
**Георгий:** Конъюнкция.
**Анатолий:** Это как фильтр получается, да?
**Георгий:** Конъюнкция как фильтр. И они всегда руковожены, да. Вы пишете всегда вот сюда конъюнкцию. Здесь всегда у вас конъюнкция находится. Какой вопрос? А это всё светно пишется все условия? Ну, через точку. Здесь точка, здесь там точка, здесь точка.
**Анатолий:** Здесь точки с новой стройки. Как хочешь. После точки нет пробела, и сразу на.
**Георгий:** Лучше лучше писать пробел, да, потому что это же читают люди. А чтобы оно работало, скорее всего, пофигу. Скорее всего, распа. Ну, можешь попробовать. Если что, тебе скажут синтаксическая ошибка. Если точку не поставишь, точно скажут, что синтаксическая ошибка. Между аргументами точными там пробелы.
**Анатолий:** Между аргументами пробелы – это точно, да. Потому что, если записать вот скобка закрылась, сразу двоеточие стрелка, скобка открылась, то он тоже будет.
**Георгий:** То есть, равно равно тоже. Если напишешь без обрамля без обрамления пробело, тоже поругается. Да.
**Георгий:** Теперь посмотрим на пример, который написал Сергей, тогда с вычисляемым свойством, когда там он форматировал, да. Угу. Именно со свойством вычисляется важно. Всё это я стираю. Сергей, значит, написал такое вот выражение на этом волшебном языке экспреписал формат. Первым аргументом сюда отдал синтаксы сматирования. Вторым аргументом отдал лист аргументов. ID, что там было? Title ID. Вот в тройке это преобразовалось в следующее. Так как он это задал для какого-то свойства, да, что это свойство какое-то в этом вычисляется. Там было, не знаю, как оно называлось, об48 там или что. Ну, да, об48. Пускай. Если она моя, это интересно. То дизъюнкция – та самая часть, которая вывелась, она, на самом деле, чётко записалась сама. Она знает, как её писать, и никогда таких вопросов больше никого не задаёт. Она представляет собой вот такую вот фигню. Вот выводится строго вот это. А из чего выводится? Ну, и сформатирование можно, как бы, пойти с конца. Интересно. То есть, формат – это тот самый string формат втриоргавский string. Не, это, по-моему, наш. Нет. Этот органский. Ну, хорошо. Это вот это вот слово. Теперь у него есть, как бы, что-то на входе, что-то на выходе. На выходе понятно, value будет. То есть, сохраняет он в это самое value. Что на входе? На входе у него, как раз, лист аргументов. Очень похожий, как здесь. Ну, и, соответственно, это лист аргументов будет выглядеть из вот вот этого нолика. Там просто строки реально. И внутри будет второй лист аргументов, который вот снова вот тот. И в него, соответственно, запихалось ID. Давайте для примера их назовём, как бы, сюда сейчас, так вот. То есть, будет знак вопроса title, вопроса ID. Вот это вот сюда фигня идёт на первое место. Ну, и, соответственно, откуда-то он их взять должен в этом месте, да. Так как здесь доллар написан, тай доллар ID наш умный фарсер вот этих выражений он поймёт, что title – это, на самом деле, ну, это шаляз, да. Вот это system name, что system name title – это там 2, system name ID 14, да. И он тогда напишет такие следующую строчку: item О 48 забегаем тай точка item 14. Ну, и таким способом он всё это вычислит. То есть, когда он начнёт вычислять, самый первый проход вам рассказываю, самый такой простой. То есть, он обратится в базу, когда, как бы, для чего он вычисляет? Для конкретного какого-то объекта, да, который там Сергей открыл, хрен знает какой-то, 1861, было какой-то такой. Он сюда придёт не с неизвестным айтэм, а придёт с айтэм, который 1861 айдишник. Он спросит базу, вот прямо здесь. То есть, ДБ, дай мне что всё, у кого, ну, что подходит под этот паттерн, так сказать, 18 там 61, что там у вас было О 42 знак вопроса. Вот. ДБ ему в ответ.
**Анатолий:** А если select написать, как выглядит?
**Георгий:** Здесь чего ты уже всё здесь понял? Ну, остальным дай понять.
**Анатолий:** Нет, просто select пример selectа был бы проще, да.
**Георгий:** Ты офигел какого селекта, Валера. Не проще. Ты что, офигел. Select-то был проще. Select он это обернуть вот это и запихать ещё в список с этим сначала разберись. То есть, базу данных спросит, дай мне, пожалуйста, всё, что подходит под этот паттерн. А что база данна посмотрит ему и отдаст? Она всегда отдаёт одно и то же, когда её так вот спрашиваешь. Она отдаёт нуумератор. Знакомы с таким понятием?
**Анатолий:** Нет.
**Георгий:** Перечислитель. Это такая фигня, в которой есть, по сути, аэтиных значений два метода. Два метода. Первый метод называется move next. Второй метод э называется current значения, да. То есть, это некоторые просто курсор такой. Слышали?
**Анатолий:** Перечислитель. Курсор, да.
**Георгий:** Когда у вас есть какой-то список там, где-то чего-то, и вы, как бы, не список возвращаете, а некоторый волшебный такой объектик, который изначально смотрит вот сюда. И когда ты ему говоришь: "Дай," он тебе всё время вот это возвращает. Потом ты говоришь: "Move," он смещается вниз на один. "Дай," он дальнёт вот это. Дальше move next, move next, move next. Он бежит до конца, и когда ты вот здесь делаешь move next, он скажет: "Больше нечего давать, всё закончилось." Почему? Потому что в базе гипотетически, а вот у этого объекта по этому свойству может быть лежать множество значений, да. Ну, предположительно, там, коллекция у вас, как работает, в одном коллекци, да. Ну, вот в одном этом у тебя много значений в одном объекте, соответственно, он тебе будет перечислительно эти объекты. В данном случае мы чётко знаем, что на самом деле значение там дано, да. Поэтому вернёт перечислитель, в котором будет на самом деле вот одно значение будет. То есть, перечислитель сюда вернулся енум, енум, в котором вот эта штука лежит.
**Анатолий:** Енум – это что за понятие?
**Георгий:** Нумератор. Перечислитель.
**Анатолий:** Мера. Да. Ну, перечисляемое. А ему позовут current, как бы, да, давай мне current value. И тогда тот самый, ну, то есть, здесь current взяли, и этот самый value засетили вот сюда в title. То есть, value будет тут, по-моему, low, который там что-то приходили. Low было бы написано. Дальше он опять скажет: "База, дай мне, пожалуйста, всё, что подходит вот под эту фигню. То есть, дай мне с этим 1860 там 1 об 14.1." Ну, та ему опять вернёт перечислитель с одним только значением, потому что у нас ничего больше туда не подойдёт. Это 100%, потому что идентификатор один для объект, и он сюда засейтит в этот ID не сейчас на 18 как раз 61, и засетит, потому что это есть возможность. Дальше позовётся уже вот это вот это не база. Это просто посчитать в памяти. Куда будет вот это отдано? Тот самый title, который low у нас забиндился, и айдишник, который забиннился. Ну, такое слово забинился. То есть, то, что сюда в данный момент загружено 1861. И он это вот по этому формату отформатирует и запихает value для объекта. Вернётся вот такой value.
**Анатолий:** Почему мы вообще пишем лист вот в этой вот формуле изначальной, да, в Expression cent. Почему мы пишем list вот и type id?
**Георгий:** А потому что у тебя тогда типизированно. То есть, у нас есть синтаксис вызова. Мы знаем, что лист – это перечисление какого-то недетерминированного количества аргументов, да. То есть, мы не знаем заранее, сколько туда аргументов напихают. Поэтому это лист. Вот у функции формат у неё чёткое определение. Она даже подсказывает это в потому что у неё есть два аргумента. Всё. Первый аргумент строчка, второй аргумент набор чего-то там.
**Анатолий:** И а такой какой-то гипотетический пример. Вот если title у нас не один. Можно мы можем какой-то такое сделать?
**Георгий:** Да, да, да. Title не один. Мы представляем, что вдруг так получилось, что title не один. Такое бывает. Вот вопрос на засыпку, что же в этом случае произойдёт? Если я вам сейчас рассказал, что вот как вот он взял карент, спустился ниже, взял карент, спустился вниз. Это не это не перечисляемая фигня. Он просто сюда засетил и вернул вот это. Подсказка. Вот эта вот штука она тоже на самом деле возвращает перечислитель дальше наверх. То есть, она возвращает точно такой же, ну, как и база, так и она возвращает, потому что потенциально этих значений может быть много. То есть, что вот когда он первый раз здесь ему позвот get current, когда ему позовут Getхаen, он вот это вот всё взял один раз прокрутил и вернул, ну, вот эту вот строчку там что-то low 1845. Вот он повернул. Но на самом деле ему позвали move next. Что он дальше будет делать? Как не я не знаю, как он должен приплюснуть ещё что-то, да. Но на самом деле он пойдёт снизу вверх обратно вот это крутить нечего. Вот это крутить бесполезно, да, это константное выражение. Всё время возвращает, ну, то есть, 2 + 2 = 4 всегда. Ну, или стрингформат от одного и того же. Он поднимется на одну строчку выше, позовёт вот у этой штуки move next. Ему вернуть не нет такого айдишник был один. Он говорит: "О'кей, без проблем. Поднимаемся ещё выше." Позовёт вот у этой штуки move next. Та найдёт ему второй title хай. Пускай. Пускай их было два. Почему-то, да. Она найдёт ему хай. И он начнёт обратно в этом же порядке спускаться. Опять у базы попросит вот это. Опять у. Ну, и опять вот здесь посчитает, и второе значение зафигачит вот это вот хай 1840. Так бывает, да.
**Анатолий:** Это будет два этих отдельных, да. То есть, он отдельных значения. Он не к нему приплюснет. Не к low.
**Георгий:** Нет, нет, нет. Это два отдельных значения возвращает тоже генумератор. Это значит, что у тебя нумератор, как бы, будет и там, и там, да. То есть, вот это важный момент, хороший образ. Вот так оно работает. Вы такое можете получить. То есть, когда вы.
**Анатолий:** Не, я такое получу, но оно не выведет. Вы два значения должно до формы долетать?
**Георгий:** Нет, или вы се долетает, да, там летает. Случайно там режется на то. Если на списке он ещё показывается, то на форме будет резко сначала. Ну, такое бывает. Так. Когда модель данных вы там думали, что там одно значение, оно малциф. Ну, я как правило в join какой-нибудь соединяю там текст получать.
**Анатолий:** ID в данном случае, когда у тебя тайбал поднялось наверх, да, у тебя вдруг оно посчитало там что-то другое, да. Оно у тебя к ID прибавит или всё-таки нумератор новый будет?
**Георгий:** ID нумератор будет новый. Потому что представим, что ещё раз усложним, что у него на самом деле не только два тайтла, но и два айдишника гипотетически. То есть, это не айдишник, пускай будет, а там Uber ID какой-то, который бывает задваивается. Тогда он на самом деле вернёт четыре значения. В каком порядке? Исходя из того, как здесь записано. То есть, сначала будет low 1841, потом, ну, вниз прокрутил, поднимается наверх, докручивает ещё раз с айдишником. Дальше, пускай 1842. То есть, он выведет ещё раз ловом 1842. Потом опять вернул вернулся наверх до тайтла, потому что айдишники уже все прокрутили. Будет хай 1841, и опять ещё раз хай 1842. То есть, как бы, перемножение четыре значения.
**Анатолий:** Поэтому вот такие вот штуки просто так писать вот этот енам он включается, когда вот мы написали там from а или всегда.
**Георгий:** Всегда. Каждая каждая вот эта строчка – это просто у тебя за исключением одного специального случая, который вот Жора говорил, объясни. То есть, один специальный случай. Ну, вот такие специальные случаи бывают, да, когда у вас просто что-то вычислить выражение, которое не зависит от базы и всего остального. Оно всегда одно и то же. Не и нам возвращает. Но бывает, что вы, например, аа вычисляете уже вам всё известно, и вам надо проверить, да, как такое бывает. Ну, например, не знаю, пиво равно мое.
**Анатолий:** Нет. Ну, вот в этом примере какой-то сделать там. Давайте в этом примере не будем убить. Точно не надо. Дурацки. Как-то. Я же ниче.
**Георгий:** Ну, бывает, что надо проверить что-нибудь, что там у нас проверяет. Ну, то что юзер там, грубо говоря, какая-нибудь роль админ. Я не знаю, где там ещё что-то бывает, что конкретный юзер, давай конкретный юзер лежит в каком-то поле, ну, title равно там, ну, или равно не. Вот лежит в поле. Вот. Ну, отлично. Вот у тебя есть current user. Current user достаётся из того самого окружения, которое я говорил. Now в окружении валяется, и current user в окружении валяется. Это весь специальный subject такой. Что-то current контекст он называется прямо вот через двоеточие захардкожный subject текущий контекст. У него есть набор заранее известных свойств. Одно изменя.
**Анатолий:** Да. Есть user, а есть дата, время, и есть ещё что-то там, локаль какая-то. Ну, куча всякой.
**Георгий:** И есть у него, соответственно, предикат, который current user. Мы вычислили в юзерах. В процессе такое тоже есть, да.
**Анатолий:** Конечно. Я просто в процессе таки бас должен быть. Как она ещё будет работать?
**Георгий:** Так и работа. Мы через session вытаскиваем. У нас пакет сечередную, ну, се- это и есть это контекст.
**Анатолий:** А, ну, то есть, ты я что-то думал, что прямо двоеточек просто у тебя есть ключевое слово какое-то.
**Георгий:** Не, нет. Вот у тебя есть вот это current session или current context. Дальше у него берёшь свойство user и фигачишь его в user. То есть, он сюда закрутился. Это будет на нумератора просить тоже обязательно. То есть, конечно, никогда двух юзеров в сессии не бывает, но в целом там всё равно внутри это самое. Дальше у тебя уже пришёл сюда, поэтому и ты знаешь. Представим, что ты знаешь уже, как называется этот предикат, оп 43, О44. Вот это. То есть, можно как написать. Можно написать чуть, как бы, более понятно, но менее, как бы, изящно, да. Почти item, оптом 44 запихать его в переменную какой-то user. То есть, ну, без разницы, да. И потом написать user равно равно этим юзером. Вот это вернёт нумератор. Вот это будет нуумератор. А вот это нумератором тоже, ну, не будет никак, да. Потому что у тебя написано А = Б. Ты и А и Б на данный момент знаешь. Тебе просто надо сравнить. Оно не может быть много значения вернуть. Оно может быть либо прав, ну, либо истинно, либо ложно. Если ложно, оно дальше не пойдёт никуда. Если истино, то у тебя всё.
**Анатолий:** Если хоть одно ложно или как?
**Георгий:** А если хоть одно, если хоть одно из этих выражений ложно, дальше ничего не идёт. Всё, да. То есть, если у тебя, например, нет ни одного item user, всё. Ничего не пойдёт. Дальше ничего не выполнится.
**Анатолий:** Пётр, наслаждение. Немножко прости. Очень сильно.
**Георгий:** Hem user. Если ты не определён, то он тогда сработает как просто приравнивание. Ну, через равно оно, как бы, не сработает как приравнивание. Не рассказывает. Потому что если item user не определён, то здесь вот это выражение ложно. Дальше не пойдёт. Ты item user вообще не получаешь. Просто вот я получаю item up 44 item user. Что нет?
**Анатолий:** Я говорю, если не получаешь. Если верхнего нету.
**Георгий:** Тобой приравне.
**Анатолий:** Если у тебя нет верхнего, не не не среднего. Ладно, проточно, поэтому 44. Если ты уберёшь вот это, да, ну, ну, а что толку-то будет? Ну, это нам не интересно, да. Это это раз. И второй момент. Если у тебя юзер этим юзером несколько значений. Какой? Ну, юзертим юзер. У тебя нет.
**Георгий:** Ну, я сказал, это нумератор. Ещё раз, это нумератор. Вот это не нуумератор. Вот это не нуумератор. То есть, это вот всегда, как бы, когда он вернёт труда с. Если у тебя два нумератора сливается, ну, он просто будет каждый вертеть на совпадениях. Вернёт true или false, да. Если совпадает. То есть, вот это не вертит ничего. Он просто ему сказали там тринадцатый юзер и сорок второй юзер. Совпадает? Нет. Всё. Дальше не поехал. Пятнадцатый и пятнадцатый совпадают? Да. О'кей. Да, да. Едем дальше. Выполнить. Понятно или ничего не понятно?
**Анатолий:** Жора вообще спрашивал?
**Георгий:** Ты, да, ты спрашиваешь. Короче, вот это иable. То есть, мератор возвращает. Это нумератор возвращает. Это не возвращает. Это просто, как бы, тупая какая-то комарная операция. Она истина или ложь. Больше ничего. Чуть изящнее запись, что записывать. Давай, надо на рел примерах как-то вот прямо смотреть конкретные. Я не знаю, спрошены какие-то разбирать.
**Георгий:** Ну, можно, но мы просто чтобы до вот этих хоров дойти, вам ещё надо чуть-чуть дальше рассказать. Мы просто начинаем вот это ОП-4, да. Пишем. Вот, как бы, ну, мне чуть-чуть понятно. Я не знаю, людям.
**Анатолий:** Ну, O44, чтобы достать 44. Вот эти вот эти асы, как раз, да. Вот эти вот все дурацкие find object property, чтобы 44 не писать. Finder не знаю, груп какой-нибудь группы. Все все группы алиации.
**Георгий:** Нет, это ты знать должен. А все, ну, то есть, как ты должен знать, какое есть системное что-то ты должен знать. Оно есть в слованарях. Вот я создал группу, да. Я создал группы. Я могу э-э написать об object find property группы. Что что такое группа?
**Анатолий:** Имя группы. Name группа. Андрюха. Давай. Что такое группа для начала?
**Георгий:** Группа – это, ну, вот у нас есть платформе группа. Группа пользователей.
**Анатолий:** А причём тут оп? Причём тут? Ну, просто хочет понять у системных объектов как именуется.
**Георгий:** У них у них, если есть, у них известный словарь есть у системных объектов. Группа ты же не это задаёшь группе свойства какие-то дополнительные или задаёшь? Нет, не задаёшь. Они заранее предопределены платформы нашей. То же самое, как имя групп. Это известно заранее. Я думаю, что это будет называться group display name. Но в принципе всегда можно посмотреть и там, ну, известно, как она называется. А-а, alias у него нету у групп. Ну, у системных объектов. Alias системных объектов. Алиаса практически. Зачем соляци почется везде.
**Анатолий:** А, ну, ты имеешь в виду не прикладные, которые, а системные прямо системные.
**Георгий:** Ну, да, согласен, да. Я не туда пошёл. О'кей. Вот пока вот это понятно. Сейчас будем писать изящные. То есть, вопрос: а в чём юзер записывается как, ну, в смысле, во что касится? Тип какой? Какой тип у юзера? Вот он вот сам по себе юзер будет вот так вот определённо внутри. Каждый юзер – это вот это вот, да. Как он обозначается? Его имя пишется получается, не айдишник.
**Анатолий:** У каждого юзера есть айдишник.
**Георгий:** Понял. То есть, как бы, каждый вот у каждой сущности в системе сложно у нас айдишник есть. Они все всегда через вот чуть поизячнее написать то же самое, избежав дополнительные строчки, во-первых, а во-вторых, как бы, точно не ошибившись, можно вот так. Что тут написано? То есть, опять то же самое. Взять юзера, а потом у базы данных спрашивают уже не дай мне всё, что попадает под паттерн что-то такое. А здесь у нас уже будет чётко спрашива, ну, известно вот это вот, и вот это вот. Поэтому вас спросят так называемый **exact match**. Есть ли у тебя чёткое совпадение? То есть, если в твоих хранилищах конкретная тройка, значит этот 1861 О 44 user 12 этот, так сказать, просто exact match. Соответственно, если там что-то есть такое, она вернёт true, по сути. Если такого нет, она не верёт true или вернёт этого юзер. У тебя уже отсюда новых знаний не достаётся. У тебя здесь в этот момент вот это известно уже сверху взялось, и вот это известно, оно, ну, тшло через за тfalse при.
**Анатолий:** Ну, вот, да, true false. Но он тебе никуда не придёт. Он придёт в движок true false. Истина или ложь. Придёт по сути, да. Скажет, это правда, можно ехать дальше, или это неправда, дальше ехать нельзя.
**Георгий:** Поехали наверх.
**Анатолий:** Не, ну, почему номера. Я говорю, потому что если у тебя совпадут два значения, да, там с этим.
**Георгий:** Нет, это не нумератор. Не бывает значение. Смотри, Пётр, нельзя в базу записать два одинаковых факта. Это тоже ключевый вариант. Нельзя два раза сказать одно и то же, чтобы было две записи в базе. В базе всегда одна запись. Одно и тоже.
**Анатолий:** Ну, если мы говорим про то, что у тебя айтем он всегда один, да, то тогда да. Но если у тебя айтем, например, там несколько значений содержит, то он для каждого айтема сначала тебе проверку сделает, да, и для каждого.
**Георгий:** Ну, потом поверх знаходили это в прошлый раз в предыдущем нашим. Э, ну, мы именно тесто не проходили, что он именно будет тоже итерить ещё по subjectу.
**Анатолий:** Не, он вернёт нумератор какой-то, да. Если он там хоть что-то есть, он вернёт нумератор. Кто-то его крутанёт один раз сразу же для того, чтобы текущее значение занить. Так это работает база. Если ты exact match, она возвращает true или false. Движок возвращаемым значением пользуется, да. Если вернули true, он едет дальше вниз куда. Если он едет наверх, вариантов нету.
**Георгий:** Если у базы спросили паттерн мач, да, то есть, какие бывают паттерн мач? Сразу там напишу. Бывает вот такой. Ну, понятно, что бывает вот такой. Бывает вот такой. Ну, на тупую вот так. То есть, неизвестно ни то, ни другое. Дай мне всё, что с этим свойство вообще есть. Слева, справа известен. Этот этот неизвестен. Известен. Этот этот неизвестен. Вот. Он будет такие нумераторы. Соответственно, если её спросить что-то такое, она вернёт нумератор. Движок спросит: "Дай мне первый элемент нумератора." Тут она ему скажет: "Нет первого элемента сратора." Он говорит: "О'кей, тогда едем наверх." Так.
**Анатолий:** Ну, вот, да, пока понятно, вроде как работает. Теперь можно уже, наверное, брать конкретные волшебные примеры или сделать перерыв?
**Георгий:** Перерыв, да, да. Можно можно было на самом деле их после тройки переть.
**Анатолий:** Русски что-то подпали немного, а какие правила? Не знаю.
**Георгий:** То есть, поищите, какие вам интересны правила, какие посмотрим. А как её это? Ну, да, повесь трубку, потом про. Ну, да. Две записи уже всё записала. Давайте.
**Анатолий:** Стало, ой, блинки.

### Транскрипт видео "n3 p2"

**Георгий:** Что, на чём мы остановились? А давайте рулы смотреть настоящие. Всё. Вы же уже прошли назад, разбираемся. То есть, сначала вы будете их читать, потом рассказывать, как они работают. Прежде чем что-то писать, надо читать. Домаш задание. Домашнее задание. Вот открываешь этот домашнее задание, делаете каждый по этому самому, по вычливому свойству простому и что-нибудь такое посложнее.
**Анатолий:** Посложнее. Что? Ну, чу-нибудь попроще. Сначала давай найдём. Я уж сканул, блядь.
**Георгий:** Вопрос. Пока ищем. Пока ищем. А мы только мы используем допут, или это обще клиенты или используют?
**Анатолий:** Клиенты, скорее всего, не используют. Они не знают.
**Георгий:** Нет, а вообще во вселенной в нашей? Вот смотри. Вывести неархивные записи, где текущий пользователь что-то такое. Давай позорим. Фильтр какой-то. Ну, Assort Union. Сейчас разберёмся. Давайте его смотреть. Да. Ну, читайте, что сверху написано. Первые строчки. Давайте по очереди слева направо.
**Анатолий:** Серёжа, пропустим, наверное, читать умее.
**Георгий:** Почему умее?
**Анатолий:** Да не умею. Я подойду рифик. Я не хочу уметь.
**Георгий:** Что в этих первых пяти строчках? Сейчас подчинённые смотрит нащадку все. Так что так част.
**Анатолий:** Ну, вообще, что вот эти все пять строчек обозначаются? Они как бы все про одно и то же – это сборник чего-то. Это все получается, да. Все объекты, все пользователи, все аккаунты. Орде. На самом деле, это объявление, это объявление пространства имён, чтобы потом вот эти вот штуки не писать. Какие? Вот эти вот скобочки, чтобы не писать, да, а просто писать аккаунт двоеточие что-то. А не по.
**Георгий:** Ну, вот смотри, видишь, object. Я уже это объяснял. Object point property. Говорил же, Пётр, сломаешь ты его лами голову.
**Анатолий:** Не, а в чём здесь ролы-то? Урламен? Ну, нормально, что.
**Георгий:** Ну, чтобы все понимали, как это работает. То есть, вот там написано object, да. Да. АТП, и какой-то там у. Да. И в конце решёточка. И это называется об. Так вот таким образом мы префикс задали. То есть, это сокращение некоторое обновление. Дальше мы этот обично написано обжектя object двоеточие find property. А вот она. И это означает, что finder из пространства имён, которое определено этим префиксом. То есть, это то же самое. Вот вот эта запись – это то же самое, что написать скобочку открыть ТТП. Вот всё, что там про было написано. Решёточка в конце, блядь. И findм сокращение для. То есть, получается, вот вот эти пять – это просто, да, набор. Это всё превращается в одном файко. Под копосте. Все опять.
**Георгий:** Вот эти нет. Обк. Смотри, вот видишь, я использую object, чтобы здесь у написать.
**Анатолий:** А, вижу. Всё. Теперь поня.
**Георгий:** Ну, вставь туда. Это то будет. То есть, только в фигурных стопках прописать.
**Анатолий:** Ну, сделай то, чтобы непонятно будет. Фигурных или в каких? Ну, в таких, да. Вот эту. Угу. Просто сокращение. Я понял. Понял. Там, где обкля там, везде там же обкских местах.
**Георгий:** Ну, я просто удари бам. И после проти кавычка закры. То есть, чтобы вот такую херню длинную не писать, придумали префиксы, которые чуть после двоеточия, ну, пишешь, получается, коротко. Вот зачем это нужно. Понятно. Угу.
**Анатолий:** Я только не понимаю, какова у вас цель вот этого чего этого выражения всего?
**Георгий:** А всего? Ну, вот это набор. Вот первые пять строчек – это сокращение. Пока читаем просто. Да, это понятно. Цель вон сверху написано: вывести неактивные записи, где текущий пользователь что-то там. Ага. Создатель или руководитель создателя. Да. Вот цель тройки вычислить.
**Георгий:** Дальше Архи условия, да. Вот первую строчку здесь читаем. Что здесь является субъектом, что предикатом, что объектом для начала.
**Анатолий:** Это не вопрос. Да. Да. Следующее. Следующая будет. Так вот первая строчка, где мит, да. Да. Вот это вот. А что является презихатом? Что объектом? Что общим, да? Это триплет. Постройка. Ох. Получается, это subject find property.
**Георгий:** Нет, а смотри-ка, паттерн такой C пробел P пробел О. Subject object. Давай. Самое простое, что объектом является здесь. Нам нужно найти третью часть. Вот из этих объектов, что является конца. Пойдём, чтобы проще было.
**Анатолий:** Свойство. Ну, здесь слово. Какое из этих слов тут написано много слов. Какой из них является объектом?
**Георгий:** После вопросительным знати. Кто это вместе с вопросительными.
**Анатолий:** Это вот это вместе с короче, да, вот это object. Что предито является find property. Выполнить поиск. Да. Object find property. Да. А это одно действие.
**Георгий:** Ну, да. Просто мы не стали его записывать в этих фигурных скобках. Понимаешь? Это всего лишь сокращённая такая вот штука.
**Анатолий:** Это действие. Ну, предикадика факт.
**Георгий:** О.
**Анатолий:** Нет, предикал. Стоп. А факт, что? А факт – это есть стройка.
**Георгий:** Да.
**Анатолий:** Всё понял. Факт – это про строчка, да. Да.
**Георгий:** Так. И, соответственно, subjectом является creator. Me creator. Два слова объединённые в этом. То есть, это лист, как бы, да, является лист, который состоит из двух из двух слов: need и create. А что в нашем случае значит? И кто т – это шаблон записи, да. Почему? Потому что семантика вызова этого предиката object find property где-то у вас накаписано. Это волшебный предикат. То есть, object file property выводит справа AliAS не не Alias Property ID. На самом деле, он выводит. Получается, Property ID выводит, а слева ему в трубочках отдаётся аAS, что это контейнера там вот этого шаблона, да. Шаблон Лона, и аAS атрибут. А он выводит О42 тот самый, про который я говорил. Вот вот эта семантика вызвал. Этока есть. – это какой-то шаблон записи. Подчёркивание creator – это функцито. Это системный атрибут. Через какой-нибудь там, да. Не надо. Мы читаем, что здесь написано. Ладно. Вот. И он нашёл ему какой-то вот протир. Он потом засунет какой-то ОП 42 или что он там найдёт. Так у них бил есть свой. Ну, он все вот всё мы ему говорим, как бы, сходи в шаблон записи N, да. Там есть у него такой атрибут, и мы ему говорим: "Возьми у всех у этого нет, возьми у этого кйтора идентификатор сам Идентификатор свойства." Что 42? Не значение поля. А у у нас их атрибута. У атрибута возьми название, в смысле типа атрибуты или что?
**Анатолий:** Нет, вот открой атрибут в другом отте. А просто у атрибута атрибуты, да. Ты не значение берёшь атрибутов объекта. Открой атрибуты, покажи. Почему я лист тогда это, если я просто взял айдишник.
**Георгий:** Ну, как а как парамет тебе надо, ну, тебе два параметра надо передать. Как ты их по тройке передашь? Атрибуты. Открываем атрибут. Вот вот системное имя у него есть активная подписка. Да. А сам атрибут закрой. Вот он называется О 646. Видишь? Вот чтобы этот О 64046 найти, надо отдать вот это слово есть активная подписка. И второе слово, которое называется системное имя этого самого шаблона контраген. Надо просто это запомнить, что это, как бы, лист. Он возвращает. Ну, не это не лист. Он не возвращает лист. Ты ему говоришь, вот для этих двух слов, которые первое слово означает алиас нит. Это алиас этого шаблона контрагенты. Вот в случае, когда Серёга показывал, второе – Креатор – это алиас этого свойства. Есть активные подписки там или что. Вот ты ему просто два алиаса сообщаешь.
**Анатолий:** Слушайте, в языке выражения функции там creator, да, этой функции два параметра передавить, правильно? А я вот так не могу одним найти.
**Георгий:** Можешь. Ну, найди, как что тебе надо знать для того, чтобы найти этот 42. Он но он не уникальный, допустим, этот крейтер для он не глобальный, не уникальный. У каждого шаблона свой крейтор, своё свойство крейтор.
**Анатолий:** Глобально не уникальный. Он он уникален в рамках одного шаблона. Ага. Это только вот из-за этого догари. А, ну, вот, вот, вот так что-то понятно. Силиконвели, помнишь сериал, когда они пытались объяснить, зачем продукт. Ну, о'кей.
**Анатолий:** Не, подожди, можно совсем такой вопрос. Что значит почему в кавычках мит?
**Георгий:** Потому что это название шаблона записи. Какого-то шаблона записи. Название. В данном случае он называется мит у нас.
**Анатолий:** А, всё поня. Мное имя именно. Это я понимаю, да.
**Георгий:** Да. Системное имя гит какое-то, блядь. А кто – это системное имя атрибута создателя. Смотри, у тебя ты первой строчку. У тебя цель найти дишних атрибутов. Ага. Понимаю. В определённом шаблоне, который при условии, что он не в архиве. Ете.
**Анатолий:** Ненене, пока неважно. Первая строчка просто нам надо достать этот.
**Георгий:** То есть, вот ты начал стройку. Сначала я хочу на те сначала у нас ничего нету, как бы, и вот мы начинаем, как бы, собирать. Ну, да. У тебя для того, чтобы найти адишне поле, есть build проти. Вот в этой вчём там. И вот это параметры ты передаёшь в эту функцию, в этот бил. Ну, здесь ещё есть понятие оптимизации. Почему именно здесь стоит вот эта хрень, да. Потому что она всегда возвращает только оди одной один айдишник. То есть, тебе нужно идти всегдать.
**Анатолий:** Ну, да, чем более точечные запросы.
**Георгий:** Нет, запросы всегда пишутся от возврата наименьшего значения генератора, да, до к большему. То есть, если вверху у тебя будет максимально возвращаемо, то у тебя каждый раз при прокрутке все маленьки зарываешь мозги делаешь. Ну, просто понятно, да, что срочно сделали. Ну, надо потом это уже объяснять. Мы говорим эту запусти вот эту функцию на ходе. Эти параметры есть.
**Анатолий:** Не, ну, вопрос, почему вообще он в начале, да, стоит. Кого записать результаты?
**Георгий:** Вот это перемен у тебя уже. Зачем? Почему?
**Анатолий:** То есть, результаты того, что атрибут, ну, что вот это property функции выполнить с этим параметром. То есть, у нас, как кстати, понять, что вето.
**Георгий:** Я его могу куда-нибудь просто вынести. Можешь. Можешь вот этот взять и сделать.
**Анатолий:** Не очень поймал, что прямо выведи и всё. Это выражение результат функции. Мы с тобой вот в эту переменную запишется на то, что, ну, типа, вывести не мог. На самом деле, лист. То есть, я пытался лист вывести просто в текстовой атрибут. Почему-то думал, почему-то думал, что мне он шаблон записи лист. Нужно атрибут.
**Георгий:** Вот это функции найти отк. И ответом будет. Будет это. Ну, не ответ, а в прот. И подставится значение. Вот этого лист же это просто данных ссылка, грубо говоря. Вообще потенциально нет, которых один. И так же ас в рамках одного шаблона. Аср. Только у одного рахна отображаешь там, грубо говоря, в листах. Но теоретически результат тройки может быть несколько значений.
**Анатолий:** Теоретически, да. Здесь вернётся и нумератор, то есть, всё правильно говорится, только в нём будет одно значение всего лишь. То есть, здесь вернётся нумератор. Однозначения будет.
**Георгий:** О'кей. Зашли сюда, положили. Давай следующий шаг. С предыдущим не связано. Тоже всё вообще сложно.
**Анатолий:** Почему контейнер? Он должен содержать объект с ээ Ну ты прочитай тройку, что написано просто. А контейнер собрать объект.
**Георгий:** Не, ну, вот subjectом на пять. Давай по сначала subject контейнер. А, да. Это там идея. Ну, а выполнить это обas. Ну, в смысле, предикат.
**Анатолий:** Предикат, да. Забывай это слово, да. Objectas и обни. Да. А что так?
**Георгий:** Вот теперь по попробуем на русский перевести, что написано. Знак вопроса контейнер – это какая-то переменная. То есть, у какой-то фигни неизвестной нам пока object. То есть, не знаю по это не.
**Анатолий:** Ну, вот я как так сформулировал. Есть какая-то вот есть что-то неизвестное пока нам. Найди все субъекты, в которых. Да. У кого обктляс. Нет. Это не полево. Что ты говоришь ещё.
**Георгий:** Ну, где? То есть, по сути, как говорит правильно Жора, вот это надо читать: "Найди мне, пожалуйста, вот сюда в этот переменную контейнер все субъекты, у которых object alias нет." То есть, по сути, найти контейнер.
**Анатолий:** А почему наоборот мы тут в объекте указываем?
**Георгий:** Ну, а что такого? Он в обратную сторону мачит. Какая разница? Серёг, кто такой обяк вопросик в нашем случае он стороны. Что это значит обже. Т. Objectas – это такой же системный волшебный предикат. Он ничего не вычисляет. Просто как описываются шаблоны записи. Шаблоны записи описываются так. По А15 как раз вот этот object контрагенты. Ну, там object name есть. Оа 15. Это не ты по-русски написал или по-английски?
**Анатолий:** Там по-русски.
**Георгий:** По-русски.
**Анатолий:** Алиас у нас по-латинец.
**Георгий:** А по-латинец. О'кей. Да, значит, это object name, да. Это name ас. Соответственно, там контрактор ас там какой-то будет. Системные, соответственно, да, да, там какой-то катся. Без разницы, судья. Вот, соответственно, в базе такие валяются. Когда вот это спрашивает база, найдёт всё. У чего обляс он, соответственно, посмотрел, да, смотрит контейнер, у него пустой. Так правильно. Ему надо чем-то его зацепить. Значит он значит он пошёл, как бы, от обратного, да, смотреть. Да, значит он пошёл в базу вот с таким вопросом. Вот это он знает, это он знает. А а вот сюда накрутить всю херню, которая подходит. То есть, вернёт и нумератор опять и будет крутить. Здесь, конечно, неявная локация такая очень неявная. Языки программирова явно пишешь, где где присваемая его часть, где где, как бы, это вычисляемая, а тут всё, как бы, перемешано.
**Анатолий:** Блин, он же вернёт ОА15, грубо говоря.
**Георгий:** Он вернёт тебе вот тот самый, как я говорил, нумератор. То есть, но в реальности в нём будет всего один, который будет ОА15. Вот он сейчас вернулмератор. Пошли на следующую строчку. Что написано? Можно уже и так читать, как бы, item заранее известен у нас. То есть, мы сюда, как правило, ну, бывает и неизвестен. Бывает известен, когда он текущий объект, да, это контекст. Обычно это контекст текущего объекта. Если мы для какое-то вычисляемое свойство там. То есть, ну, здесь это для списка, я так понимаю. Он неизвестен бывает вообще.
**Анатолий:** Бывает бывает неизвестен. В системе у нас бывает. Вот ещё раз. Есть именно выходное значение. То есть, вообще у нас в системе два ключевых этих каких перемен входное и выходное. Здесь в качестве этого экспресшена на список здесь будет одно выходное – это айтем. Здесь входного нету. А в если ты по объекту там вычисляемый атрибут и так далее, там всегда есть на вход айтем от ID объекта. Вали, соответственно, будет мать значение атрибу.
**Георгий:** Да. Ну, представляем. Ладно. Item пускай неизвестен. Нам нигде не написали, что он известен. Пускай неизвестен. Соответственно, найди мне всё опять-то очень похоже на предыдущее, где контейнер равен какому-то. То есть, вот этому контейнеру, который мы уже сверху получили, да, в данный момент.
**Анатолий:** Да. Вот здесь здесь вычисли.
**Георгий:** То есть, сверху мы уже получили этот УА15. И пойдёт он тогда в базу.
**Анатолий:** А, стоп. Найти всё, что всё, что такое же, как у А15. Задача. Нет.
**Георгий:** То есть, вообще изначально задача тебе надо из какого-то конкретного контейнера, ну, то есть этого не контейнера, а шаблона вытащить все записи, которые не архивные, и при этом текущие пользователь там кто-то там у них создатель. Понял, что тут, как бы, пытаются сделать. Сначала они запомнили себе просто закшировали, какой там у создателя свойство, создатель какой там волшебный идентификатор. Теперь они начинают искать объекты. Пытаются найти, которые лежат в нужном нам этом шаблоне. Ник. Все подряд объекты. Пока просто все подряд. Сначала они нашли этот по аляцию. Они нашли этот контейнер, то есть, шаблон записи. Теперь они вот этой строчкой начинают искать все записи внутри этого шаблона. То есть, вот эта строчка она означает следующее: "Вот эта фигня принадлежит конкретному шаблону записи, которого мы выше определили." А мы уже выше его определили, да, на одну точку выше. Пока понятно.
**Анатолий:** А если бы ам был известен, то он бы в контейнер записывал?
**Георгий:** Да нет. Если был известен, то это была бы вот такая вот уже проверка. Она бы ноль, ну, то есть true или false вернула.
**Анатолий:** Контейнер у тебя уже есть. У нас сейчас айтем неизвестен.
**Георгий:** Сейчас неизвестен, да.
**Анатолий:** А у нас на списке неизвестен, да.
**Георгий:** Он здесь вот конкретно для списка неизвестен айтем, да. То есть, ты как раз айтемы выводишь, которые подпадут под фильтр.
**Анатолий:** А я наоборот думал, что как бы у нас на айтеме есть все записи, и как бы ты их потом уже фильтруешь.
**Георгий:** Нет, здесь, по-моему, вот и на системных фильтрах такого нет. На системных фильтрах такого нет. Они именно тебе позволяют туда вообще любую херню накрить, на самом деле. Хоть юзеров с группами объедини отдать. Что получится, непонятно, как бы, но можно. Даже такое делали. Значит, ну, да. То есть, можно туда за счёт системного фильтра всё поряд процесс можно купить на всех. Вот. Ну, соответственно, первые три строчки понятно выражение. То есть, он здесь будет крутить подряд все айтемы, которые внутри контейнера у А15. И по одному их выкручивает и вниз отда. Вот сначала он находит этот контейнер. Правильно? Нашёл А15 вот здесь. Потом нашёл здесь айтемы, которые в нём, в этом, подходящие к нему, да. Дальше идёт проверка, которые не. Да. Которые не. Это синтаксический сахар такой для отрицаний у нас сделан. Ну, и там справа написано уже такой в этом бизнес.
**Анатолий:** А, точно. Которая не содержится в архиве, да.
**Георгий:** То есть, архив в архиве они или нет. Означает, как бы, у нас так записано. Если что-то в архиве, то у него из disable трубы. То есть, вот это вот такая есть. Угу. Если что-то в архиве. Соответственно, если это неправда, то оно не в архиве. Так вот они сделализ, потому что из disabled false не пишут, как правило.
**Анатолий:** Просто, может быть, дурацкий вопрос. Если запись не в архиве, если шаблон не в архиве, то он получается уже активен.
**Георгий:** А почему мы не можем запись. Ну, ты мог удалить запись. Архивировать саму конкретную запись из шаблона, а мог не удалить. Если ты её заархивировал, то про неё напишется disable true. Где-то будет написано там объект 3050 is disabled true. Запи. Если заархивировать, если заархивировать, мы говорим у нас not, да. Мы говорим, не надо нам заархивированные. Ну, даже удалённые мы можем найти. Ну, нет. Удалён вообще в базе нет. Да. Айтем у нас уже, как бы, дафильтрован. Здесь вот сверху уже отфильтровался, и продолжается, как бы, строжает дофильтровывать. Получается вот этим вот условиям.
**Анатолий:** Здесь, Пётр, ещё одна штука, которую ты не дорассказал.
**Георгий:** Какая?
**Анатолий:** Ну, у тебя айтем изначально предзаполнился, да. Сейчас ты пошёл матчить уже практически айтем, да, причём мачится не только по айтемам, а ещё по другим связанным этим вещам. И он, как бы, он получается отсекать начинает из айтема теперь те, которые не удовлетворяют условия. Ну, мы потом раскрутим, как оно работать будет на инумератора.
**Георгий:** Ну, давай. Ладно. Сейчас мы разберёмся с бизнем смысл, потом раскрутим на инумератор. Так. Дальше. Следующая строчка. Вот эта.
**Анатолий:** А она не там стоит.
**Георгий:** Ну, да. Смысл у её. Потому что она каждый раз у тебя вычисляться будет при итератора. Ну, короче, сейчас до сейчас как увидим, как нумератор крутится, поймём, что её надо было наверх перетащить. Потому что нет смысла её вызывать. Она всегда один и тот же результат возвращает. И у них всего этого результат.
**Анатолий:** А зачем нам нечего пользователя? Потому что дальше мы его будем использовать. Потому что нам у нас сама цель вывести архитивные записи, где текущий пользователь. То есть, ты зашёл в систему, ты текущую ты сам себя определил, что у тебя вот, ну, чистый лист. Вот ты определяешь, что вот я есть такой системе, что это именно мне нужно, что я себе это ещё в этом зада.
**Георгий:** Ну, ты сам себя просто ты зашёл в систему, всё. Ты текущий юзер, авторизованный.
**Анатолий:** Я понимаю. Ну, да, я хочу кто-то взять и покажи мне, пожалуйста, записи, которые не заархивированы, и в которых создатель я. То есть, те, которые я создал. Ну, вот там написано сверху для текуще.
**Георгий:** А, ну, я понял. Создатель или руководитель создателя. Соответственно, для того, чтобы это считать, нам надо текущего пользователя вытащить. Он берётся из, как раз этих, а переменных окружения, да. Вот это говори. А сначала он вычисляет, кто пользователь текущий, а потом что он создатель вычислять. Правильно? Всё. Понял. Понял логику.
**Георгий:** Дальше, дальше. Тут забавная фигня, плохо отформатированная, поэтому фигово читаемая. Да. Это Георгий. Да. Георгий, плохо отформатирова. Понимаю. Все эти четыре строчки как раз вычисляют, что он создатель. Это просто моя фотография. Или он, или создатель, или менеджер создателя. Справа, видишь, он создатель. Ну, то есть, что тут написано волшебная фигня. Что вот в большом это является субъектом, что предикатом, а что объектом? Лучше опять с конца пойти, потому что может object, что union true получается.
**Анатолий:** Нет. Object true. Просто true, да.
**Георгий:** Так. Предикат. Так. Предикатор. Предика. Да. Почему? Ну, пробел забыли поставить, да. А а мы какую функцию. Ну, а сейчас мы поймём, что делает assert union. А, ну, я сю не понимаю. То есть, assert union. Семантика вызова Assort Union такая: у него передаётся списочек здесь assert union. Ну, и здесь или true. Ну, тут лучше всегда использовать. Больше ничего не надо. То есть, union true. Вот это вот всегда эти предикат с объектом, да. Ну, иногда можно знак вопроса поставить, если вам надо выяснить, правда ли что-то или неправда. А вот сюда в список отдаётся список формул. Вот. И тут проверяется, что вот это работает, и вот это работает. И оно это вместе объединяет оба условия, да, или то, или другое, или третье. То есть, он каждое условие крутит по отдельности, и результаты добавляет.
**Анатолий:** Вставляют их в переменные в общие, которые объявлены внутри.
**Георгий:** Которые внутри объявлены, да. То есть, я правильно понимаю, что это всё суммирует все выше перечисленные свойства?
**Георгий:** Нет, это только суммирует всё, что вот здесь забрано, потому что давай теперь разберёмся. Вот мы нашли, что предикат с объектом вот это union true, а здесь снова формулы. То есть, вот это subject. Давай теперь каждую формулу разберём. Каждая формула – это триплеты. Набор триплетов через точку зелёный. Первая формула, на самом деле, вот она. Вот фигурная открылась, фигурная закрылась. Что написано? Тепущий пользователь. Покажи мне текущего пользователя.
**Анатолий:** Нет, нет, нет. Что у нас айтем? Что у нас тут creator? Что у нас а это мы до этого посчитали Core. У нас определён, да. Соответственно, мы идём как можно сказать, справа налево идём, да, типа нет. А ты что у нас тут вообще не определённо, а это определённо. А у нас всё у нас определено в этой строчке. Соответственно, он просто проверяет, что это можно или нельзя. Ну, есть такое выражение. То есть, истинно это выражение или ложно. То есть, автор текущий пользователь.
**Георгий:** Да нет, как бы, спрашиваю. Аз, а второе вот здесь вот идёт какой зер? А мы ещё даже не писали, да. Мы не использовали проти Creator.
**Анатолий:** Нет, как первый раз используем, да. А второе выражение вот оно. Оно из двух стоит. Из двух уже стоит. Из двух троечек. Видно?
**Георгий:** Видно.
**Анатолий:** Давай Андрюха. У кого есть про дела. Давай, давай. Подска.
**Георгий:** Ну, ты и прочитай первую скрочку. Поэтому так. Во втором что делает выражение, да. Что определено. А этим определённо уже.
**Анатолий:** Нет.
**Георгий:** Почему нет? Item вот здесь определили. А дальше этим известен. Всё. Значит, осталось нахопй пользуется. Значит, сам не могу.
**Анатолий:** А я думал я этом мы здесим так property creat тоже.
**Георгий:** Так, да. То есть, вот это у нас уже item. Это какой-то будет там 343 объекта, которые вот здесь вот закрепили. 343 Property Creator там О 15. А сверху то, что мы user car от это не относится к нему, да. Так же здесь и нету. Вот вот вот эта вот строчка и вот эта строчка независимо считается, потому что union то, что передаётся.
**Анатолий:** А так это жёстко. То что они без пробела – это ничего не значит. Без точки.
**Георгий:** Ну, у тебя здесь я говорю, вот это семантически выглядит так: Ass union. Вот здесь здесь true. В конце здесь список из формул. Вот формула, вот формула. Ещё могут быть. То есть, они между собой не это. Вот у тебя первая формула вот здесь закончилась. Вот эта вот закончилась. А вот вторая формула вот здесь началась. Вот здесь закончилась. Она из двух троек состоит. Первая тройка item известен, property creator известен. Юзеер первый раз встречаю.
