---
prompt: |
    Transcribe the whole length video in Russian in a very detailed manner. Second by second, do not miss any part or fragment. Read carefully the screen content and describe it along with the audio transcript. Refer to the `n3_examples_collection.md` file with code snippets used in the video. The video is about Notation3/N3/Turtle expressions usage in Comindware Platform 5. Male name A. Female name N. For code blocks use `tutrle` language id as in the attached markdown. Output structured markdown with headings and summaries for each logical section in the video. Before the transcript generate a summary of the video and then a concise beginner guide on N3 usage.
answer: |
    Вот подробное содержание, руководство для начинающих и полная транскрипция предоставленного видео по выражениям N3 в Comindware Platform.
---

# Краткое содержание видео

В этом обучающем видео спикер по имени А. (Попович Александр) объясняет основы использования выражений N3 (Notation3), также называемых "тройками", в платформе Comindware для коллеги по имени Н. (Наташа). Он подробно разбирает базовую структуру триплета, состоящую из трех компонентов: субъекта (обычно ID записи), предиката (свойства) и объекта (значения этого свойства).

А. использует простую схему в Paint для визуализации этой структуры и объясняет, как использование переменных вместо конкретных частей триплета позволяет выполнять мощные запросы к данным. Он представляет ключевые системные переменные, такие как `?item` (контекст текущей записи) и `?value` (конечный результат выражения).

Руководство охватывает различные практические применения, включая:
*   Фильтрацию записей по значениям конкретных атрибутов.
*   Получение значений из связанных записей (например, получение кода статуса из записи-справочника).
*   Использование логических операторов, таких как `AND` (неявно между строками), `OR` и `NOT`.
*   Работу с сессионными переменными для получения контекстно-зависимых данных, таких как текущий пользователь или дата.
*   Использование встроенных функций для вычислений (`average`, `count`, `product`), манипуляций со списками (`ascending`, `at`) и форматирования строк.
*   Важность оптимизации запросов путем правильного порядка условий для уменьшения набора данных на ранних этапах (концепция "среза данных").

На протяжении всего занятия А. ссылается на коллекцию готовых примеров N3 для иллюстрации сложных сценариев, таких как создание гиперссылок, обработка данных из интеграций и реализация условной логики.

# Краткое руководство для начинающих по N3 в Comindware

Это руководство обобщает ключевые концепции для написания выражений N3 ("троек") в Comindware, как объяснено в видео.

## Основная концепция: Триплет

В основе N3 лежит простая структура под названием **триплет**, состоящая из трех частей: **Субъект**, **Предикат** и **Объект**.

```
<Субъект> <Предикат> <Объект>.
```

*   **Субъект:** То, о чем вы говорите. В Comindware это обычно запись или переменная, представляющая запись.
*   **Предикат:** Свойство или атрибут субъекта.
*   **Объект:** Значение этого свойства для данного субъекта.

**Пример:**
`?item <СвойствоСтатус> "Завершено".`
Этот триплет проверяет, имеет ли `СвойствоСтатус` текущего элемента (`?item`) значение "Завершено".

## Использование переменных для запросов

Вы можете находить информацию, заменяя части триплета переменной — словом с префиксом в виде вопросительного знака (например, `?мояПеременная`).

*   **Найти значение:** Если вы знаете субъект и предикат, вы можете найти объект.
    `?item <СвойствоДатаСоздания> ?дата.` — Это поместит дату создания текущего элемента в переменную `?дата`.
*   **Найти субъект:** Если вы знаете предикат и объект, вы можете найти все субъекты, которые соответствуют условию.
    `?любаяПретензия <СвойствоСтатус> "Завершено".` — Это найдет все претензии (`?любаяПретензия`), у которых статус "Завершено".

## Системные переменные: `?item` и `?value`

Comindware предоставляет специальные системные переменные:
*   **`?item`**: Представляет текущую запись, в контексте которой выполняется выражение (например, запись, открытая на форме).
*   **`?value`**: Это конечная переменная для вывода. Результат вашего выражения должен быть присвоен `?value`, чтобы он был отображен или использован системой.
    `?мойРезультат -> ?value.`

## Объединение условий: Логика И и ИЛИ

*   **И (AND):** Когда вы пишете несколько триплетов друг за другом, они объединяются логическим «И». Все условия должны быть истинными.
    ```turtle
    # Найти задачи, которые в работе И назначены на текущего пользователя
    ?item <СвойствоСтатусЗадачи> "В работе".
    ?item <СвойствоИсполнитель> ?текущийПользователь.
    ```
*   **ИЛИ (OR):** Чтобы использовать «ИЛИ», необходимо обернуть альтернативные условия в специальный блок `or{}`.
    ```turtle
    or
    {
        ?item <СвойствоИсполнитель> ?текущийПользователь.
    }
    or
    {
        ?item <СвойствоВозможныйИсполнитель> ?текущийПользователь.
    }
    ```

## Использование функций

N3 позволяет использовать функции для вычислений, форматирования строк и манипуляций со списками. Средняя часть триплета становится именем функции.

**Пример:** Вычисление среднего значения из списка цен.
`?списокЦен cmwnullable:average ?value.`
Здесь `?списокЦен` — это входные данные (Субъект), `cmwnullable:average` — это функция (Предикат), а `?value` — это результат (Объект).

***

# Подробная транскрипция видео

### Секция 1: Введение в триплеты N3 (00:00 - 01:09)

**Краткое содержание:** Спикер А. знакомит с базовой концепцией выражений N3 как "триплетов". Он рисует схему, чтобы показать, что триплет состоит из трех частей: ID записи (субъект), свойства (предикат) и его значения (объект). Эта структура является основой для выполнения запросов к данным.

**Транскрипция:**

(00:00) **Экран:** На экране интерфейс Comindware Platform 5. В основной области отображается форма для элемента с ID "85749". В фоновом режиме виден видеозвонок в Яндекс Телемост с двумя участниками: "Наташа" (Н.) и "Попович Александр..." (А.). А. демонстрирует свой экран.
**А.:** То есть, в принципе, наши тройки достаточно простые.

(00:05) **Экран:** А. переключается в приложение Microsoft Paint. Виден белый холст с оверлеем видеозвонка справа.
**А.:** Э-э, и состоят из триплетов.

(00:10) **Экран:** А. рисует карандашом в Paint три пустых овала в ряд.
**А.:** И, в принципе, и клиентам, и коллегам своим рассказываю для простого понимания, как...

(00:24) **Экран:** А. указывает курсором на самый левый овал.
**А.:** Э-э, в левой части, в левой части всегда идут, э-э, ID записи.

(00:30) **Экран:** А. пишет "id зап" внутри первого овала.
**А.:** То есть, с левой части всегда идут записи зачастую. То есть это может быть, э-э, в случае... То есть у нас есть ещё некие системные переменные.

(00:46) **Экран:** А. пишет "? item" под овалами.
**А.:** То есть это вопрос item. Он означает, что мы достаём контекст текущей записи. То есть, если мы пишем, допустим, э-э, в вычисляемом атрибуте,

(01:02) **Экран:** А. на мгновение переключается на окно Comindware, указывая курсором на раздел "Вычисление неисправности", затем возвращается в Paint.
**А.:** то у нас итемом будет вот конкретная запись, в котором мы откроем для вычисления.
**Н.:** Угу.

### Секция 2: Системная переменная `?value` и предикат (01:09 - 01:39)

**Краткое содержание:** А. объясняет вторую ключевую системную переменную, `?value`, которая всегда используется для хранения конечного результата выражения. Затем он определяет среднюю часть триплета как "свойство" (предикат), которое указывает, к какому атрибуту записи осуществляется доступ.

**Транскрипция:**

(01:09) **А.:** И вторая переменная у нас системная — вопрос value.

(01:13) **Экран:** А. пишет "? value" под "? item" и обводит его в круг.
**А.:** Она говорит о том, какой результат мы вернём. То есть в эту переменную у нас всегда кладётся результат.
**Н.:** Угу.
**А.:** Наших вычислений. То есть с левой части у нас всегда записи,

(01:31) **Экран:** А. указывает на средний овал и пишет над ним "prop".
**А.:** э-э, в средней части у нас всегда property. Что такое property?
**Н.:** Свойство.
**А.:** Да, свойство.

### Секция 3: Понимание `findProperty` и логики триплетов (01:39 - 03:32)

**Краткое содержание:** А. переключается в редактор кода, чтобы показать практический пример выражения `findProperty`. Он объясняет, что "свойство" в триплете может быть сложным, содержащим имя шаблона и имя атрибута. Это позволяет системе понять, какие записи и атрибуты запрашивать. Затем он определяет третью часть триплета как "значение". В завершение он иллюстрирует различные способы использования триплета для запросов, оставляя разные его части неизвестными (в виде переменных), и подчеркивает, что центральная часть "свойство" всегда должна быть известна.

**Транскрипция:**

(01:39) **Экран:** А. переключается в окно редактора кода (Visual Studio Code), где отображается файл с множеством выражений N3.
**А.:** То есть у нас... какой-нибудь простой тройкой есть у меня...

(01:46) **Экран:** А. прокручивает файл с кодом в поисках подходящего примера. Он останавливается на фрагменте кода.
**А.:** Ну вот, допустим, хорошая тройка.

(02:02) **Экран:** А. копирует строку кода: `("ProjectPlans" "Otvetstvennyy") object:findProperty ?contact.`. Он возвращается в Paint и вставляет ее как текст над овалами.
**А.:** То есть мы объявляем некий find property... Можно, интересно, так вставить? Текст... А, то есть посередине у нас всегда property.

(02:16) **Экран:** А. водит курсором по вставленному тексту в Paint.
**А.:** И по этому property очень легко понять, что мы конкретно вообще ищем здесь.
**Н.:** Угу.
**А.:** То есть если мы разбираем find property, то у нас всегда здесь указан название шаблона указано,

(02:29) **Экран:** А. указывает на `"ProjectPlans"` во вставленном тексте.
**А.:** а здесь атрибут искомый.
**Н.:** Угу.
**А.:** То есть по property мы можем понять, с какими записями мы, э-э, в данный момент оперируем.

(02:40) **Экран:** А. обводит средний овал "prop".
**А.:** То есть мы оперируем, допустим, здесь записями шаблона ProjectPlans. И мы оперируем вот здесь с атрибутом "Ответственный".

(02:50) **Экран:** А. указывает на самый правый овал и пишет над ним "знач" (значение).
**А.:** А вот третий элемент, в принципе, самый простой — это значение. То есть здесь мы указываем значение, которое будет храниться в атрибуте, который указан в property, в шаблоне вот этом, и в этих записях.
**Н.:** Угу.

(03:13) **Экран:** А. красным цветом в Paint рисует пустые овалы под первым и третьим овалами в новом ряду, показывая, что они могут быть неизвестными переменными.
**А.:** И мы можем как угодно жонглировать. То есть у нас могут быть, э-э, неизвестными как наш триплет. То есть у нас может быть неизвестным, э-э, левый, левая часть триплета... Надо как-то отметить красиво. То есть у нас может быть неизвестным вот это и вот это, но центр у нас всегда должен быть известен.
**Н.:** Всегда.

### Секция 4: Логика фильтрации и условные операторы (03:32 - 05:41)

**Краткое содержание:** А. подробно описывает, как работает фильтрация, когда части триплета неизвестны. Если левая и правая части — переменные, система вернет все записи и их соответствующие значения для данного свойства. Он объясняет, как проверить на непустое значение с помощью `?.`. Затем он демонстрирует, как указание конкретного значения справа фильтрует записи слева. Вводится структура `if-then-else`, показывающая, как выполнять условные действия в зависимости от того, вернет ли запрос результат.

**Транскрипция:**

(03:32) **А.:** Надо как-то отметить красиво. То есть у нас может быть неизвестным вот это и вот это, но центр у нас всегда должен быть известен.
**Н.:** Всегда.
**А.:** Да, всегда. У нас может быть... У нас может быть неизвестна только левая часть... центр и правая часть у нас известна. И у нас может быть неизвестна только правая часть, центр и левая у нас известны.

(03:58) **А.:** И что тогда в таком... в каждой из этих случаев происходит? В случае, если у нас неизвестно... то есть мы здесь задали какие-то переменные, которые у нас выше никак не присваиваются. То есть они неизвестны в контексте тройки ещё.

(04:13) **Экран:** А. начинает писать имена переменных в нарисованных им красных овалах. `?plans` в левом овале и `?statVal` в правом.
**А.:** Какие-то случайные. То есть здесь мы там написали, допустим, plans... здесь у нас там, не знаю, ответственный...
**Н.:** Иванов, да.
**А.:** Не, не, допустим, если мы статус здесь проверяем, статус. А и здесь мы просто там задали переменную... status val. То в таком случае у нас вот сюда... здесь будут храниться все записи всего шаблона, у которых, э-э, есть статус какой-либо.
**Н.:** Угу.

(05:04) **А.:** А здесь, получается, в правой части у нас будут храниться все статусы всех планов, у которых, которые вообще заполнены.

(05:17) **Экран:** А. рисует вопросительный знак с точкой `?.` внутри нового овала.
**А.:** Есть ещё одна системная штука — это проверка на пустоту. Она вот таким образом осуществляется, то есть вопрос-точка. Зачастую её используют только в правой части,

(05:28) **Экран:** А. рисует стрелку от овала `?.` к овалу `?statVal`.
**А.:** и она как раз проверяет, что у нас значение не пустое. То есть мы в явном виде проверяем, что у нас в этом атрибуте лежит не пусто.
**Н.:** Угу. А её можно... можно и там, и там поставить, допустим, и в ID, и в property? Нет? Ну, в property понятно, что нет. А вот в первой части можно её поставить?
**А.:** Ну, это зачастую в левой части не имеет смысла, потому что, в принципе, если мы какую-то переменную случайно объявляем, то мы и так проверяем эти записи.
**Н.:** М-м.
**А.:** То есть особого какого-то смысла нет в этом.
**Н.:** А, ну да. Да, да, всё. Понятно. Там же значение-то, мы на значение на пустоту проверяем.
**А.:** Да-да-да.

### Секция 5: Практический пример — фильтрация по статусу (05:41 - 07:35)

**Краткое содержание:** А. приводит конкретный пример фильтрации. Он демонстрирует, как найти все записи с определенным статусом ("выполнено"). Он объясняет, что если левая часть триплета — это переменная, а правая — известное значение, запрос отфильтрует записи и поместит подходящие в эту переменную. Затем он показывает самый распространенный случай использования: взять текущую запись (`?item`), найти значение в одном из ее атрибутов и сохранить его в новую переменную для дальнейшего использования.

**Транскрипция:**

(05:41) **Экран:** А. рисует 'X' над средним черным овалом (предикатом).
**А.:** Э-э, в случае, если у нас правая часть известна, то мы тогда начинаем фильтровать записи.

(06:24) **Экран:** А. пишет "вып" (сокращение от "выполнено") в самом правом овале среднего ряда.
**А.:** То есть мы здесь там какой-то статус типа "выполнено" проверяем. И так как мы вот здесь не знаем, ну, не указываем в явном виде, из каких записей нам фильтровать, и мы указываем какую-то случайную, неизвестную переменную, то в эту переменную у нас положатся те записи, у которых в атрибуте "статус" лежит значение "выполнено".
**Н.:** Угу.
**А.:** То есть таким образом мы отфильтруем весь справочник и положим сюда все записи, у которых выполнено.
**Н.:** Угу.
**А.:** И, соответственно, последний вариант, который у нас остался, мы знаем записи. К примеру, это, допустим, item.

(07:07) **Экран:** А. рисует стрелку от текста "? item" к левому овалу нижнего ряда.
**А.:** То есть возьми из текущей записи в атрибуте "статус"... и вот сюда там выведи какое-то значение.

(07:15) **Экран:** А. рисует стрелку от правого овала нижнего ряда к тексту "? value".
**А.:** То есть здесь можно как прописать вопрос value, сразу вернуть результат, можно там положить в какую-то переменную status val. И эта переменная у нас будет хранить значение статуса в конкретных этих записях либо в конкретной одной записи.
**Н.:** Угу.

### Секция 6: Работа с реальными примерами кода в редакторе (07:35 - 09:21)

**Краткое содержание:** А. переходит в интерфейс Comindware и редактор выражений, чтобы показать, как эти концепции триплетов применяются в реальных сценариях. Он демонстрирует фильтрацию записей `ProjectPlans`, где "Ответственный" — это текущий пользователь. Затем он объясняет более сложный пример со связанными записями: получение статуса "Обращения", который является ссылкой на другую запись, и последующая проверка атрибута 'Код' этой записи статуса. Это знакомит с концепцией цепочек триплетов для навигации по связям между данными.

**Транскрипция:**

(07:35) **Экран:** А. переключается обратно в интерфейс Comindware Platform, который находится в разделе "Формы" для шаблона. Он открывает окно "Редактор выражений". Виден код из примера в Paint.
**А.:** Угу.
**Н.:** А мы её... вот через value, смотри, если мы вот, э-э, ищем статус val, а, мы её не обязательно же задаём через item value? Или обязательно? Если мы её просто пропишем в самом конце, то она будет и так выдаваться, да?
**А.:** Э-э, все тройки, э-э, зачастую, кроме правил...
(07:59) **А.:** вроде... Да, кроме правил. Они и фильтры системного на таблице требуют вопрос value. А... чтобы вернуть какой-то результат.
**Н.:** Угу.
**А.:** То есть на системном фильтре таблицы у нас достаточно вопрос итема,

(08:15) **Экран:** А. переключается обратно в окно Paint и рисует "? item" вверху.
**А.:** и он там уже выступает не в роли контекста текущей записи, а в роли итератора по каждой записи справочника.
**Н.:** Угу.
**А.:** И итемом является результатом для системного фильтра. То есть он вернёт все записи, которые у нас подошли под условия.
**Н.:** Угу.
**А.:** Так, как раз у меня эта троечка...

(08:32) **Экран:** А. сдвигает окно Paint в сторону, открывая редактор выражений Comindware с кодом фильтра `ProjectPlans`.
```turtle
("ProjectPlans" "Otvetstvennyy") object:findProperty ?contact.

cmw:securityContext cmw:currentUser ?user.
?template object:alias "ProjectPlans".
?item cmw:container ?template.
?item ?contact ?user.
```
**А.:** сейчас я её тоже посмотрю.

(08:34) **Экран:** А. переключается на основное окно Comindware, где показан список форм. Он нажимает на "http: Основная форма", и открывается редактор форм. Затем он открывает редактор выражений для атрибута.
**А.:** Вот, в принципе, вот эту часть пока можно исключить... Вот эту... юзер нам надо оставить.

(08:51) **Экран:** В редакторе выражений А. выделяет и изменяет код.
**А.:** Вот, к примеру, тройка. Мы говорим, что нам нужно вывести, э-э, в таблице все записи шаблона ProjectPlans, у которых в ответственном, э-э, лежит текущий пользователь.

(09:08) **Экран:** А. указывает на строку `cmw:securityContext cmw:currentUser ?user.`.
**А.:** Вот эта штучка, в принципе, её учить не нужно. Э-э, все вот такие системные штуки у меня, в принципе, есть в этих примерах троек. Можно их как-то выписать отдельно, наверное. То есть вычисление текущего пользователя, вычисление текущей даты. Угу. У меня тоже есть там... где-то можно найти. Вот она, системная штучка.

### Секция 7: Разбор сложной тройки и оптимизация запросов (09:34 - 11:13)

**Краткое содержание:** А. разбирает сложный пример, который фильтрует данные по связанным записям. Он показывает, как получить значение из ссылочного поля (статус обращения), а затем, используя это значение (ID записи статуса), получить другое значение (код статуса) из связанной записи. Также он вводит важную концепцию оптимизации — "срез данных" (data slice) — и объясняет, что порядок условий в тройках имеет значение для производительности. Запросы должны быть структурированы так, чтобы сначала применялись наиболее строгие фильтры, максимально сужая набор данных для последующих операций.

**Транскрипция:**

(09:34) **Экран:** А. показывает код в редакторе.
**А.:** И всё. И, получается, в этой тройке у нас что происходит? У нас вот эти записи, они известны, то есть это все записи шаблона. У нас известно, по какому атрибуту мы это ищем, по какому property. И у нас вот эта правая часть известна, что это текущий пользователь. Таким образом, мы в итеме оставим только те записи, у которых в ответственном лежит текущий пользователь.
**Н.:** Угу.
**А.:** Мы отфильтруем.
**Н.:** То есть мы там ищем сначала в шаблоне атрибут через find property... это именно значение атрибута, потом задаём, э-э, юзера, и потом кладём это всё оба в item.
**А.:** Да-да-да.
**Н.:** Угу.
**А.:** Давай теперь какую-нибудь троечку интересную посмотрим.

(10:25) **Экран:** А. выделяет другой, более сложный фрагмент кода в редакторе.
**А.:** Вот, допустим, со статусом. Тоже классная троечка. Очень часто используется. Вот это пока исключу я, и вот это нам тоже пока не нужно. То есть у нас есть шаблон "Обращений". И у обращения есть ссылка на справочник статусов обращения.
**Н.:** Угу.
**А.:** И... как нам проверить, что у нас, допустим, или вывести нам все обращения, у которых статус обращения там, допустим, "черновик". Так как это у нас ссылочное поле, то вот здесь у нас будет лежать айдишник.
**Н.:** Угу.
**А.:** И... по сути, на айдишник, э-э, можно там сравнивать, э-э, напрямую со строкой... но это тоже нужно махинации отдельные проводить. Нам, по идее, лучше завязаться на код, потому что айдишник может смениться, там кто-то поменяет, пересоздаст запись и так далее. И вот как нам проверить, э-э, что у нас в определённом... определённый код стоит, черновик? То есть мы из текущей записи, или, допустим, из списка записей, в случае системного фильтра, достаём значение, которое лежит в ссылочном атрибуте "статус обращения". И кладём её в некую переменную. Такой важный относительно нюанс, который, в принципе, помогает мне, как минимум, тройки делать читабельными, э-э, я стараюсь, э-э, property называть, то есть название атрибута и постфикс "Property", чтобы не путаться. А-а, сами значения я в конце заканчиваю "val"-ом. То есть название атрибута "val". Помогает сильно не путаться.
**Н.:** Угу.
**А.:** То есть мы говорим: из текущей записи возьми нам значение, э-э, айдишник записи на статус, который проставлен у нас. И всё, мы вот здесь уже знаем запись, соответственно, если статус у нас заполнен. Из этой записи мы можем получить код. То есть у статуса есть атрибут кода. Тоже мы объявляем, э-э, property уже в шаблоне статуса и достаём из него property кода, статус код.
**Н.:** Угу.
**А.:** И говорим, что вот... вот эта запись у нас уже известна, мы её достали, посмотри, какой у неё код. Достаём property кода и возвращаем сюда код. И нам нужно уже как-то отфильтровать это. То есть проверить, что у нас код равен вот какому-то определённому. То есть там достаточно скопировать эту же переменную и приравнять её, допустим, к "Q0". Это статус "черновик".

### Секция 8: Операторы сравнения и логические операторы `NOT` и `OR` (11:00 - 13:34)

**Краткое содержание:** А. объясняет синтаксис операторов сравнения: `==` для равенства и `!=` для неравенства. Он также представляет логический оператор `not` как альтернативу `!=` и оператор `or`, который позволяет выполнять альтернативные наборы условий, что является аналогом `if-else`, но часто работает быстрее и эффективнее.

**Транскрипция:**

(11:00) **Экран:** А. продолжает работать в редакторе выражений Comindware.
**А.:** Ещё одна важная штучка в тройках: все триплеты последовательно работают как, э-э, операция "и". Что это значит? Это значит, что все строчки будут выполняться до тех пор, э-э, пока каждая из них выполняется. Что это значит? К примеру, у нас вот здесь не выбран статус. Соответственно, вот это всё не будет выполняться дальше.
**Н.:** Угу.
**А.:** Потому что вот это условие у нас не выполнится. Если у нас, э-э, не заполнен код в записи статуса, то у нас вот это выполнится, вот это выполнится, но здесь будет пустота. Вот это уже не выполнится.
**Н.:** Угу.
**А.:** То есть у нас важно, чтобы у нас каждое условие проходило. То есть это работает как оператор "и".
(12:12) **А.:** То есть если мы, допустим, вернём, откатим то, что было до этого, ещё проверяю тут на креатора, и, допустим, мы вот такой штучкой заморочимся, вернём там юзера... Вот, к примеру, допустим, нам ещё нужно проверить, что у нас у обращения ещё... То есть нужно отфильтровать все обращения и вернуть список обращений, у которых создатель — сам пользователь, и статус определённый. И у нас, получается, сначала отфильтруются статусы, то есть останется список в итеме тех обращений, у которых статус "черновик", и потом у этих записей, у всех, отфильтруется ещё по создателю, в которых равен текущему пользователю. То есть это будет работать как раз как операция "и". И это, и это.
**Н.:** Угу.
**А.:** Плюс у нас есть возможность, э-э, делать оператор "или".

(13:34) **Экран:** А. вводит ключевое слово `or` и фигурные скобки `{}` в редакторе.
**А.:** Он у нас вот такой конструкцией, то есть через Ctrl+пробел у нас подсвечивается, в принципе, часто... часто возможные штуки, всякие операторы. То есть `if`, `or`. Ну `if` он, на самом деле, лучше не пользоваться, он, э-э, медленнее работает, чем `or`, и в принципе, решает задачу `or`-а.

### Секция 9: Работа с переменными и разбор сложных сценариев (13:58 - 18:31)

**Краткое содержание:** А. показывает, как работать с локальными переменными в триггерах и процессах. Он объясняет, как объявить переменную (`variable ... operator:replace`), как получить ее значение из контекста (`session:context var: ...`), и как модифицировать ее, например, склеивая строки (`cmwstring:concatenation`). Он разбирает сложный кейс по логированию ошибок, где в одну переменную последовательно собирается текст всех ошибок, возникших при обработке интеграционных данных.

**Транскрипция:**

(13:58) **Экран:** А. показывает сложный код с оператором `if`.
**А.:** То есть, к примеру, если у нас, мы, допустим, ифкой хотели прописать такую штучку. То есть проверить, что у нас статус здесь не пустой. Если у нас статус не пустой, тогда там... достань текущий статус и там отфильтруй, чтобы он был вот в таком-то. Иначе там отфильтруй по текущему пользователю. То есть, в принципе, вот эти конструкции... ифка нам особо-то и не нужна.
**Н.:** Угу.
**А.:** Как это переписать на орку? Так как мы уже знаем, что у нас все строчки выполняются последовательно, если у нас там первая не выполнилась, то у нас дальше не пойдёт, то мы можем просто вот это вот всё, весь `then` скопировать в первую `or`. А то, что у нас было в `else`, скопировать во вторую `or`. Тогда что у нас получается? У нас сначала пойдёт проверка по статусу. Если у нас по статусу не удалось отфильтровать, то он отфильтрует по пользователю.
**Н.:** Угу.

(15:30) **А.:** Плюс у нас, есть ещё одна важная штучка в тройках. Все триплеты последовательно работают как операция "и".

... (повтор объяснения)

(17:43) **Экран:** А. показывает пример с префиксами `variable` и `operator`.
**А.:** Что ещё такого интересного? Условия равенства... То есть мы проверяем, что у нас статус только черновик, оставь нам записи статуса черновик. Это двойное равно. Условие неравенства, то есть покажи нам все статусы, которые не равны черновику, все остальные — это восклицательный знак равно.
**Н.:** Угу.
**А.:** Ещё можно это записать вот так. То есть у нас есть ещё оператор `not`, логическое отрицание. И мы инвертируем условие. То есть до этого у нас было статус только "черновик", а здесь мы говорим, что статус любой, но только не "черновик".
**Н.:** Угу.
**А.:** Все остальные. Можно хоть и так, хоть так записать.
**Н.:** А точка после этого... после статуса черновика, она и до фигурных скобок должна быть? Точнее, и после? Или это так просто?
**А.:** Да-да-да. То есть точка должна быть всегда. Точка всегда после конца строки, да?
**А.:** Э-э, то есть точка ставится, в принципе, если мы `not` добавим... то она сама автоматически поставится.
**Н.:** Угу.
**А.:** И у нас каждый триплет должен тоже заканчиваться точкой. То есть здесь у нас триплетом является вот здесь значение кода, здесь некое условие, а здесь само значение, проверка на значение.
**Н.:** Угу.
**А.:** Это тоже у нас триплет.

### Секция 10: Разбор сложных функций и синтаксиса (18:31 - 21:09)

**Краткое содержание:** А. углубляется в синтаксис функций и их использование. Он показывает, как различные функции (`count`, `remainder`, `product`, `ascending`, `average`, `at`) принимают аргументы. Он отмечает синтаксические особенности: некоторые функции принимают один аргумент без скобок, другие — несколько в круглых скобках, а некоторые, работающие с запросами, используют фигурные скобки. Он разбирает сложный пример, где вычисляется индекс элемента в отсортированном списке для нахождения медианного значения.

**Транскрипция:**

(18:31) **А.:** А вот смотри, у тебя, м-м, вот первое... на три строчки назад, где `item` у тебя. Получается, э-э, третий, э-э, элемент, который неизвестен, ты кладёшь в переменную "статус обращения val", и потом её первым, м-м, первым элементом задаёшь в следующей строчке, а в третьем элементе у тебя опять то, что мы ищем, "статус код val". То есть, м-м, та переменная, которую мы не знаем, она, получается, последняя всегда будет.
**А.:** Э-э, не всегда, но да. То есть здесь... А, если... смотри, а если бы мы знали, э-э, статус обращения, но не знали вот этот "статус код property", да... нет, подожди, он всегда должен быть известен. А-а, то, что ты там говорил, что property всегда известно. Получается, мы могли то, что мы ищем, что нам ещё неизвестно, это мог быть и "статус обращения val", и "статус код val". То есть без...
**А.:** Давай вот так сделаем. Мы можем вот так написать. И вот сюда вернутся... то есть вот эта часть у нас будет уже неизвестная. Вот это известно и значение кода тоже известно. И нам сюда вернутся все записи статусов.
**Н.:** Прям так просто?
**А.:** Да.
**Н.:** То есть ты задал даже без айтема?
**А.:** Ну и, допустим... ну смотри, то есть мы могли написать это вот так... могли написать... можно было написать и вот так...

(20:56) **Экран:** А. показывает три разных способа написания одного и того же запроса.
**А.:** Сейчас я все три варианта, как это можно написать, напишу. Так, это первый у нас. Это у нас второй будет. И... это третий будет у нас. Вот эту тройку можно вот тремя разными способами написать.
**Н.:** А во втором у тебя после двойного равенства, там тоже статус, да? Угу.
**А.:** Да.
**Н.:** Так, так, так. Угу.
**А.:** И тут... то есть эти тройки, они, ну, выполняются, выдают условие, но результат одинаковый, но есть свои хитрости. Какие хитрости? То есть, когда мы пишем вот так, то есть это, в принципе, эквивалентно вот этому условию. То есть тут разницы, в принципе, никакой. А у нас здесь работает немножко похитрее. То есть она... идёт тоже вот так, то есть сверху вниз, но при этом она уже не сравнивает, она вот здесь отфильтрует статус и вот здесь уже по этому отфильтрованному статусу отфильтрует item.
**Н.:** Угу.
**А.:** В случае, если мы идём вот так, по второму случаю, то у нас сначала достанутся из всех записей обращения статусы, потом из всех статусов достанется статус-код, и потом только по всем кодам сравнится "Q0" и отфильтруется item.
**Н.:** Угу.
**А.:** Если мы вообще вот так напишем, то у нас мы изначально пойдём сразу в справочник статусов. И найдём значение ID записи, у которых статус-код "Q0". И пойдём сразу фильтровать все записи, э-э, обращений, у которых статус "Q0".
**Н.:** Угу.
**А.:** То есть это самый короткий, получается.
**А.:** Да. Не всегда самый короткий, но да.
**Н.:** Или самый быстрый.
**А.:** Не всегда. Э-э, вот тут важно понимать порядок условий. Так называемый срез данных.

### Секция 11: Концепция "среза данных" и примеры оптимизации (23:41 - 26:17)

**Краткое содержание:** А. подробно объясняет концепцию "среза данных" — оптимизации, при которой порядок выполнения условий в N3-выражении строится так, чтобы на каждом шаге максимально сокращать количество обрабатываемых записей. Он приводит пример: если нужно отфильтровать 9000 записей по двум условиям (статус и пользователь), выгоднее сначала применить тот фильтр, который оставит меньше записей (например, по пользователю, если у него всего 300 записей), а уже затем фильтровать оставшиеся по статусу. Это значительно ускоряет выполнение запроса.

**Транскрипция:**

(23:41) **А.:** Что такое срез данных? У нас... больше рисовать негде... давай вот тут. К примеру, у нас вот есть такой пирожочек обращений. Из них... то есть нам нужно написать фильтр по там статусу и текущему пользователю, да? То есть, к примеру, у нас статусы делят наш пирожочек на три части равные. То есть здесь там... новое, здесь в работе, а здесь там завершено. То есть три равные доли, к примеру, всех обращений. Их там, допустим, 9 тысяч. То есть здесь 3 тысячи, здесь 3 тысячи, здесь 3 тысячи. И нам... наша задача — отфильтровать только те обращения, которые новые и которые создатель — текущий пользователь. При этом количество записей, которые создал текущий пользователь, там равно ста записям. И тогда как раз влияет вот порядок условий. То есть если мы пойдём сначала отфильтруем все обращения и оставим только со статусом "новые", то мы оставим 3 тысячи.
**Н.:** Угу.
**А.:** А потом из них мы отфильтруем и оставим только 100. Либо мы пойдём и сразу отфильтруем все записи по текущему пользователю, и у нас останется только 300 пользователей... 300 записей точнее. И потом из них нам нужно дофильтровать 100, которые в статусе "новые".
**Н.:** Угу.
**А.:** И вот это как раз является порядком условий. То есть порядок тех строчек, которые мы задаём. И, понятно, что будет тройка работать быстрее, которая сразу отфильтрует наибольшее количество записей, уберёт их из поиска. Тогда нам нужно сначала у обращения отфильтровать, э-э, записи, которые равны текущему пользователю в создателе, и оставить всего лишь 300 записей, а потом из этих трёхсот записей оставить только 100 записей, которые в статусе "новые".
**Н.:** Угу.

### Секция 12: Практика: написание N3-выражений (26:26 - 31:47)

**Краткое содержание:** А. переходит к практическому заданию. Он показывает, как вычислить среднее значение цен из коллекции дочерних записей (`maintenanceItems`). Он объясняет, как использовать конструкцию `from ... select` для преобразования "кучи" данных в "лист", который могут принимать агрегирующие функции (`average`, `sum` и др.). Демонстрируется синтаксис функций и работа с префиксами.

**Транскрипция:**

(26:26) **А.:** И, соответственно, у нас будет троечка, что у нас `item creatorProperty user`. Здесь мы оставили уже 300 записей.
**Н.:** А `user` он откуда взялся? Это системная?
**А.:** Ну вот да, просто я не написал его. То есть мы сверху объявили его где-нибудь. Вот так.
(27:00) **А.:** То есть мы здесь оставили... срезали там... почти все записи, а потом у них там статус обращения взяли... и потом у статуса обращения взяли код... и так далее. Вот эта тройка будет гораздо быстрее работать, нежели если мы вот эту часть перенесём наверх.
**Н.:** Угу.
**А.:** Потому что вот тут останется больше записей.
**Н.:** Угу.
**А.:** Вот. Тоже важно понимать, как лучше... ну это больше с точки зрения оптимизации, вот то, чем я занимаюсь. Проверять, какой из условий оставит как можно наименьшее количество данных для последующей фильтрации.
**Н.:** Угу.
**А.:** Так, что ещё? Что ещё такого интересного?

(28:10) **Экран:** А. прокручивает свой файл с примерами кода.
**А.:** То есть, в принципе, базовые тройки мы разобрали. Можем какую-нибудь троечку написать или вот, допустим, вычисление гиперссылки у меня там интересное есть, какая-то тройка.
**Н.:** Угу.

(28:23) **Экран:** А. переключается в Comindware, в редактор форм, и открывает атрибут "Вычисление гиперссылки".
**А.:** А, она форматом сделана. М-м... Что б такое сделать? А, я, в принципе, придумал. А-а... Напишем тогда две тройки. Первая, которая нам выведет список... итемов по определённым условиям.

(28:51) **Экран:** А. переходит в запись с ID 85749, где есть таблица `maintenanceItems` с несколькими строками и атрибутом `materialPrice`.
**А.:** А вторая — посчитает среднее по ним.

(28:56) **Экран:** А. возвращается в редактор форм и создает новую кнопку.
**А.:** Вот, допустим, мы там добавили какие-то... наши `maintenanceItems`. А, у меня, кстати, здесь среднее считается. Можно вот эту троечку разобрать. То есть она считает среднюю цену всех позиций по `materialPrice`.
**Н.:** Угу.

(29:47) **Экран:** А. открывает редактор выражения для атрибута `Avg`.
**А.:** Тоже, как можно решить эту задачу? То есть зачастую пользователи... э-э... как решают эту задачу? Очень частая ошибка. Э-э, они идут, допустим, если мы на язык формул это переводим, они идут там `from NDB maintenanceItems where ID нашей там претензии claim equals $ID`. `select materialPrice` и там среднее посчитай нам, просуммируй и подели там на каунт этих позиций, условно. И такой подход, э-э, он позволяет решать задачу, но со временем начинает дико тормозить. То есть чем больше у нас там позиций в справочнике позиций, тем дольше у нас будет это всё вычисляться.
**Н.:** Угу.
**А.:** Э-э, важно понимать, когда можно идти через `from($)`. То есть мы можем пойти по этой коллекции сразу из записи. То есть мы пишем `from($maintenanceItems)`, и мы уже сразу знаем все вот эти позиции. Их уже там можем суммировать, делить, умножать и так далее. То же самое в тройках. То есть мы можем... то есть мы опять берём item... item — текущая запись.
**Н.:** Сейчас, подожди. Я... вот из... начни сначала, там, где поиск по... Значит, в шаблоне `Claim` мы ищем атрибут там `maintenance` и потом у него `material price`. Так, это понятно. Угу.
**А.:** Да-да-да. То есть да, мы получили все записи, то есть у нас сюда положились все записи, э-э, позиций этих. И мы из позиций достали цену. И мы плавно переходим к функциям, которые у нас есть в тройках.

### Секция 13: Работа с функциями и префиксами в N3 (31:50 - 35:05)

**Краткое содержание:** А. показывает, как использовать функции в N3, обращая внимание на справочник функций в интерфейсе Comindware. Он отмечает, что не все функции из справочника работают, и наоборот, некоторые рабочие функции в нем отсутствуют. Он демонстрирует, как использовать `nullable:sum`, `average` и как важны префиксы (`string`, `cmwstring`), объясняя, что разные функции требуют разных префиксов, и это нужно проверять на практике или по примерам.

**Транскрипция:**

(31:50) **Экран:** А. указывает на панель "Справочник по функциям" в редакторе выражений.
**А.:** В принципе, большая часть функций вот здесь расписана. То есть, допустим, `sum`. Нам нужно сумму посчитать. То есть мы смотрим, что у нас тут... Суммирует два значения. То есть здесь мы просуммируем только два значения. А нам нужно посчитать сумму всего списка. То есть нам нужна вот эта вот штучка: "суммирует все значения списка, используемого в качестве аргумента". То есть нам по списку надо посчитать. Как эти...
**Н.:** Они же одинаковые.
**А.:** Это у нас... классная нотация.
**Н.:** Круто.
**А.:** Я тебе больше скажу: они мало того, что они одинаковые, тут могут быть те, которые не работают.
**Н.:** У нас не работают или вообще не работают?
**А.:** У нас не работают.
**Н.:** А, у нас не работают, понятно.
**А.:** Э-э, и там есть всякие приколы. Э-э, к примеру, у нас есть, э-э, префикс `string`... вот такой. И есть префикс `cmwstring`. То есть пути у них разные. Первый идёт на сайт W3, второй у нас с Comindware тянется из платформы, из движка. И... у стринга есть формат... обычный формат, который вот мы используем в формулах. То есть тут есть якобы у нас конкатенация, то есть склеивание двух строк, формат, поиск по матчам и так далее. И вот что забавно, формат работает с префиксом `string`, а всё остальное у нас работает только с `cmwstring`.
**Н.:** Прикольно.
**А.:** То есть всякие джойны... что там ещё у нас строковое... Конкатенация, `contains`, э-э, `join`, э-э, длина, матчи и так далее. Всё работает только через `cmwstring`. Но формат работает только через `string`.
**Н.:** То есть надо задавать всегда два, если не очень помнишь.
**А.:** Это вот, на самом деле, вот если пописать, э-э... То есть это всё тестится путём атрибутов. То есть делаем атрибут и тестируем, смотрим, работает оно или нет. Если не работает, то либо пробовать через `cmw` переделывать это... либо как-то ещё.

### Секция 14: Разбор интеграционного сценария (35:05 - 41:00)

**Краткое содержание:** А. разбирает сложную тройку для интеграционного сценария. Он показывает, как работать с переменными, полученными из внешнего запроса (триггера). Он объясняет, как объявить локальную переменную в начале триггера, а затем в последующих блоках процесса получать и модифицировать ее значение. Пример демонстрирует, как собрать строку с ошибками: если валюта из запроса не найдена в справочнике, к переменной `error` добавляется текст ошибки, который потом можно вывести пользователю.

**Транскрипция:**

(35:05) **А.:** А-а, но, опять же, повторяюсь, в принципе, если нужно что-то, вот, допустим, формат тот же... У меня вот есть здесь `string:format`. И по вот этому `string:format` можно посмотреть, какая директива подключается. Вот он, W3.
**Н.:** Угу.
**А.:** Допустим, если нам нужен `join`... Join уже, видишь, `cmwstring`.
**Н.:** Угу.
**А.:** И вот здесь `cmwstring` используется.
**Н.:** Угу.
**А.:** То есть, в принципе, у меня тут описаны большая часть вот таких штук, которые нужно использовать. Можно из моих примеров смотреть, там какую нужно функцию и смотреть, что она в себе использует и как пишется.
(36:13) **А.:** Так вот, э-э, вернёмся к нашей задаче. Нам нужно посчитать среднюю... э-э... среднюю цену.
**Н.:** Угу.
**А.:** Э-э, ещё одна проблема в том, что мы... э-э, когда мы достанем по нашему пути, то есть из всех позиций мы достанем цену, это у нас не является листом, который принимает функция `average`. То есть она у неё здесь... прямо написано: `value` — это `list`. А вот это называют "кучей". Не знаю, как правильно.
**Н.:** А зачем у неё `value list`, если одно значение у тебя в списке выдаётся?
**А.:** Э-э, `value` — это то, что мы должны передать в эту функцию, а `result` — это сам результат. То есть тут тоже инвертированная штука.
**Н.:** Угу.
**А.:** И, то есть вот эта цена... вот если мы напишем без `from`-а вот этого, то вот здесь будет лежать "куча", и вот эта функция не будет работать на "кучу", к сожалению.
**Н.:** Угу.
**А.:** Она воспринимает лист. А лист формируется с помощью вот выражения `from-select`.
**Н.:** Угу.
**А.:** То есть мы пишем `from`, внутри там пишем то же самое, что бы мы написали до этого.
**Н.:** Угу.
**А.:** И дальше он говорит: `select MaterialPrice`, то есть возьми каждую цену и положи её в `MaterialPriceList`.
**Н.:** Угу.
**А.:** То есть он берёт первую запись, достаёт из неё цену и кладёт в лист. Берёт следующую запись, получает из неё цену, кладёт в лист. И таким образом формирует лист. Дальше мы уже этот лист перекладываем как левую часть триплета. Потом говорим, что нам нужно с этим сделать, то есть посчитать среднюю, и вернуть значение в `value`.
**Н.:** Угу.
**А.:** А как ты понял, что вот там префиксы нужны... ну вот `object` понятно. Э-э, математически тоже понятно. А вот `assert` и `nullable`? Это ты просто уже помнишь, что надо их использовать для того, чтобы функции выводились? У нас просто, я не вижу, чтобы в справочнике по функциям тебе префиксы как-то выводил.
**А.:** Он выводится. Смотри. К примеру, вот возьмём какую-нибудь "Дата и время"... Э-э... Внимание! Давай вот так даже сделаю. То есть я убрал все префиксы. Я когда нажимаю "Вставить"...
**Н.:** М-м.
**А.:** Мне автоматически вставляется префикс.
**Н.:** Угу.
**А.:** И вставляется вот средняя часть... э-э, как-то, функция.
**Н.:** Угу.
**А.:** И зачастую вот эта штука... даже, наверное, правильно сказать, всегда, вот эта часть, она всегда средняя.
**Н.:** Угу.
**А.:** Слева у нас обычно какие-то переменные, в которых нам нужно как-то преобразовать, а справа у нас результат.
**Н.:** Угу.
**А.:** Опять же, не всегда, к сожалению, не всегда, но как-то так.

(38:25) **А.:** И, опять же, повторюсь, почему у меня вот есть вот эти кучу примеров, э-э, чтобы понимать, какая вот функция и как правильно работает и что нужно в ней писать.

(38:38) **Экран:** А. показывает тройку с `if-else` и `string:format`.
**А.:** А, вот, допустим, вот в этой тройке, допустим, интересно. Вот мне нужно было удалить, э-э, все нули у строчки. То есть я передаю сюда, э-э, саму искомую строку... Тоже можем `regex replace` посмотреть. Он говорит: первое у нас `input` — строка, вторая у нас `pattern` — это по какому регулярному выражению мы будем как-то чистить строку, и следующая строчка — это на что мы будем замещать это. То есть вот эта штука — это просто пустая строка. И у нас там номер какой-то вот такой... как строка. Мы говорим, что нам нужно вот эти нули удалить. И вот эта штука, она находит все нули до первого числа, любого другого, их меняет на пустоту и возвращает вот сюда в `result`. И у нас остаётся вот такая строчка.
**Н.:** Блин, ну там выше такая дичь написана. Я просто вообще в офиге.
**А.:** Тут, на самом деле, тоже ничего сложного. А-а, вот эта штука, вот эта конструкция, она используется в основном в интеграциях и в случае, если мы используем какие-то диалоговые переменные. И... вот эта вот дичь, она, на самом деле, на языке формул выглядит вот так... `var.IDOC.SalesOrderData.DocumentNumber`. Это вот так на языке формул выглядит.
**Н.:** А `var` ты откуда взял? Это ж то, что ты задаёшь.
**А.:** Э-э, `var` — это переменная, в которую у нас приходит запрос. Сейчас, я что-нибудь открою... какую-нибудь интеграцию.
**Н.:** Ну то есть это объявление переменной или нет?
**А.:** Да, и объявление переменных мы ещё придём.

### Секция 15: Фильтрация и сложные вычисления (41:00 - 46:41)

**Краткое содержание:** А. продолжает разбирать сложные примеры. Он показывает, как фильтровать экземпляры процессов по статусу и имени, используя системные префиксы `process` и `task`. Он снова возвращается к примеру с вычислением индекса и средних значений, подробно объясняя математические функции: `remainder` (остаток от деления), `product` (умножение), `sum` (сложение), `ceiling` (округление вверх) и `average` (среднее).

**Транскрипция:**

(41:00) **Экран:** А. переходит в раздел "Сценарии" и открывает сценарий "testingQueue".
**А.:** Вот, допустим, я вчера писал. Нет, это не то. А... вот тут, наверное. Вот у нас есть блок "Полученное сообщение". И вот здесь мы задаём имя переменной, в которую у нас положится всё сообщение наше.
**Н.:** Угу.
**А.:** И вот в том конкретном случае там лежало `var`.
**Н.:** М-м.
**А.:** И дальше мы просто разбираем её. То есть мы говорим: из `var`... То есть вот эта конструкция первая, она, в принципе, стандартная, её только откуда-то копировать, в принципе. Запомнить... я очень ленивый человек, мне проще скопировать откуда-то. То есть нужно просто понимать, э-э, что это значит. Она говорит, что из текущего контекста достань мне переменную `var`, которая лежит в триггере. В триггере у нас вот этой штукой задаётся. И положи всё её содержимое в переменную тройки `varVal`.
**Н.:** Угу.
**А.:** Дальше из `varVal` достань нам всё, что у нас лежит в варе `IDOC`. И из `IDOC`а мы достали `SalesOrderData`, положили в переменную, и из `SalesOrderData` достали наш `DocumentNumber` и положили в переменную, которую мы уже там дальше оперируем как-либо.
**Н.:** Угу.
**А.:** И вот тут тройка, по сути, она что делает? Нам пришёл запрос некоего заказа, и нам нужно проверить, есть ли он у нас в справочнике или нет. И в случае, если у нас его нет, то мы его там создаём. В случае, если он у нас есть, то мы его идём обновлять. И как я это там реализовал? То есть я написал вот такую троечку, которая идёт по вот этому пути, там убирает лидирующие нули, и потом вот у нас триплет уже знакомый. То есть мы говорим: в шаблоне `OrderHeader` по атрибуту `OrderHeader_IDS4` отфильтруй нам те записи, у которых в этом атрибуте лежит значение, которое нам пришло по интеграции. Вот сюда у нас положится запись.
**Н.:** Угу.
**А.:** В случае, если эта тройка выполняется, то есть у нас запись есть, то мы эту запись возвращаем. А если у нас запись... записи такой нет, то я возвращаю сюда просто строчку `empty`. Вот эта конструкция, она говорит, что мы положим в `value`. Э-э, и мы можем также объявлять некие локальные там переменные в тройке. То есть мы можем написать там статус тот же `Q0` и можем его сразу положить в переменную `status_code`. Ну, которая ещё нет. Да-да-да. То есть она, по сути, ничего ещё не значит. И мы дальше там можем писать: `?status statusProperty`, которое там объявим, и сразу здесь уже приравнивать к `status_code`. Ну как мы делали раньше, но вот это объявление переменных, допустим, если нужно его переиспользовать в другом месте, в каком-то тут же, в тройке.
**Н.:** Угу.
**А.:** Но этим редко на самом деле пользуются. То есть это в основном конструкция используется для возврата результата. То есть или мы так положим сюда айдишник записи, или мы положим строчку `empty`.

### Секция 16: Разбор сложного фильтра по датам (46:58 - 51:41)

**Краткое содержание:** А. показывает пример сложного фильтра по датам. Он демонстрирует, как получить текущую дату и время (`session:requestTime`), начало текущего дня (`startOfDay`), а затем использовать условную логику (`if-then-else` и `not`) для проверки, является ли задача просроченной. Фильтр сравнивает плановую и фактическую даты завершения с текущей датой, чтобы определить статус задачи.

**Транскрипция:**

(46:58) **Экран:** А. показывает сложную тройку с множеством префиксов и условий `if-else`.
**А.:** Вот, допустим, у нас была вот эта формула...
**Н.:** Это чтобы вывести...
**А.:** Да-да-да.
**А.:** Это у нас, э-э, что здесь прикольного? Здесь, в принципе, прикольного получения даты текущей. Вот так получается дата текущая. И потом здесь, э-э, по условию надо было получить, э-э, э-э, время начала дня, то есть 00:00, текущей даты.
**Н.:** Угу.
**А.:** И в чём тут фильтр? Что мы проверяем, что у нас, если у нас заполнена дата завершения работы... точнее, не заполнена... То есть ещё раз, вот эта штука проверяет, что у нас, э-э, заполнено, не пустое.
**Н.:** Не пустое.
**А.:** А если мы инвертируем это через `not`, то мы говорим о том, что если у нас дата завершения работы пустая, тогда мы у текущей записи берём, э-э, плановый срок даты завершения, приводим его к старту дня и проверяем, что у нас дата текущая больше, чем плановая дата завершения. То есть здесь, э-э, фильтрация происходила: просрочена работа или нет.
**Н.:** Угу.
**А.:** Иначе, то есть вводился список всех просроченных работ. Иначе, там проверяем дату завершения работы, э-э, получаем, э-э, время начала дня, дата завершения. М-м... Потом... э-э, берём плановую дату завершения и проверяем, что у нас дата завершения... э-э, дата завершения больше, чем дата старта. Короче, что плановая дата завершения больше, чем фактический план завершения.
**Н.:** Угу.
**А.:** Что задача успела в срок сделана. Ну или там заявка какая-то.
**Н.:** Угу.
**А.:** Какой-то план. То есть либо мы проверяем, что она уже не просроченная, если у нас дата завершения, э-э, не заполнена, либо мы проверяем, что задачу закрыли в срок до даты завершения плановой.
**Н.:** Угу.
**А.:** Ну вот такой вот сравнение. Ну вот такой вот фильтр.

### Секция 17: Заключение и обсуждение дальнейших шагов (51:41 - 52:21)

**Краткое содержание:** А. подводит итоги, отмечая, что основной файл с примерами N3-кода является ценным ресурсом. Он предлагает Н. изучить этот файл, добавлять комментарии для понимания и пробовать писать свои собственные выражения, начиная с простых. Н. соглашается и планирует использовать файл как основу для практики.

**Транскрипция:**

(51:41) **А.:** Класс. Саш, спасибо тебе большое.
**А.:** Ну, пожалуйста. Правда, ещё много чего не это... не рассказал.
**Н.:** Это бесценно. Правда. Ну, это ты видишь, ты говоришь, там, э-э, не всё есть в справочнике. То есть клиенты-то думают, что там всё есть.
**А.:** Ну, да, и много что не работает.
**Н.:** Ну вот, да. И с этим тоже, чтобы не напороться на то, что я там буду рассказывать, а... они говорят: "Да, да, там вот это работает, мы сейчас вот это сделаем", а...
**А.:** Ну вот всё, что у меня описано вот здесь, то есть все формулы, все, э-э, функции, вот это всё 100% работает.
**Н.:** Угу.
**А.:** То есть на всех сборках везде это работает.
**Н.:** Ну, крутяк.
**А.:** Пойду пробовать, начну с простого.
**А.:** Всё, хорошо.
**Н.:** Спасибо большое.

### Секция 18: Финальный разбор примеров и комментариев (52:21 - 58:32)

**Краткое содержание:** Завершая сессию, А. быстро пробегается по оставшимся примерам в своем файле. Он показывает, как фильтровать задачи по статусу и исполнителю, как работать с группами пользователей и как формировать гиперссылки на файлы. Он также подчеркивает, что многие полезные функции отсутствуют в официальном справочнике, но есть в базе знаний (КБ), и что его файл с примерами — это проверенный сборник рабочих конструкций.

**Транскрипция:**

(52:21) **А.:** В общем, вот это, я думаю, переварить.
**Н.:** Да. Ну, это...
**А.:** Я твой файлик буду это... колупать. Колупаю.
**А.:** То есть можно там комментарии пописать в этих тройках, там, можно мне прислать. Если что, сва лидирую или подправлю комментарии, чтобы было понятнее.
**Н.:** Угу.
**А.:** А вообще, желательно вот что-то пописать.
**Н.:** Да, вот я как раз собиралась этим заняться. Я вчера, позавчера... где-то есть у меня там просто выраженьки. Вот, и я пыталась там выраженьки переписать на... э-э... тройки. Вот. Но там как раз были места по большей части на системном фильтре таблиц, и, скорее всего, это просто не сработало. Ну, я постараюсь, посмотрю, что ещё можно сделать. Ну, такие там простые, где там, нам из такого-то шаблона надо достать атрибут пользователя, и потом этого пользователя засунуть в значение.
**А.:** Ну вот по статусам можно что-то пофильтровать. То есть, э-э, допустим, у нас есть все там претензии, у них сделать какой-нибудь статус, хотя бы просто текстом, там, три статуса сделать.
**Н.:** Угу.
**А.:** И пописать эти фильтры на системное...
(52:47) **Экран:** А. переходит в раздел "Таблицы", затем в "Системный фильтр".
**А.:** сюда, посмотреть, что выводится. Там я вот писал на вторую таблицу. Перепутал. Не в форму, а... вроде дописал его. А здесь, допустим, фильтруется, остаются все записи, у которых там дата создания, э-э, за два дня.
**Н.:** Угу.
**А.:** Эта штука не нужна.

(53:22) **Экран:** А. показывает код с функциями `cmwlocal:sub` и `cmwlocal:between`.
**А.:** Ну, вот такая ещё есть. А, `plus one day`, `plus two day`, вот, это я вспомнила, да, это я уже видела. Да. Ну она фактически, ты её тут задаёшь, а, э-э, как её взять, то есть её надо именно заполнить... ой, запомнить.
**А.:** Ну вот, это я получаю дату начала. Здесь я там перевожу это в длительность, потом дату прибавляю с длительностью, получаю день до, точнее, вычитаю здесь длительность. И потом проверяю, что у текущей записи получи нам дату создания и проверь, что она между... э-э, днём назад и между сегодня. То есть все заявки, которые в рамках одних суток были.
**Н.:** Угу.
**А.:** Такой вот фильтр.

(54:13) **Экран:** А. продолжает показывать различные примеры из своего файла.
**А.:** Капец. Саша, спасибо тебе большое.
**Н.:** Ну... пожалуйста.
**А.:** Правда, ещё много чего не это... не рассказал.
**Н.:** Это бесценно. Правда.
(54:27) **А.:** Что ж, там не всё есть в справочнике. Клиенты-то думают, что там всё есть. И много что не работает.
**Н.:** Ну вот, да, и с этим тоже, чтобы не напороться на то, что я там буду рассказывать, а... они говорят: "Да, да, там вот это работает, мы сейчас вот это сделаем", а...
**А.:** Ну вот всё, что у меня описано вот здесь, то есть все формулы, все функции, вот это всё 100% работает. На всех сборках везде это работает.
**Н.:** Ну, крутяк.
**А.:** Пойду пробовать, начну с простого.
**А.:** Всё, хорошо.
**Н.:** Спасибо большое.
**А.:** Пожалуйста.

(55:20) **Экран:** А. показывает код с префиксами `variable` и `operator`.
**А.:** То есть нашим случаем... мы вот сюда `error` вставляем. То есть мы говорим: `variable error`, то есть переменную `error` нам нужно очистить. И это тоже вставляется в "выполнить... проверить результат выражения". Простая очистка.
(55:48) **А.:** А, что ещё бы рассказать такое интересное? Условия равенства...

(56:02) **Экран:** А. прокручивает файл с кодом.
**А.:** То есть все тройки, на самом деле, они типовые. То есть, зная там парочку троек, вполне достаточно, чтобы уже что-то осмысленное писать и кучу всего.

(56:16) **Экран:** А. останавливается на сложном примере с вычислением индекса.
**А.:** Вот, к примеру, одна из таких сложных троек. Но, на самом деле, ничего сложного здесь нет. То есть тут была речь о том, что нам нужно посчитать количество позиций и в зависимости от того, делятся ли они нацело на четыре, э-э, нам нужно по-разному их выполнять.
**Н.:** Угу.
**А.:** То есть нам первое нужно посчитать количество. Как посчитать количество? То есть тут прям в поиске можно написать "количество"... Что-то он не ищет, да? Вот, у нас есть `count`. И, опять же, возвращаюсь к тому, что у нас здесь, какие формулы описаны, не все формулы, которые действительно работают, описаны вот в этом справочнике функций. То есть вот это `cmwnullable:count`, она, на самом деле, не сработает при подсчёте, а сработает `assert:count`. А `assert:count` мы можем найти только в нашей КБ-шке.
(57:26) **Экран:** А. открывает браузер на странице базы знаний Comindware "Написание выражений на языке N3".
**А.:** То есть её в справочнике нету.
**Н.:** Нет. Офигенно. И вот здесь в КБ-шке у нас есть "вычисляет количество записей".
**Н.:** Блин, а это важная штука-то.
**А.:** Да. И вот много такого, в принципе, нигде не описано. В КБ-шке есть в неком виде, но в КБ-шку мало кто смотрит. И вот зачастую все люди вот выписывают себе примерчики троек и потом смотрят, как они там писали это, чтобы оно работало, и копируют.
**Н.:** Угу.
**А.:** И вот такая конструкция, тоже мы говорим, что из текущей записи возьми нам все позиции и... заключается это в фигурные скобки, а не в круглые уже.
**Н.:** Почему?
**А.:** Ну, потому что такой синтаксис, э-э, самой функции. То есть она в себе принимает триплет, а в круглых скобках обычно принимаются сами переменные уже известные или неизвестные.
**Н.:** Угу.
**А.:** То есть вот, допустим, здесь, э-э, сумма... То есть здесь мы уже знаем какое-то число, и второе — это у нас явное число, единица.
**Н.:** А почему единица не через кавычки? Это же значение. Или нет?
**А.:** Вот, важно. Если в кавычках — это строка.
**Н.:** Угу.
**А.:** То есть, когда мы... То есть если бы я здесь написал вот эту штучку, то мы говорим, что сложи нам с, допустим, `firstVal` — это число там 25. Сложи нам 25 со строкой "1".
**Н.:** М-м.
**А.:** Это будет неправильно. То есть у нас должны быть одинаковые типы данных.
**Н.:** Угу.
**А.:** Кавычки означают, что это именно строка. Если мы без кавычек пишем, то это именно число.
**Н.:** Угу.
**А.:** И, то есть в первом случае мы там посчитали количество позиций. То есть сделали просто... достали нам все позиции, вот эта штука нам посчитала в эту переменную значение количества этих позиций в записи. Банально вот здесь количество вот этих записей посчитало, там шесть штук.
**Н.:** Угу.
**А.:** Дальше нам нужно поделить на четыре и проверить, есть остаток или у нас нет остатка. `remainder` возвращает значение остатка от после деления. То есть 16 разделить на 4 у нас будет остаток от деления ноль, потому что будет 4,0. Э-э, допустим, 6 разделить на 4 будет 1,5. Тогда остаток от деления будет уже 5.
**Н.:** Угу.
**А.:** Э-э, соответственно, вот эта штука нам вернёт там остаток от деления. То есть, в случае если нацело делим, то здесь будет ноль. И вот у нас ифка.
**Н.:** Слушай, а где само деление-то? У тебя получается сразу на остаток...
**А.:** Э-э, в моём случае мне нужно было...
**Н.:** Или нет?
**А.:** Здесь функции, здесь всё делается функциями.
**Н.:** А, ну а где вот функция, чтобы разделить? Потому что это... ты, ну, переменную, потому что у тебя остаток четыре, да? А вот само деление?
**А.:** М-м... само деление... остаток от деления... вычитание... корень... округление... возвращает целочисленный результат деления... вот это целочисленный результат деления... произведение... степень... округление... Вот, вот это будет деление у нас, вот эта штука.
**Н.:** Просто его там нету, а я думаю, как она, система, поняла, что надо разделить?
**А.:** Не, вот здесь же написано описание того, что нужно делать.
**Н.:** А...
**А.:** То есть вот здесь префикс, а вот здесь описание.
**Н.:** А, это два в одном! Всё, понятно.
**А.:** То есть да, вот эта штука — остаток от деления, вот эта штука вернёт именно деление с дробной частью, есть, которая... э-э, допустим, деление одного числа на другое и вернёт только целое число, там, допустим, единицу только вернёт.
**Н.:** Угу.
**А.:** То есть то, что происходит со значениями, описывается вот после двоеточия в функциях. То есть здесь умножение, здесь сумма у нас, здесь сортировка, здесь среднее, э-э, здесь там получение по индексу.

(62:55) **Экран:** А. прокручивает код, показывая различные функции.
**А.:** То есть всё описано после двоеточия. Вот здесь количество, аккаунт...
**Н.:** Угу.
**А.:** То есть по вот этим штукам можно проверять. То есть мы посчитали, здесь мы поделили на четыре и проверили остаток, и дальше вот у меня идут ифки. Э-э, если у нас остаток равен нулю, то мне там нужно было вычислить необходимый искомый индекс, там умножить количество на 0,25 и получить индекс второго элемента — это индекс первого плюс один. Что такое индекс? В конкретной этой задаче нужно было... как это всё почистить можно...

(63:48) **Экран:** А. пытается очистить холст в Paint.
**А.:** Сохранить. Создать. Не сохранять. То есть конкретно в этой задаче у меня были некие позиции. Дайте мне кисточку. То есть позиция 1, позиция 2, позиция 3, позиция 4. Э-э... То есть количество N у нас равно 4. Мне нужно было умножить на 0,25 или поделить на 4. 4 на 4 у нас получается 1. То есть индекс первый у нас был 1, индекс второй у нас был 2. И потом мне нужно было по этим индексам... нужно было отсортировать по цене. То есть здесь могла быть цена там... 301, 248, 5, 15.
**Н.:** Это ты, кстати, по убыванию расположил. Там наоборот тогда должно быть. 5, 15 и потом... Ну, неважно.
**А.:** Ну да, допустим, 5, там 15 и так далее.
**Экран:** А. показывает функцию `ascending` в редакторе.
**А.:** `ascending` у нас как, по возрастанию сортирует. В порядке возрастания. Соответственно, у нас после фильтрации получился бы список: 301, 248, 15, 5. И, соответственно, индексы у них поменялись бы: 1, 2, 3, 4. То есть мне нужно было по первому индексу получить, так как заранее я там вычислил, это 5, и получить по второму индексу значение, это 15. И потом мне нужно было посчитать среднюю. То есть я получил эти значения, и среднее у нас считается как 5 + 15 поделить на 2. У меня получилось, сколько, 10. И вот этот результат я уже вернул в `value`. Все остальная часть тройки у нас не выполняется. В случае, если они на четыре в явном виде не делятся, то у меня было другое условие. То есть тоже я там отсортировал список. Первый у меня индекс по такой же формуле вычислялся: N умножить на 0,25. А второй, э-э, мне нужно было поделить... а, нужно было округлить в большую сторону. То есть, к примеру, я там поделил и получил 4,2. И первый у меня индекс был... а, мне нужно было просто первый индекс вернуть. То есть получилось там 4,2, вот я пишу, это всё округлялось в большую сторону, в пятёрку. То есть неважно, не банковское, не математическое округление, а просто в большую сторону. То есть мне нужен был пятый индекс. И потом я по этому индексу получал значение и сразу возвращал его в результат.
**Н.:** Угу.

### Секция 19: Финальные примеры (68:11 - Конец видео)

**Краткое содержание:** А. быстро рассматривает еще несколько примеров, показывая универсальность N3. Он демонстрирует фильтрацию задач по статусу, фильтрацию по исполнителю (включая или возможного исполнителя, или назначенного), проверку принадлежности пользователя к группе и, наконец, создание гиперссылки на вложенный файл, извлекая его ID и название для формирования HTML-тега `<a>`.

**Транскрипция:**

(68:11) **Экран:** А. снова показывает свой файл с примерами кода.
**А.:** В первом случае там среднее считал, во втором случае мне просто по индексу вернул результат. Так как список отсортированный, там примерно в этом, э-э, месте и хранилось среднее. Приблизительно.
(68:33) **Н.:** А вот то, что у тебя перед функцией, э-э, ну там `cmwlist` и прочее, там в одном случае у тебя в скобках — это когда известные переменные, а без скобок — это когда мы их задаём, ну, точнее, ищем.
**А.:** Э-э, в скобках используется, когда у тебя несколько параметров передаётся в функцию. Допустим, умножение у нас принимает два параметра: первую переменную и вторую.
**Н.:** Угу.
**А.:** Округление нам только один параметр, поэтому скобки не требуются. Это такие тоже особенности синтаксиса. В случае, если триплет у нас принимается, в основном фигурные скобки нужно заключать. И... в... в формате у нас тоже круглые скобки были. Формат... Ну вот, допустим...
**Н.:** Ну это как формат в выражениях. То же самое.
**А.:** Да-да-да, то же самое. То есть здесь не через запятую идёт перечисление, а через пробел. И так далее. Запятые в тройках не используются вообще.
**Н.:** Ну и хорошо.
**А.:** Всё только через пробелы.

(70:02) **Экран:** А. переходит к следующему примеру в файле кода.
**А.:** Э-э, что ещё есть интересного? С процессами, наверное, пока сложно будет.
**Н.:** Да.
**А.:** Тоже много системных штук. То есть, на самом деле, тоже не особо и сложно.
**Н.:** Это экземпляры процессов, чтобы он, э-э, какие-то выдавал?
**А.:** Здесь считается количество процессов, связанных с текущей записью, у которых статус "активная" и имя этого процесса "создание аккаунта".
**Н.:** Угу.
**А.:** То есть здесь итемом, э-э, будут все процессы, а не текущая запись.
**Н.:** А, то есть наименования процессов. А, может быть.
**А.:** Да-да-да. То есть мы достаём все процессы, из них все статусы, потом, э-э, переводим статус процесса в строчку простым форматом, проверяем, что у нас статус равен, э-э, `process.ActiveStatus`, потом проверяем, что отфильтруй нам, оставь нам только все процессы, у которых имя равно "Creating_Account", и посчитай нам их количество и верни в `value`. То есть он вернёт количество всех процессов по созданию аккаунта, которые активны.
**Н.:** А вот, кстати, функция у тебя в данном случае не средняя, а первая.
**А.:** М-м...
**Н.:** Ну, не первая, а, подожди, там же фигурные скобки.
**А.:** Вот это всё первое.
**Н.:** А, это считается первым. Всё.
**А.:** Вот это среднее, да.
**Н.:** Угу.
**А.:** Вот это конец.

(72:12) **Экран:** А. показывает следующий пример.
**А.:** Что-то там я делал ещё по этим... по задачам тоже делал. Э-э, тоже, отфильтруются, берутся все задачи, у всех задач фильтруется статус "в прогрессе", и у которых, э-э, исполнитель либо возможный исполнитель равен текущему пользователю. Это фильтр на таблицу в процессах, по экземплярам. Он выводит все задачи, где пользователь либо исполнитель задачи, либо он как возможный исполнитель задачи, и статус в прогрессе.
**Н.:** А, вот это прикольная штука.
(72:59) **А.:** С группами тоже прикольная штука. То есть уже известная нам, получение текущего пользователя. И здесь мы получаем, э-э, айдишник группы по её названию. То есть вот это название группы. И мы идём справа налево. То есть по названию группы получи нам группу. И потом уже группа у нас известна, опять справа налево идём. Из группы достань всех её... всех, кто находится в ней.
**Н.:** Угу.
**А.:** И здесь проверь, что текущий пользователь находится в этой группе и верни `true`. Либо мы можем, там, допустим, написать здесь, э-э, `value` и вернуть всех пользователей какой-то группы, к примеру.
(74:02) **А.:** А-а, что ещё есть интересного? А, вот, кстати, по задачам тоже простая троечка. Она достаёт все задачи у текущей записи и проверяет, что эти задачи в статусе "в прогрессе".
**Н.:** Это задачи какие? В задачах пользователя?
**А.:** Да-да-да.
**Экран:** А. выделяет `?task task:objectId ?item.`
**А.:** А... нет, даже не так. А... здесь все задачи, которые в статусе "в прогрессе".
**Н.:** А, то есть здесь без этого, без аккаунта, без юзера.
**А.:** Да. То есть мы делали системный фильтр на шаблон записи, где у нас он пустой, без записей, и мы делали вот такие тройки, которые выводили все задачи всех пользователей в таблицу. И в статусе "в прогрессе".

(75:22) **А.:** В принципе, тройки-то не особо сложные. Сложно разобраться, как работает какая-то функция.
**Н.:** Как и правильно переписать.
**А.:** Да. Да. Ну, опять же, вот тут у меня большая часть вот этих функций, прямо 80%, которые используются, описаны. Можно, в принципе, у меня найти, посмотреть, там какую нужно функцию и смотреть, что она в себе использует и как пишется.
(75:50) **А.:** А, тут, к примеру, мы у текущей записи достаём вложения. Из вложения, с помощью вот `document`, мы можем достать, э-э, его название.
**Н.:** Угу.
**А.:** И сделать гиперссылку. То есть мы говорим, что вот эта вот у нас ссылочка на скачивание файла. Сюда мы передаём, э-э, сам файлик, то есть айдишник файлика, и ссылка на скачивание файла и его название сюда передаём в `title`. Просто форматом собираем.
**Н.:** Угу. Да, вот это прикольная штука тоже.
**А.:** То есть, соответственно, мы за одну штучку можем сразу получить данные и по айдишнику файла, и по его названию.
**Н.:** Угу.

(76:38) **А.:** М-м...
(76:52) **А.:** Да, смотрели по созданию аккаунта.
**Н.:** А, да. Угу.
(77:00) **А.:** какая-то сложная.
(77:05) **А.:** Я избегал вот этой конструкции, потому что я уже не уверен, что она работает нормально. Вот эта конструкция, что она говорит? Э-э, она говорит, что достань нам все записи из `ProjectPlans` и положи эти записи в контейнер. И вообще, как подразумевалось, что это работает, она достаёт все записи и прихранивает их локально. То есть мы не перебираем все записи, как мы до этого писали в тройках. Э-э, то есть берём одну запись, проверяем её, берём другую запись, перебираем её. А вот эта штука позволяет, э-э, брать сразу все записи и сразу по всем фильтровать, и это должно быстрее работать. Но что-то в последних сборках вот это отвалилось, и оно стало медленнее работать. Поэтому вот эту штуку пока лучше, наверное, не использовать.
**Н.:** Угу.
**А.:** А в более старых сборках вот это почему-то очень сильно помогало. То есть она кэширует все записи и работает быстрее.
**Н.:** То есть она берёт, э-э, по системному имени в шаблоне и кладёт это всё в контейнер.
**А.:** Да-да-да.
**Н.:** Угу.
**А.:** И контейнером является `item`, который мы уже дальше используем для фильтрации.
**Н.:** Угу.

(78:32) **А.:** А, вот. Что здесь прикольного? Здесь прикольного получения даты текущей. Вот так получается дата текущая. И потом здесь по условию надо было получить, э-э, э-э, время начала дня, то есть 00:00, текущей даты.
**Н.:** Угу.
**А.:** И в чём тут фильтр? Что мы проверяем, что у нас... если у нас заполнена дата завершения работы... точнее, не заполнена... То есть ещё раз, вот эта штука проверяет, что у нас, э-э, заполнено, не пустое.
**Н.:** Не пустое.
**А.:** А если мы инвертируем это через `not`, то мы говорим о том, что если у нас дата завершения работы пустая, тогда мы у текущей записи берём, э-э, плановый срок даты завершения, приводим его к старту дня и проверяем, что у нас дата текущая больше, чем плановая дата завершения. То есть здесь, э-э, фильтрация происходила: просрочена работа или нет.
**Н.:** Угу.
**А.:** Иначе, если у нас дата завершения работы... то есть вводился список всех просроченных работ. Иначе, там проверяем дату завершения работы, э-э, получаем, э-э, время начала дня, дата завершения.
**Н.:** Угу.
**А.:** Э-э, потом, э-э, берём плановую дату завершения и проверяем, что у нас дата завершения...
**Н.:** Больше, чем...
**А.:** дата старта.
**Н.:** Дата начала.
**А.:** Короче, что плановая дата завершения больше, чем фактическая план завершения.
**Н.:** Угу.
**А.:** Что задача успела в срок сделана. Ну или там заявка какая-то.
**Н.:** Угу.
**А.:** Какой-то план. То есть либо мы проверяем, что она уже не просроченная, если у нас дата завершения, э-э, не заполнена, либо мы проверяем, что задачу закрыли в срок до даты завершения плановой.
**Н.:** Угу.

(81:04) **Экран:** Звонок завершается.
**А.:** Ну вот, такое вот сравнение. Ну, круто.
(81:17) **Экран:** А. переходит в редактор выражений Comindware, показывает код.
(81:41) **А.:** Я вообще желательно...
**Н.:** Да, вот я как раз собиралась этим заняться. Я вчера-позавчера... где-то есть у меня там просто выраженьки. Вот, я пыталась там выраженьки переписать на... тройки. Вот. Но там как раз были места по большей части на системном фильтре таблиц, и, скорее всего, это просто не сработало. Ну, я постараюсь, посмотрю, что ещё можно сделать. Ну, такие там простые, где там... нам из такого-то шаблона надо достать атрибут пользователя, и потом этого пользователя засунуть в значение.
(82:27) **А.:** Ну вот по статусам можно что-то пофильтровать. То есть, допустим, у нас есть все там претензии, у них сделать какой-нибудь статус... хотя бы просто текстом, там три статуса сделать.
**Н.:** Угу.
**А.:** И пописать эти фильтры на системное...
(82:48) **Экран:** А. переходит в настройки таблицы.
**А.:** сюда, посмотреть, что выводится. Там я вот писал на вторую таблицу, там перепутал. Не в форму... А, вроде дописал его. А здесь, допустим, фильтруется, остаются все записи, у которых там дата создания, э-э, за два дня.
**Н.:** Угу.

(83:13) **Экран:** А. показывает код с `cmwlocal:between`.
**А.:** Эта штука не нужна... вот такая ещё есть. А, `plus one day`, `plus two day`, вот, это я вспомнила, да, это я уже видела.
**А.:** Ну она фактически, ты её тут задаёшь, а... как её взять, то есть её надо именно заполнить... ой, запомнить.
**А.:** Ну вот, это я получаю дату начала. Здесь я там перевожу это в длительность, э-э, потом дату прибавляю с длительностью, получаю день до, точнее, вычитаю здесь длительность. И потом проверяю, что у текущей записи получи нам дату создания и проверь, что она между... э-э, днём назад и между сегодня. То есть все заявки, которые в рамках одних суток были.
**Н.:** Угу.
**А.:** Такой вот фильтр.

(84:12) **Экран:** А. нажимает на кнопку "Запись", чтобы завершить запись звонка.
**А.:** Ну, я думаю, на сегодня хватит, в принципе.
**Н.:** Ну, нормально.
**А.:** Класс.
**Н.:** Спасибо, Саша.
**А.:** Да не за что.
**Н.:** Офигенно. Спасибо тебе большое.
**А.:** Пожалуйста. Это, правда, ещё много чего я не это, не рассказал.
**Н.:** Это бесценно, правда. Ну, это, ты видишь, ты говоришь, там, э-э, не всё есть в справочнике. То есть клиенты-то думают, что там всё есть.
**А.:** Ну, да, и много что не работает.
**Н.:** Ну вот, да, и с этим тоже, чтобы не напороться на то, что я там буду рассказывать, а... они говорят: "Да-да-да, там вот это работает, мы сейчас вот это сделаем", а...
**А.:** Ну вот всё, что у меня описано вот здесь, то есть все формулы, все, э-э, функции, вот это всё 100% работает. На всех сборках везде это работает.
**Н.:** Ну, крутяк.

(85:11) **Экран:** А. показывает свой файл с примерами кода.
**А.:** Пойду пробовать, начну с простого.
**А.:** Всё, хорошо.
**Н.:** Спасибо большое, Саша.