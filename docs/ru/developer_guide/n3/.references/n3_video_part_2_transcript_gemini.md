### Подробный анализ и объяснение

Это видеофрагмент технического урока или семинара, на котором лектор вместе со студентами разбирает сложное правило, написанное на декларативном языке запросов. Этот язык, судя по синтаксису и концепциям, тесно связан с технологиями семантической паутины, такими как **RDF (Resource Description Framework)** и языком запросов **SPARQL**. Правило предназначено для выборки данных из некой базы знаний или онтологии.

#### Основная задача правила

**Цель:** «Вывести неархивные записи, где текущий пользователь является создателем записи или руководителем создателя записи».

Лектор последовательно, строчка за строчкой, разбирает логику этого правила, объясняя, как система (вероятно, движок правил) его выполняет.

#### Ключевые концепции и их разбор

1.  **Префиксы и пространства имён (`@prefix`)**
    *   **Что это:** Первые пять строк кода (`@prefix ontology: ...`, `@prefix user: ...` и т.д.) определяют **префиксы**. Это стандартный механизм в RDF-подобных системах для сокращения длинных URI (уникальных идентификаторов ресурсов). Вместо того чтобы каждый раз писать полный URI, например, `<http://semantic.sergei-kolesnikov.ru/project/1/ontology/1.0#findProperty>`, можно использовать короткую форму `object:findProperty`.
    *   **Объяснение лектора:** Лектор наглядно демонстрирует это, написав на доске, что короткая запись `object:findProperty` эквивалентна длинной записи с полным URI. Это делается для читаемости и краткости кода.

2.  **Триплеты (Субъект-Предикат-Объект)**
    *   **Что это:** Основа модели данных RDF. Любой факт в базе представляется в виде тройки: `Субъект Предикат Объект`.
        *   **Субъект:** Ресурс, который описывается.
        *   **Предикат:** Свойство или отношение, описывающее субъект.
        *   **Объект:** Значение свойства или другой ресурс, с которым связан субъект.
    *   **Объяснение лектора:** Лектор постоянно просит студентов идентифицировать эти три части в каждой строке правила. Например, в строке `(?nit ?_creator) object:findProperty ?property_creator`:
        *   **Субъект:** `(?nit ?_creator)` — это список, состоящий из двух переменных.
        *   **Предикат:** `object:findProperty` — это специальная функция для поиска идентификатора свойства.
        *   **Объект:** `?property_creator` — переменная, в которую будет записан результат.

3.  **Переменные и выполнение запроса (энумераторы)**
    *   **Что это:** Слова, начинающиеся с вопросительного знака (например, `?item`, `?container`), являются переменными. Движок правил пытается найти значения (ресурсы) из базы, которые можно подставить вместо этих переменных, чтобы утверждение (триплет) стало истинным.
    *   **Объяснение лектора:** Лектор объясняет, что работа движка зависит от того, определена ли переменная на данный момент:
        *   **Если переменная не определена (пуста):** Движок ищет все возможные значения в базе, которые удовлетворяют условию. Этот процесс называется **энумерацией**.
        *   **Если переменная уже определена (связана):** Триплет работает как **фильтр** или проверка — он проверяет, истинно ли утверждение для уже известного значения.
    *   **Оптимизация:** Студент правильно замечает, что для оптимизации запросы, которые возвращают меньше всего результатов (наиболее селективные), нужно ставить как можно раньше. Это сокращает количество итераций для последующих шагов.

4.  **Специальные (встроенные) предикаты**
    *   **`object:findProperty`:** Это, по-видимому, встроенная функция, которая находит уникальный идентификатор (`obs-ID`) атрибута по его системному имени (алиасу) и системному имени шаблона, в котором он определён. Это нужно, так как одно и то же системное имя атрибута (например, `_creator`) может использоваться в разных шаблонах и иметь разные `obs-ID`.
    *   **`object:alias`:** Этот предикат, вероятно, связывает внутренний идентификатор шаблона (например, `ОА-15`) с его системным именем (`?nit`).
    *   **`user:current`:** Получает идентификатор текущего авторизованного пользователя из контекста сессии.
    *   **`assert:union`:** Самый сложный предикат в примере. Это логический оператор **"ИЛИ" (OR)**. Он принимает в качестве субъекта список из нескольких подзапросов (формул). Правило считается истинным, если хотя бы один из этих подзапросов истинен. Результаты всех истинных подзапросов объединяются.

#### Пошаговый разбор логики правила

1.  **Найти ID атрибута "Создатель"**: `(?nit ?_creator) object:findProperty ?property_creator`. Здесь `?nit` — это "nit", `?_creator` — это "_creator". Система находит уникальный ID для атрибута с системным именем `_creator` в шаблоне с системным именем `nit` и записывает его в переменную `?property_creator`.
2.  **Найти ID шаблона**: `?container object:alias ?nit`. Система находит ID шаблона (`?container`), у которого системное имя — "nit".
3.  **Найти все записи в шаблоне**: `?item rdfs:member ?container`. Система находит все записи (`?item`), которые принадлежат найденному шаблону (`?container`). Этот шаг создает основной набор данных для дальнейшей фильтрации.
4.  **Отфильтровать неархивные**: `NOT { ?item v-s:is_disabled true }`. Из найденных записей удаляются те, у которых есть свойство `v-s:is_disabled` со значением `true`.
5.  **Найти ID текущего пользователя**: `?user_current user:current ()`. Система получает ID текущего пользователя и записывает его в `?user_current`.
6.  **Применить "ИЛИ" (`assert:union`)**: Это основная логическая проверка.
    *   **Условие 1: Пользователь — создатель**: `?item ?property_creator ?user_current`. Проверяется, является ли текущий пользователь (`?user_current`) создателем (`?property_creator`) записи (`?item`).
    *   **Условие 2: Пользователь — руководитель создателя**: Этот блок сложнее. Сначала находится создатель записи (`?user`), а затем проверяется, является ли текущий пользователь (`?user_current`) его руководителем (`v-s:manager`).

В итоге, правило вернёт список всех `?item`, которые не в архиве и для которых выполняется либо первое, либо второе условие из `assert:union`. Урок отлично демонстрирует декларативный подход к программированию, где важна не последовательность действий, а описание конечного результата и отношений между данными.

### Полная транскрипция

[00:00:00]
**Видео:** Камера показывает мужчину с бородой в розовой футболке-поло, стоящего в помещении, похожем на учебный класс. Он смотрит на экран, который не виден зрителю. На правой части экрана есть небольшое круглое окно видеозвонка с другим мужчиной в серой футболке, который улыбается. Внизу экрана видна подпись «George R3 Folyan».
**Лектор:** Что я, на чём мы остановились-то? Забыл уже.

[00:03:00]
**Лектор:** А, давайте рулы смотреть настоящие. Всё. Вы же уже прошли даже, разбираетесь. То есть сначала будете их читать.

[00:09:00]
**Лектор:** Потом рассказывать, как они работают. Прежде чем что-то писать, надо научиться читать.
**Студент 1 (за кадром):** А домашнее задание?

[00:15:00]
**Лектор:** Домашнее задание...
**Видео:** Лектор поворачивается в сторону студентов, которые находятся за кадром.
**Студент 2 (за кадром):** Домашнее задание вот открываешь, этот...

[00:20:00]
**Лектор:** Домашнее задание вы делаете каждый по этому самому, по вычисляемому свойству. Простому... и что-нибудь такое посложнее, осложнение.
**Студент 2 (за кадром):** Потом всё равно расскажешь?

[00:30:00]
**Лектор:** Что? Ну, что-нибудь попроще сначала, давай найдём. Немножко так, сэкономим.
**Студент 1 (за кадром):** А вот вопрос, пока ищем.

[00:36:00]
**Студент 1 (за кадром):** Пока ищем. А мы только мы используем такой метод? Или это...
**Лектор:** Клиенты или... используют клиенты, скорее всего, не используют, они не знают.
**Студент 1 (за кадром):** Нет, а вообще, во вселенной, в нашей...

[00:46:00]
**Студент 2 (за кадром):** Вот смотри: вывести неархивные записи, где текущий пользователь что-то такое. Давай посмотрим.
**Видео:** Камера переключается на экран компьютера. На экране открыт редактор кода со светлым текстом на тёмном фоне. Виден заголовок правила: «Вывести неархивные записи, где текущий пользователь создатель или руководитель создателя (assert:union)».

[00:52:00]
**Студент 2 (за кадром):** Видишь такой?
**Студент 1 (за кадром):** assert:union есть.
**Лектор (за кадром):** Ну, assert:union сейчас разберёмся. Давайте его смотреть, да.

[01:01:00]
**Лектор (за кадром):** Ну читайте. Что сверху написано? Первые строчки.
**Студент 1 (за кадром):** Ага.

[01:05:00]
**Лектор (за кадром):** Давайте по очереди. Слева направо. Серёжа, пропустим, он, наверное, читать умеет.
**Студент 2 (за кадром):** Всё умею, да, всё.
**Лектор (за кадром):** Я не умею.

[01:11:00]
**Студент 1 (за кадром):** Сейчас, подойду, я просто очков...
**Лектор (за кадром):** Я ничего не умею.
**Студент 1 (за кадром):** `@prefix`... Что в этих первых пяти строчках?
**Видео:** Лектор, стоявший за кадром, возвращается в поле зрения камеры, теперь он снова стоит перед белой доской.

[01:20:00]
**Студент 1 (за кадром):** Сейчас, подчинённые смотрят насчёт всего.
**Лектор:** Так что я не инициализирую сейчас. Логгер... Ну вообще, что от этих пяти строчек обозначает?
**Студент 1 (за кадром):** Логгер?

[01:31:00]
**Лектор:** Они как бы все про одно и то же.
**Студент 1 (за кадром):** `ontology` — это сборник чего-то.
**Лектор:** Это все, получается. Да, все эти, все объекты, все пользователи, все аккаунты, `assert`, `logger`. Я не знаю, что это...

[01:47:00]
**Лектор:** Да. На самом деле, это объявление `namespaces`. Это объявление пространства имён, чтобы потом вот эти вот штуки не писать...
**Студент 1 (за кадром):** Какие?
**Лектор:** Вот эти вот скобочки чтобы не писать, а просто писать `account:` что-то.

[01:58:00]
**Лектор:** Ну.
**Студент 1 (за кадром):** А-а, не понял.
**Лектор:** Ну вот смотри, видишь `object`, я уже это объяснял, `object:findProperty`.
**Студент 2 (за кадром):** Говорил же я, Пётр, сломаешь ты в лагере голову.

[02:08:00]
**Лектор:** Не, ну в чём здесь рулы? С урлами. Ну нормально, что, ну чтобы все понимали, как это работает.
**Видео:** Лектор берёт маркер и подходит к белой доске.
**Лектор:** То есть вот там написано `object`... префикс, да?

[02:18:00]
**Лектор:** И какой-то там `URL`, да? И в конце решёточка. И это называется `object`. Так вот? Таким образом мы префикс задали. То есть это сокращение некоторое, объявление `namespace`.
**Видео:** Лектор пишет на доске: `object - http://... #`

[02:34:00]
**Лектор:** Дальше мы этот `object`... видишь, написано `object:findProperty`.
**Видео:** Лектор продолжает писать на доске: `object:findProperty`.
**Лектор:** И это означает, что `findProperty` из пространства имён, которое определено этим префиксом. То есть это то же самое... вот вот эта запись — это то же самое, что написать скобочку открыть, `http://`, вот всё, что там про `object` было написано, решёточка в конце, блин, и `findProperty`.
**Видео:** Лектор пишет на доске: `<http://...#findProperty>`.

[03:06:00]
**Студент 2 (за кадром):** Мы задаём сокращение для...
**Лектор:** То есть, получается, вот эти пять...
**Студент 1 (за кадром):** Это просто, да, набор...
**Лектор:** Это всё превращается в одно `findProperty`. Все пять вот эти...
**Студент 1 (за кадром):** Нет, `object`, смотри, вот видишь, я использую `object`, чтобы здесь вот этот `URL` не писать.

[03:21:00]
**Студент 1 (за кадром):** А, вижу, всё. Теперь понял.
**Лектор (за кадром):** Ну вставь туда этот `URL` просто.
**Студент 1 (за кадром):** А если я напишу `find`, то будет...
**Лектор:** То есть только в фигурных скобках...
**Видео:** На экране компьютера студент выделяет текст `object:findProperty` и заменяет его на полный URI, который лектор написал на доске.

[03:30:00]
**Студент 1 (за кадром):** Нет, ну сделай, а то что-то непонятно будет. В угловых или в...
**Лектор:** Вот в таких, да. Вот эту... Просто сокращение, чтобы было. Я понял, понял. Там, где `object`, двоеточие, `object` там везде, в там в нескольких местах. Ну я просто здесь покажу.
**Видео:** Студент удаляет двоеточие и закрывает URI угловой скобкой.

[03:50:00]
**Лектор:** Двоеточие удали. И после `findProperty` кавычку закрой. То есть чтобы вот такую херню длинную не писать, придумали префиксы, которые после двоеточия, вот, ну, пишешь, получается коротко. Вот зачем это нужно.

[04:11:00]
**Студент 1 (за кадром):** Понятно?
**Студент 2 (за кадром):** Угу.
**Лектор (за кадром):** Я только не понимаю, какова цель вот этого... выражения всего.

[04:22:00]
**Лектор:** Всего?
**Студент 1 (за кадром):** Ну вот этот набор...
**Лектор:** Вот первые пять строчек — это сокращение.
**Студент 1 (за кадром):** Я пока просто...
**Студент 2 (за кадром):** Мы пока читаем просто, да.
**Лектор:** Это понятно?
**Студент 1 (за кадром):** Да, понятно.
**Лектор (за кадром):** А цель...
**Студент 2 (за кадром):** Цель вон сверху написана: «Вывести неархивные записи, где текущий пользователь что-то там... создатель или руководитель создателя». Вот цель тройки вычислить.
**Лектор:** Иерархия, условия... Да.

[04:42:00]
**Лектор:** Вот первую строчку здесь читаем. Что здесь является субъектом, что предикатом, а что объектом для начала?
**Студент 1 (за кадром):** Это мне вопрос?
**Лектор:** Да, да. Следующий следующему будет оператору.
**Студент 1 (за кадром):** Так, в первой строчке, где `(?nit ?_creator)`... Да, вот это вот.

[04:56:00]
**Студент 1 (за кадром):** Э-э, что является предикатом, что...
**Лектор:** Субъектом и что объектом.
**Студент 1 (за кадром):** Это триплет.
**Лектор:** То есть тройка.
**Студент 1 (за кадром):** Ох...

[05:07:00]
**Видео:** Лектор снова подходит к доске.
**Студент 1 (за кадром):** Сейчас, сейчас...
**Лектор:** Нам нужно найти... третью часть, вот из этих... объектов. Что объектом является? С конца пойдём, чтобы проще было.
**Студент 1 (за кадром):** Свойство.

[05:44:00]
**Лектор:** Ну, здесь слово какое из этих слов... Тут написано много слов. Какое из них является объектом?
**Студент 1 (за кадром):** После вопросительного знака, который `?property_creator`.
**Лектор:** Это вместе с вопросительным знаком. Это вместе слово, короче, `?property_creator`. Да, вот это `object`.

[05:59:00]
**Лектор:** Что предикатом является?
**Студент 1 (за кадром):** `findProperty`. Выполнить поиск.
**Лектор:** `object:findProperty`. Да.
**Студент 1 (за кадром):** А, это одно... действие.
**Лектор:** Ну, да. Просто мы не стали его записывать в этих фигурных скобках. Понимаешь? Это всего лишь сокращённая такая вот штука.
**Студент 1 (за кадром):** Это действие, ну...
**Лектор:** Предикат.
**Студент 1 (за кадром):** Предикат, да-да-да-да.
**Лектор:** Факт. О!
**Студент 1 (за кадром):** Нет...
**Лектор:** Предикат.
**Студент 1 (за кадром):** Фильтрует...
**Лектор (за кадром):** А факт — это не...
**Студент 1 (за кадром):** А, факт — это и есть тройка.
**Лектор:** Да, всё, понял.
**Студент 2 (за кадром):** Факт — это вся строчка.
**Лектор:** Да. Так, и, соответственно, субъектом является...
**Студент 1 (за кадром):** `(?nit ?_creator)`.
**Лектор:** `?nit` и `?_creator` — два слова, объединённые в этом... То есть это лист как бы, да. Субъектом является лист, который состоит из двух... из двух слов: `?nit` и `?_creator`.

[06:39:00]
**Лектор:** А что в нашем случае значит `?nit`?
**Студент 1 (за кадром):** `?nit` — это шаблон записи.
**Лектор:** Почему? Потому что семантика вызова этого предиката `object:findProperty`, где-то у вас, наверное, написано. Это волшебный предикат. То есть `object:findProperty` выводит справа `property_id`, на самом деле он выводит, волшебный, `property_id` он выводит, а слева ему в скобочках отдаётся алиас, что это, контейнера там или... шаблона.
**Видео:** Лектор пишет на доске: `object:findProperty`, `property_id`, `(алиас шаблона, алиас атрибута)`.

[07:13:00]
**Лектор:** Шаблона... и алиас атрибута. А он выводит `obs-42`, тот самый, про который я говорил. Вот. Вот это семантика вызова этого предиката. То есть `?nit` — это какой-то шаблон записи. Подчёркивание `_creator` — это алиас вот этого атрибута, автора, типа.

[07:37:00]
**Студент 2 (за кадром):** Это системный атрибут.
**Лектор:** Какая разница.
**Студент 2 (за кадром):** Через этот `ЦМД` какой-нибудь там, да?
**Лектор:** Не надо, мы читаем, что здесь написано. Он нашёл ему какой-то вот... в `?property_creator` он потом засунет какой-то `obs-42` или что он там найдёт, как он...
**Студент 2 (за кадром):** У них был `dynax`, есть свой паттерн.
**Лектор:** Он все... вот всё, мы ему говорим, как бы сходи в шаблон записи `?nit`, да, там есть у него такое атрибут `creator`, и мы ему говорим, возьми у всех...
**Студент 2 (за кадром):** У этого `creator`...
**Лектор:** Нет, возьми у этого `creator` идентификатор сам. Идентификатор свойства, чтобы `obs-42` получилось.

[08:13:00]
**Студент 2 (за кадром):** Не значение поля, а у...
**Студент 1 (за кадром):** У нас их...
**Лектор:** Атрибута. У атрибута возьми название.
**Студент 1 (за кадром):** В смысле, тип атрибута или что имеется в виду?
**Лектор:** Нет, вот открой атрибут в другом окне.
**Студент 1 (за кадром):** А, просто у атрибута...
**Студент 2 (за кадром):** У атрибута, да, ты не значение берёшь атрибута в объекте.
**Лектор:** Открой атрибут, покажи просто, что...
**Студент 1 (за кадром):** А почему иреалист такая... если я просто взял айдишник.
**Лектор:** Ну а как ты иначе...
**Студент 2 (за кадром):** Тебе надо передать два параметра. Тебе надо передать два параметра, как ты их по тройке передашь?

[08:42:00]
**Видео:** На экране появляется окно с настройками атрибута «Есть активная подписка». В поле «Системное имя» указано `s_has_active_subscription`.
**Лектор (за кадром):** Атрибуты, открываем атрибут. Вот системное имя у него есть «активная подписка». А сам атрибут, ну, закрой. Вот он называется `obs-646`. Видишь? Так чтобы этот `obs-646` найти, надо отдать вот это слово «есть активная подписка» и второе слово, которое называется системное имя этого... шаблона контрагента.

[09:16:00]
**Студент 2 (за кадром):** Хочешь получить айдишник атрибута.
**Лектор:** Тебе надо просто это запомнить, что это как бы лист он возвращает. Ну, не он возвращает, а лист. Ты ему говоришь: вот для этих двух слов, которое первое слово означает алиас... `nit` — это алиас этого... шаблона контрагента, вот в случае, когда Серёга показывал. Второе, `creator`, — это алиас этого свойства «есть активные подписки» там или что. Вот ты ему просто два алиаса сообщаешь на вход.

[09:41:00]
**Студент 2 (за кадром):** А я вот так не могу одним найти?
**Лектор:** Можешь. Ну найди, как? Что что тебе надо знать для того, чтобы найти этот `obs-42`?
**Студент 1 (за кадром):** Он, ну, он не уникальный, допустим, этот `creator` для...
**Лектор:** Он не глобальный, не уникальный. У каждого шаблона свой `creator`, своё свойство `creator`. Он глобально не уникальный. Он уникален в рамках одного шаблона.

[10:11:00]
**Студент 1 (за кадром):** А, ну вот, вот, вот так что-то...
**Лектор:** Только вот из-за этого такая хрень.
**Студент 1 (за кадром):** Можно совсем тупой вопрос? Что значит, почему в кавычках `nit`?
**Лектор:** Потому что это название шаблона записи.
**Студент 1 (за кадром):** Какого-то шаблона записи, название.
**Лектор:** В данном случае он называется `nit` у нас.
**Студент 1 (за кадром):** А, всё, понял.
**Лектор (за кадром):** Системное имя.
**Студент 1 (за кадром):** Просто, да, я понимаю, да.
**Лектор:** Системное имя `nit` какое-то было. А `_creator` — это системное имя атрибута «создатель».
**Студент 2 (за кадром):** Смотри, у тебя ты ты в первую строчку, у тебя цель — найти айдишник атрибута.
**Лектор:** Ага, понимаю. В определённом шаблоне.
**Студент 1 (за кадром):** Который при условии, что он не в архиве, имеется в виду?
**Лектор:** Не, не, пока неважно. Первая строчка, просто нам надо достать этот...
**Студент 2 (за кадром):** То есть ты сначала, ты говоришь, сначала я хочу найти айдишник...
**Лектор:** Изначально у нас ничего нету как бы, и вот мы начинаем как бы собирать.
**Студент 2 (за кадром):** Да. Что-то есть. Для того, чтобы найти айдишник поля, есть вот `builtin:findProperty`.
**Лектор:** Вот в этой...
**Студент 2 (за кадром):** Понял. В чём прикол.
**Лектор (за кадром):** И в этот `parameters` ты передаёшь в эту функцию, в этот `builtin`.

[11:21:00]
**Студент 2 (за кадром):** Ну, здесь ещё есть понятие оптимизации. Почему именно здесь стоит вот эта хрень, да? Потому что она всегда возвращает только одно... один айдишник. То есть тебе нужно найти всегда... Ну да, чем более точный запрос...
**Лектор:** Нет, запросы всегда пишутся от возврата наименьшего значения, вот именно энумератора, да, до к большему. То есть...
**Студент 2 (за кадром):** Сверху у тебя будет максимально возвращаемый, то у тебя каждый раз при прокрутке...
**Лектор:** Все мозги...
**Студент 1 (за кадром):** Ну просто...
**Лектор:** Понятно, да, что эта строчка сделала?
**Студент 1 (за кадром):** Ну надо потом это уже объяснять.
**Лектор:** Мы говорим, эту запусти вот эту функцию, на вход даём ей два параметра.
**Студент 1 (за кадром):** Не, ну вопрос, почему вообще он в начале, да, стоит?
**Лектор:** В `?property_creator` запишется результат этой переменной.
**Студент 1 (за кадром):** То есть результатом того, что атрибут...
**Лектор:** Ну что вот этот `findProperty` функция выполнит.
**Студент 1 (за кадром):** И ответом у нас...
**Лектор:** В эту переменную запишется результат этой функции.
**Студент 1 (за кадром):** И ответом будет айди...
**Лектор:** На входе функция доказывает, что это будет айди этого атрибута. Ну не ответ, а в `?property_creator` подставится значение вот этого... `obs`.

[13:04:00]
**Студент 2 (за кадром):** Лист — это же просто некая ссылка, грубо говоря, на...
**Лектор:** Вообще потенциально, нет, ну, которая... один и тот же алиас в рамках одного шаблона `nit`, алиас `creator` только у одного свойства.
**Студент 2 (за кадром):** Да, у тебя в рамках шаблона уникальный...
**Лектор:** Теоретически результат тройки может быть несколько значений.
**Студент 2 (за кадром):** Теоретически, да. Здесь вернётся энумератор. То есть всё правильно ты говоришь, только в нём будет одно значение всего.

[13:30:00]
**Лектор:** Вот здесь вернётся энумератор, но одного значения. О'кей, нашли, сюда положили. Давай следующий шаг. С предыдущим не связан.
**Видео:** Камера переключается обратно на экран компьютера, где виден код.

[13:41:00]
**Студент 1 (за кадром):** Почему?
**Лектор (за кадром):** `?container:object.alias ?nit`. Он должен содержать объект с...
**Студент 1 (за кадром):** Ну ты прочитай тройку, что написано вот просто.
**Лектор (за кадром):** А-а...
**Студент 1 (за кадром):** `container` собрать объект.
**Лектор:** Не, ну вот субъектом опять... давай по этой сначала. Субъектом?
**Студент 1 (за кадром):** `?container`. Э-э, да, это там, где...
**Лектор:** Ну, субъектом... `?container`?
**Студент 1 (за кадром):** А-а, выполнить это `object.alias`, ну...
**Лектор:** Предикат.
**Студент 1 (за кадром):** Предикат, да, вот... забываю это слово.
**Лектор:** И `object.alias`, и `object` — `?nit`. Да. А что так вот теперь попробуем на русский перевести, что написано? Знак вопроса `?container` — это какая-то переменная. То есть у какой-то фигни, неизвестной нам пока, `object.alias` — это `?nit`.

[14:28:00]
**Студент 1 (за кадром):** Не знаю, как это сформулировать.
**Лектор:** Есть что-то неизвестное пока нам.
**Студент 2 (за кадром):** Найди мне все субъекты, в которых... Да, у кого `object.alias` равен `?nit`. То есть, по сути...
**Студент 1 (за кадром):** Найти контейнер.
**Лектор:** То есть мы тут наоборот. Мы тут в объекте указали...
**Студент 1 (за кадром):** Ну а что такого? Он в обратную сторону матчит, какая разница.
**Лектор (за кадром):** Что такое `object.alias`?
**Студент 2 (за кадром):** Он в обе стороны ма...
**Лектор:** `object.alias` — `?nit`. `object.alias` — это такое же системное волшебное предикат. Он ничего не вычисляет, просто... Как описываются шаблоны записи? Шаблоны записи описываются так: `ОА-15`, как раз вот этот `object.alias`, «контрагенты».

[15:34:00]
**Лектор:** `ОА-15`, это не... что, по-русски написал или по-английски, «контрагенты»? По-русски. А, по-латински.
**Студент 2 (за кадром):** По-латински, `contractor`...
**Лектор:** А, по-латыни, ну о'кей, да. Значит, это `object.name`.
**Студент 2 (за кадром):** Да, это `name`, а `alias`, соответственно, там, `contractor`...
**Лектор:** А `alias` там какой-то будет... системное имя, соответственно. Да, да, там... `container name` там какой-то, хрен его знает.
**Видео:** Лектор снова пишет на доске, иллюстрируя, как описываются шаблоны.

[16:03:00]
**Лектор:** Вот. Соответственно, в базе такие валяются. Когда вот это спрашивают, база найдёт всё, у чего `object.alias`...
**Студент 1 (за кадром):** `name`.
**Лектор:** Он, соответственно, посмотрел, да, смотрит, `?container` у него пустой.
**Студент 1 (за кадром):** Так, правильно.
**Лектор:** Ему надо чем-то его зацепить.
**Студент 1 (за кадром):** Значит, он, значит, он пошёл как бы от обратного, да, смотреть.
**Лектор:** Да. Значит, он пошёл в базу вот с таким вопросом. Вот это он знает, это он знает. А... вот сюда накрутить всю херню, которая подходит. То есть вернётся энумератор опять и будет... крутить.

[16:36:00]
**Студент 2 (за кадром):** Здесь, конечно, неявная логика такая.
**Лектор:** Неявная, да.
**Студент 2 (за кадром):** В языке программирования ты явно пишешь, где где присваиваемая часть, где, как бы, это, вычисляемая. А тут всё как бы перемешано.
**Лектор:** Он вернёт `ОА-15`, по сути, грубо говоря.
**Студент 2 (за кадром):** Он вернёт себе вот тот самый, как я говорил, энумератор. То есть...
**Лектор:** Но в реальности в нём будет всего один, который будет `ОА-15`. Вот он сейчас вернул энумератор. Пошли на следующую строчку. Что написано?

[17:11:00]
**Лектор:** Можно уже так читать как бы, по-другому.
**Студент 1 (за кадром):** `?item` заранее известен у нас.
**Лектор:** Ну, бывает, что неизвестен.
**Студент 1 (за кадром):** Обычно это контекст текущего объекта, если мы для какого-то вычисляемого свойства там делаем.
**Студент 2 (за кадром):** То есть здесь это для списка, я так понимаю.
**Лектор:** Он бывает, что неизвестен.
**Студент 1 (за кадром):** В системе у нас бывает?
**Студент 2 (за кадром):** Ну вот ещё раз, есть `expression` на выходное значение. То есть вообще у нас в системе два ключевых этих, переменных — входное и выходное. Здесь в качестве этого `expression` на список, здесь будет одно выходное — это `?item`. Здесь входного нету. А в... если ты по объекту там, вычисляемый атрибут и так далее, там всегда есть на вход `?item` — это `ID` объекта, а `value` — это, соответственно, будет значение атрибута.
**Лектор:** Да. Ну, представляем, ладно, `?item`, пускай неизвестен, нам нигде не написали, что он известен. Пускай неизвестен. Соответственно, найди мне всё, опять, что-то похожее на предыдущее. Где контейнер... равен какому-то, то есть вот этому контейнеру, который мы уже сверху получили, да, на данный момент?
**Студент 2 (за кадром):** Да, мы здесь, здесь вычислили.
**Лектор:** То есть сверху мы уже получили этот `ОА-15`, и пойдёт он тогда в базу...
**Студент 1 (за кадром):** А, стоп, найти всё, что... всё, что такое же, как `ОА-15`, задача?
**Лектор:** Нет. То есть вообще изначально задача: тебе надо из какого-то конкретного контейнера, ну, то есть этого, не контейнера, а шаблона, вытащить все записи, которые не архивные и при этом текущий пользователь там кто-то там у них, создатель.

[18:45:00]
**Лектор:** Понял? Что тут как бы пытаются сделать? Сначала они запомнили себе просто, закэшировали, какой там у создателя, у свойства «создатель», какой там волшебный идентификатор. Теперь они начинают искать объекты пытаются найти, которые лежат в нужном нам этом шаблоне `nit`. Все подряд объекты. Пока просто все подряд. Сначала они нашли этот по алиасу, они нашли этот контейнер, то есть шаблон записи. Теперь они вот этой строчкой начинают искать все записи внутри этого шаблона. То есть вот эта строчка, она означает следующее: вот эта фигня принадлежит конкретному шаблону записи. Который мы выше определили. Ну уже выше его определили, да.

[19:31:00]
**Видео:** Лектор делает паузу, смотрит на студентов за кадром.

[19:40:00]
**Лектор:** Пока понятно?
**Студент 1 (за кадром):** А если бы `?item` был известен, то он бы в `?container` записал, да?
**Лектор:** Нет, если бы `?item` был известен, то это была бы вот такая вот уже проверка, она бы ноль, ну, то есть `true` или `false` вернула. Контейнер у тебя уже есть.
**Студент 1 (за кадром):** У нас сейчас `?item` неизвестен.
**Лектор:** Сейчас неизвестен, да. А у нас на списке неизвестен, да, он?
**Студент 2 (за кадром):** Здесь, из...
**Лектор:** Для списка неизвестен `?item`, да. То есть ты как раз `?item`ы и выводишь, которые подпадут под фильтр.
**Студент 1 (за кадром):** А, я наоборот думал, что как бы у нас на `?item` есть все записи, и какой-то их потом уже фильтрует.
**Лектор:** Нет. Здесь, по-моему... Вот на системных фильтрах такого нет, на системных фильтрах такого нет. Они именно тебе позволяют туда вообще любую херню наперекосяк сунуть. Хоть юзеров с группами объедини и отдай. Что получится — непонятно как бы, но можно даже такое сделать. То есть можно туда за счёт системного фильтра всё подряд бросить, и всё.

[20:34:00]
**Лектор:** Вот. Ну, соответственно, первые три строчки понятно, выражение. То есть он здесь будет крутить подряд все айтемы, которые внутри контейнера `ОА-15`, и по одному их в откручивает и вниз отдаёт.
**Студент 1 (за кадром):** Вот сначала он находит этот контейнер `ОА-15`.
**Лектор:** Правильно, нашёл `ОА-15` вот здесь, потом нашёл здесь айтемы, которые в нём, в этом `ОА-15`, подходящие к нему, да. Дальше идёт проверка. Которые не...
**Студент 1 (за кадром):** Так.
**Лектор:** ...которые не... это синтаксический сахар такой для отрицаний у нас сделан. Не... `is_disabled` `true`.

[21:14:00]
**Лектор:** Ну и там справа написано уже, что такое в этом бизнес-смысле, точно. Которые не содержатся в архиве.
**Студент 1 (за кадром):** Да.
**Лектор:** То есть архив... в архиве они или нет, означает как бы, у нас так записано: если что-то в архиве, то у него `is_disabled` `true` будет. То есть вот это вот такая есть... `Угу`. Если что-то в архиве. Соответственно, если это неправда, то оно не в архиве. Вот так вот они сделали.

[21:45:00]
**Лектор:** Потому что `is_disabled` `false` не пишут, как правило. Просто...
**Студент 1 (за кадром):** Может быть, дурацкий вопрос, но если запись не в архиве, если шаблон не в архиве, то он, получается, уже активен. А почему мы не можем...
**Лектор:** Запись. Ты мог удалить запись, архивировать саму конкретную запись из шаблона, а мог не не удалить. Если ты её заархивировал, то про неё напишется `s_is_disabled` `true`, где-то будет написано там... объект 3050, `is_disabled` `true` в базе запишется. Если заархивировал.
**Студент 1 (за кадром):** А у нас `not`.
**Лектор:** `not`, да, мы говорим, не надо нам заархивированные.
**Студент 1 (за кадром):** Но даже удалённые мы можем найти.
**Лектор:** Ну, удалённые вообще в базе нет.
**Студент 1 (за кадром):** Да.
**Лектор:** `?item` у нас уже как бы, да, есть, отфильтрован. Здесь вот сверху уже отфильтровался, и продолжает как бы, который ты ищешь, продолжает дофильтровывать, получается, да? Вот этим вот условием.

[22:41:00]
**Лектор:** Здесь, Пётр, ещё одна штука, которую ты не дорассказал.
**Студент 2 (за кадром):** Какая?
**Лектор:** Ну, у тебя айтемы изначально предзаполнились, да? Но сейчас ты пошёл матчить уже практически `?item`, да? Причём матчится не только по айтемам, а ещё по другим связанным этим вещам. И он как бы, он, получается, отсекать начинает из айтема теперь те, которые не удовлетворяют условию.
**Студент 1 (за кадром):** Ну мы это потом раскрутим, как оно работает, на энумераторах.

[23:05:00]
**Лектор:** Ну да, ладно. Сейчас мы разберёмся с бизнес-смыслом, потом раскрутим на энумераторах. Так, дальше, следующее строчка, вот эта. Она не там стоит, но да ладно. Ну да. Смысл её...
**Студент 1 (за кадром):** Какая разница, где она?
**Лектор:** Ну потому что она каждый раз у тебя вычисляться будет при итераторе. То есть, короче, сейчас...
**Студент 2 (за кадром):** Сейчас на энумератор, как увидим, как энумераторы крутятся, поймём, что её надо было наверх перетащить, потому что нет смысла, она всегда один и тот же результат возвращает, не от `?item` зависит.
**Лектор:** А зачем нам айдишник текущего пользователя?
**Студент 1 (за кадром):** Потому что дальше мы его будем использовать. Потому что нам, у нас сама цель — «вывести архивные записи, где текущий пользователь...». То есть ты зашёл в систему, ты текущий, ты сам себя определил.
**Студент 2 (за кадром):** Чистый лист, и вот ты определяешь, что вот я есть такой в системе.
**Студент 1 (за кадром):** Что это именно мне нужно, что я себе ищу.
**Лектор:** Ты сам себя просто, ты ты зашёл в систему, всё, ты текущий юзер.
**Студент 1 (за кадром):** Авторизованный, я понимаю.
**Лектор:** Ну да, то есть кто-то... взять и покажи мне, пожалуйста, записи, которые не заархивированы и в которых создатель — я. То есть те, которые я создал.
**Студент 1 (за кадром):** Ну там написано сверху, да.
**Лектор:** Где текущий...
**Студент 1 (за кадром):** А, ну я понял.
**Лектор:** Создатель или руководитель создателя. Соответственно, для того чтобы это считать, нам надо текущего пользователя вытащить. Он берётся из как раз этих... переменных окружения, да, вот которые...
**Студент 1 (за кадром):** То есть сначала он вычисляет, кто пользователь текущий, а потом, что он создатель для этого...
**Лектор:** Да, всё, понял, понял логику.
**Студент 1 (за кадром):** Да.
**Лектор:** Дальше. Дальше.
**Студент 1 (за кадром):** `(assert:union ...)`
**Лектор:** Тут забавная фигня. Плохо отформатировано, поэтому фигово читаемое, да?
**Студент 2 (за кадром):** Это Георгий писал.
**Лектор:** Да, Георгий, плохо отформатировал.
**Студент 1 (за кадром):** Я понимаю, все эти шесть строчек, раз он вычисляет, что он создатель...
**Лектор:** То просто моя фотография... или он... или создатель, или менеджер создателя.
**Студент 1 (за кадром):** Справа видишь, создатель или руководитель создателя.
**Лектор:** Да, да, да. Ну то есть что тут написано, волшебная фигня. Что вот в большом этом является субъектом, что предикатом, а что объектом? Ну лучше опять с конца пойти, потому что...
**Студент 1 (за кадром):** `object` что?
**Лектор:** `assert:union true`, получается.
**Студент 1 (за кадром):** Нет, `object` — `true`. Просто `true`. Да. Так, а предикат?
**Лектор:** Так, предикат `assert:union`.
**Студент 1 (за кадром):** Да, всё.
**Лектор:** А `assert:union` такой, ну...
**Студент 1 (за кадром):** А сейчас мы поймём, что делает `assert:union`.
**Лектор:** А, вот я стою, не понимаю. То есть `assert:union`... семантика вызова `assert:union` такая: у него передаётся списочек... здесь `assert:union`... Ну и здесь или `true`... ну, тут лучше `true` использовать, больше ничего не надо. То есть...
**Видео:** Лектор снова пишет на доске, объясняя синтаксис `assert:union`.
**Лектор:** `assert:union`, `true`. Вот это вот всегда этим... предикат с объектом, да? Иногда можно знак вопроса поставить, если вам надо выяснить, правда ли что-то или неправда. А вот сюда, в список, отдаётся список формул. Вот. И тут про-проверяется, что вот это работает, и вот это работает, и оно это вместе объединяет... оба условия, да? Или то, или другое, или третье. То есть он каждое условие крутит по отдельности и результаты добавляет.

[26:35:00]
**Студент 2 (за кадром):** Ну он добавляет их в переменные общие, которые объявлены внутри.
**Лектор:** Которые внутри задекларированы, да.
**Студент 1 (за кадром):** То есть я правильно понимаю, что это всё суммирует все вышеперечисленные свойства?
**Лектор:** Нет, это только суммирует всё, что вот здесь задано. Потому что давай теперь разберёмся. Мы нашли, что предикат с объектом вот этот `assert:union true`, а здесь снова формулы. То есть это субъект. Давай теперь каждую формулу разберём. Каждая формула — это триплет, ну, набор триплетов через точку зелёную. Первая формула, на самом деле, вот она.
**Видео:** Лектор указывает на код на экране.
**Лектор:** Вот, фигурная открылась, фигурная закрылась. Что написано?

[27:09:00]
**Студент 1 (за кадром):** Текущий пользователь. Покажи мне текущего пользователя.
**Лектор:** Нет. Нет.
**Студент 1 (за кадром):** Что у нас `?item`, что у нас `?property_creator`, что у нас `?user_current`?
**Лектор:** `?item` мы до этого посчитали.
**Студент 1 (за кадром):** Сейчас, вообще...
**Лектор:** `user_current` у нас определён. `Угу`. Соответственно, мы идём...
**Студент 1 (за кадром):** Справа налево идём, да, типа?
**Лектор:** Нет. Ты что у нас тут вообще не определено?
**Студент 1 (за кадром):** `?item` определён.
**Лектор:** Всё у нас определено в этой строчке. Соответственно, он просто проверяет, что это можно или нельзя. Ну, есть такое выра... то есть истинно это выражение или ложно? То есть `?item`, автор, текущий пользователь. Да, нет? Как бы вот это спрашивается.

[28:02:00]
**Лектор:** А второе... вот здесь вот идёт...
**Студент 1 (за кадром):** Какой юзер уже точно?
**Лектор:** А, мы ещё даже не писали, да, мы не использовали `?property_creator`.
**Студент 1 (за кадром):** Нет, мы только первый раз используем, да.
**Лектор:** А второе выражение, вот оно. Оно из двух стоит, из двух уже, из двух троечек.
**Студент 1 (за кадром):** Давай, Андрюха. У кого есть права на это дело.
**Студент 2 (за кадром):** Давай, давай, подсказывай.
**Лектор:** Ну ты прочитай первую строчку.
**Студент 1 (за кадром):** `?item`, так...
**Лектор:** Во втором что делает выражение? Да. Что определено? `?item` определён уже?
**Студент 1 (за кадром):** Нет.
**Лектор:** Почему нет-то?
**Студент 2 (за кадром):** `?item` вот здесь определили. А... Дальше `?item` известен. Всё.
**Студент 1 (за кадром):** Нам сейчас осталось найти, какой пользователь.
**Лектор:** Так, `item` известен, `property_creator` тоже известен. Так, да. То есть у нас уже `item` — это какой-то будет там 343 объект, который вот здесь вот закрепился, 343. `Property_creator` там `obs-15`.
**Студент 2 (за кадром):** А сверху то, что мы `?user_car`... это не относится к нему, да?
**Лектор:** Так он же здесь и нету.
**Студент 2 (за кадром):** Вот-вот, мы сверху...
**Лектор:** Вот эта вот строчка и вот эта строчка независимо считаются, потому что в `assert:union` то, что передаётся...
**Студент 1 (за кадром):** А-а... так жёстко.
**Лектор:** То есть там не без пробела, это ничего не значит.
**Студент 1 (за кадром):** Без точки.
**Лектор:** Ну, у тебя здесь, я говорю, вот это семантически выглядит так: `assert:union` вот здесь, здесь `true` в конце. Здесь список из формул. Вот формулы, вот формулы, ещё могут быть. То есть они между собой не это. Вот. У тебя первая формула вот здесь закончилась. Вот эта вот закончилась. А вот вторая формула вот здесь началась, вот здесь закончилась. Она из двух троек состоит. Первая тройка: `?item` известен, `?property_creator` известен. `?user` первый раз встречаем.

