---
title: 'Урок 2. Синтаксис N3, переменные и формы запросов'
kbTitle: 'Урок 2. Синтаксис N3, переменные и формы запросов'
kbId: 
tags:
    # Common tutorial_n3 tags
    - ElasticData
    - N3
    - Notation3
    - RDF
    - Turtle
    - выражения
    - разработка
    - обучение
    - платформа
    - триплеты
    - тройки
    - уроки
    - учебник
    # Lesson-specific tags
    - синтаксис
    - переменные
    - формы-запросов
    - HR
hide: tags
---

# Урок 2. Синтаксис N3, переменные и формы запросов {: #tutorial_n3_lesson_2 }

## Введение {: #tutorial_n3_lesson_2_intro }

В этом уроке мы расширим понимание N3 на основе навыков из _[урока 1][tutorial_n3_lesson_1]:_ разберём правила именования переменных, типизацию входных и выходных данных, способы присвоения значений, поведение интерпретатора N3 (последовательность и конъюнкция), проверки пустоты и преобразование **формул** в **N3**.

**Предусловия:** пройден [урок 1 «Введение в графовую СУБД и язык N3»][tutorial_n3_lesson_1].

**Расчётная продолжительность:** 1,5 часа.

!!! warning "Бизнес-логика"

    В этом уроке мы будем использовать контекст HR-процесса подбора кандидатов со следующей моделью данных:

    - Связи между сущностями:
        - Подразделение → Вакансии
        - Вакансия → Кандидаты
        - Кандидат → Подразделение
        - Кандидат → Вакансия
        - Кандидат → Руководитель
        - Кандидат → Статус
        - Сотрудник → Подразделение
    - Атрибуты:
        - Шаблон _«Подразделения»_
            - _Вакансии_ — **записи**, **связанный шаблон** _«Вакансии»_
            - _Название_, _Код_ — **текст**
        - Шаблон _«Вакансии»_
            - _Кандидаты_ — **записи**, **связанный шаблон** _«Кандидаты»_
        - Шаблон _«Кандидаты»_
            - _Подразделение — **запись**, **связанный шаблон** _«Подразделения»_
            - _Руководитель_ — **запись**, **связанный шаблон** _«Сотрудники»_
            - _Статус_ — **запись**, **связанный шаблон** _«Статусы кандидата»_
            - _Стаж_ — **число**
            - _Телефон_, _Сопроводительное письмо_, _Код вакансии_, _Название и код подразделения — **текст**
            - Новый кандидат — **логический**
        - Шаблон _«Статусы кандидата»_
            - _Название_, _Код_ — **текст**

    Мы решим следующие бизнес-задачи:

    - получим название и код подразделения кандидата по вакансии и руководителю;
    - проверим статус кандидата;
    - проверим, указан ли номер телефона кандидата;
    - сформируем строку визитки кандидата из его данных.

{% include-markdown ".snippets/tutorial_version_notice.md" %}

## Темы, навыки и задания урока {: #tutorial_n3_lesson_2_taxonomy }

### Темы {: #tutorial_n3_lesson_2_topics }

- Переменные
- Правила записи триплетов
- `?item` и `?value` в разных контекстах
- Типы запросов
- Логика работы итератора
- Конструкция `if {...} then {...} else  {...}
<!-- - Отрицание -->
- Запросы к связанным шаблонам

### Навыки {: #tutorial_n3_lesson_2_skills }

- Корректно объявлять префиксы и переменные
- Составлять запросы для извлечения данных из связанных шаблонов
- Применять различные формы присвоения и проверки совпадений

### Задания {: #tutorial_n3_lesson_2_tasks }

- Написать запросы для извлечения данных из связанных шаблонов
- Применить проверку на пустоту

<div class="admonition question" markdown="block">

## Определения {: .admonition-title #tutorial_n3_lesson_2_definitions}

- **Проверка точного совпадения** — триплет, где заданы субъект, предикат и объект; используется для проверки утверждения _«Есть ли именно такой факт?»_.
- **Операторы** — встроенные предикаты, записанные сокращённо, например `->` — присваивание.

</div>

## Именование переменных и типизация данных {: #tutorial_n3_lesson_2_core }

- Имена переменных должны обозначать соответствующую бизнес-сущность, например: `?candidate`, `?departmentCode`, а не `?c`, `?d`.
  - К именам переменных, хранящих атрибуты, рекомендуется добавлять суффикс `Attr` или `Attribute`,например: `?candidateAttr`.
  - К именам переменных, хранящих значения атрибутов, рекомендуется добавлять суффикс `Val` или `Value`, например: `?candidateValue`.
- Типы данных в переменных `?item` и `?value` зависят от контекста вычисления см. [урок 1][tutorial_n3_lesson_1] и [Справочник по N3][n3_guide_reference].
- Тип данных в `?value` должен совпадать с типом вычисляемого атрибута (текст, число, логический, запись).

!!! example "Вычисление значения текстового атрибута"

    В записи _кандидата_ вычислим значение **текстового** атрибута _«Код вакансии»_, получив его из связанного шаблона _«Вакансии»_.
    
    Этот пример иллюстрирует правила именования типизации переменных:

    ``` turtle
    # Импортируем предикаты для работы с записями.
    @prefix object: <http://comindware.com/ontology/object#>.
    {
        # Получаем атрибуты "Вакансия" и "Код"
        # по их системным именам в соответствующих шаблонов.
        # Помещаем атрибуты в переменные ?positionAttr и ?codeAttr.
        ("Кандидаты" "Вакансия") object:findProperty ?positionAttr.
        ("Вакансии" "Код") object:findProperty ?codeAttr.

        # В текущей записи ?item 
        # получаем ID связанной записи в шаблоне "Вакансии"
        # и помещаем его в переменную ?positionValue.
        ?item ?positionAttr ?positionValue.
        # Из записи вакансии получаем её код
        # в переменную ?codeValue.
        ?positionValue ?codeAttr ?codeValue.
        # Возвращаем текстовый код вакансии
        # в выходную переменную ?value.
        ?codeValue -> ?value.
    }
    ```

## Сравнение формул и языка N3 {: #tutorial_n3_lesson_2_formula_to_n3 }

Чтобы лучше понять логику и применимость выражений на N3, преобразуем приведённое выше выражение для вычисления значения **текстового** атрибута _«Код вакансии»_ в записи _кандидата_ в **формулу**:

``` sql
$Вакансия—>Код
```

!!! tip "Вывод"

    Формула получилась гораздо компактнее выражения на N3.

    Это подчёркивает, что необходимо понимать назначение языка N3 в **{{ productName }}**: запросы на N3 следует использовать в случаях, когда возможностей **формул** недостаточно.
    
    То есть сложность синтаксиса языка N3 компенсируется его расширенными возможностями.
    
    Области применения и преимущества формул и языка N3 мы рассмотрели в _[уроке 1][tutorial_n3_lesson_1_languages]_.

## Типы запросов и присвоения в N3 {: #tutorial_n3_lesson_2_query_forms }

Мы уже знаем, что любые выражения на N3 состоят из триплетов.

При этом в триплете могут быть определены (известны) не все элементы:

- субъект и объект могут быть не определены (то есть их значения неизвестны);
- предикат должен быть определён всегда.

Результат обработки триплета зависит от того, какие элементы определены.

Возможны следующие комбинации:

| Субъект      | Объект       | Операция                                                            |
| ------------ | ------------ | ------------------------------------------------------------------- |
| Определён    | Определён    | Проверка субъекта и объекта на полное совпадение                    |
| Субъект      | Не определён | Поиск объекта по предикату и субъекту                               |
| Не определён | Определён    | Поиск субъекта по предикату и объекту                               |
| Не определён | Не определён | Поиск субъекта и объекта по предикату                               |
| Не определён | `?.`         | Проверка наличия непустого значения (факта) по субъекту и предикату |

Рассмотрим примеры обработки этих форм триплетов.

- **Проверка субъекта и объекта на полное совпадение:** определены субъект и объект

    !!! warning "Бизнес-логика"

        Вычислим значение **логического** атрибута _«Новый кандидат»_ в записи _кандидата_: он должен принимать значение `True`, если _код статуса кандидата_ равен `new`.

    ``` turtle
    # Импортируем предикаты для работы с записями.
    @prefix object: <http://comindware.com/ontology/object#>.
    {
        # Получаем атрибут "Статус" из шаблона "Кандидаты"
        # и помещаем его в переменную ?statusAttr
        ("Кандидаты" "Статус") object:findProperty ?statusAttr.
        # Получаем атрибут "Код" из шаблона "Статусы кандидатов"
        # и помещаем его в переменную ?statusCodeAttr
        ("Статусы кандидатов" "Код") object:findProperty ?statusCodeAttr.

        # В текущей записи ?item
        # получаем ID связанной записи в шаблоне "Статус"
        # и помещаем его в переменную ?statusValue
        ?item ?statusAttr ?statusValue.
        # Проверяем, что код статуса равен "new",
        # точное совпадение: субъект и объект определены.
        ?statusValue ?statusCodeAttr "new".
        # Если все условия выполнены, возвращаем true
        true -> ?value.
    }
    ```

    !!! example "Эквивалентная формула"

        Чтобы лучше понять логику **N3**, составим **формулу** для такого же вычисления.

        ``` sql
        $Статус->Код == "new"
        ```

- **Поиск объекта по предикату и субъекту:** определён субъект, объект не определён

    !!! warning "Бизнес-логика"

        Вычислим значение **текстового** атрибута _«Название и код подразделения»_ в записи _кандидата_.

        Значение _«Название и код подразделения»_ должно иметь следующий вид: `Название подразделения (код подразделения)`, например `Бухгалтерия (Accounting)`.

    ``` turtle
    # Импортируем предикаты для работы с записями.
    @prefix object: <http://comindware.com/ontology/object#>.
    # Импортируем предикаты для обработки строк.
    @prefix cmwstring: <http://comindware.com/logics/string#>.
    {
        # Получаем атрибут "Подразделение" из шаблона "Кандидаты"
        # (определённый субъект)
        # и помещаем его в переменную 
        # ?deptAttr — неопределённый объект.
        ("Кандидаты" "Подразделение") object:findProperty ?deptAttr.
        # Получаем атрибуты "Код" и "Название" из шаблона "Подразделения"
        # (определённые субъекты) 
        # и помещаем их в переменные
        # ?deptCodeAttr и ?deptNameAttr — неопределённые объекты.
        ("Подразделения" "Код") object:findProperty ?deptCodeAttr.
        ("Подразделения" "Название") object:findProperty ?deptNameAttr.

        # В текущей записи ?item (определённый субъект)
        # получаем ID связанной записи в шаблоне "Подразделение"
        # и помещаем его в переменную 
        # ?deptVal — неопределённый объект.
        ?item ?deptAttr ?deptVal.
        # Из записи подразделения (определённый субъект)
        # получаем его код и название и помещаем их в переменные 
        # ?deptCodeVal и ?deptNameVal — неопределённые объекты.
        ?deptVal ?deptCodeAttr ?deptCodeVal.
        ?deptVal ?deptCodeAttr ?deptNameVal.
        # С помощью предиката cmwstring:format соединяем
        # код и название подразделения (определённые субъекты) в единую строку
        # и помещаем её в переменную 
        # ?deptQualifiedName — неопределённый объект.
        ("{0} ({1})" ?deptNameVal ?deptCodeVal) cmwstring:format ?deptQualifiedName.
        # Возвращаем название и код подразделения в выходную переменную 
        # ?value — неопределённый объект.
        ?deptQualifiedName -> ?value.
    }
    ```

        !!! example "Эквивалентная формула"

            ``` sql
            FORMAT("{0} ({1})", LIST($Подразделение->Название, $Подразделение->Код))
            ```

- **Поиск субъекта по предикату и объекту:** определён объект, субъект не определён

    !!! warning "Бизнес-логика"

        Получим ID всех _подразделениеов_ c кодом _«IT»_.

    ``` turtle
    # Импортируем предикаты для работы с записями.
    @prefix object: <http://comindware.com/ontology/object#>.
    {
        # Получаем атрибут "Код" из шаблона "Подразделения"
        # и помещаем его в переменную ?deptCodeAttr
        ("Подразделения" "Код") object:findProperty ?deptCodeAttr.
        # Находим ID всех подразделениеов с кодом "IT" (определённый объект)
        # и помещаем его в переменную
        # ?deptId — неопределённый субъект.
        ?deptId ?deptCodeAttr "IT".
        # Возвращаем коллекцию ID в выходную переменную ?value.
        ?deptId -> ?value.
    }
    ```

    !!! example "Эквивалентная формула"

        ``` sql
        from a in db->Подразделения where a->Код == "IT" select a->id
        ```

- **Поиск субъекта и объекта по предикату:** субъект и объект не определены

    !!! warning "Бизнес-логика"

        Найдём подразделениеы, на вакансии в которых есть кандидаты, — составим выражение **N3 для системного фильтра таблицы**.

    ``` turtle
    # Импортируем предикаты для работы с записями и строками.
    @prefix object: <http://comindware.com/ontology/object#>.
    {
        # Получаем атрибут "Подразделение" из шаблона "Кандидаты"
        # и помещаем его в переменную ?deptAttr
        ("Подразделения" "Вакансии") object:findProperty ?departmentPositionsAttr.
        ("Вакансии" "Кандидаты") object:findProperty ?positionCandidatesAttr.
        # Находим все связанные через атрибут "Вакансии"
        # пары записей "подразделение-вакансия"
        # (неопределённые субъект и объект)
        # и помещаем записи ?departmentsValue и ?positionsValue
        ?departmentsValue ?departmentPositionsAttr. ?positionsValue.
        # Оставляем только те вакансии, на которые есть кандидаты.
        ?positionsValue ?positionCandidatesAttr ?.
        # Возвращаем отфильтрованный список подразделениеов в переменную ?item.
        ?departmentsValue ->?item.
        
    }
    ```

    !!! example "Эквивалентная формула"

        ``` sql
        FIRST(from a in db->Подразделения WHERE NOT(EMPTY(a->Подразделения->Вакансии->Кандидаты)) select a->id)
        ```

- **Проверка на пустоту значения:** субъект определён, объект задан оператором `?`

    В предыдущем примере мы использовали функцию проверки пустоты `?`. Рассмотрим её работу подразделениеьно.

    !!! warning "Бизнес-логика"

        Вычислим значение **логического** атрибута _«Имеется сопроводительное»_ в записи кандидата: `True`, если кандидат предоставил сопроводительное письмо.

    ``` turtle
    # Импортируем предикаты для работы с записями.
    @prefix object: <http://comindware.com/ontology/object#>.
    {
        # Получаем атрибут "Сопроводительное письмо" из шаблона "Кандидаты"
        # и помещаем его в переменную ?coverLetterAttr
        ("Кандидаты" "Сопроводительноеписьмо") object:findProperty ?coverLetterAttr.
        # Проверяем, что в текущей записи ?item
        # сопроводительное письмо не пустое.
        ?item ?coverLetterAttr ?.
        # Если имеется сопроводительное, возвращаем true
        true -> ?value.
    }
    ```

        !!! example "Эквивалентная формула"

        ``` sql
        NOT(EMPTY($Сопроводительноеписьмо))
        ```

## Получение значения атрибута из связанного шаблона

    !!! warning "Бизнес-логика"

        Получим ФИО нанимающего менеджера кандидата в вычисляемый атрибут.

    ``` turtle
    # Импортируем предикаты для работы с записями.
    @prefix object: <http://comindware.com/ontology/object#>.
    {
        # Получаем атрибут "Менеджер" из шаблона "Кандидаты"
        # и помещаем его в переменную ?managerAttr
        ("Кандидаты" "Менеджер") object:findProperty ?managerAttr.
        # Получаем атрибут "ФИО" из шаблона "Сотрудники"
        # и помещаем его в переменную ?fioAttr
        ("Сотрудники" "ФИО") object:findProperty ?fullNameAttr.

        # В текущей записи ?item получаем ID менеджера
        # и помещаем его в переменную ?managerValue
        ?item ?managerAttr ?managerValue.
        # Из записи менеджера в шаблоне «Сотрудники»
        # получаем ФИО и помещаем его в переменную ?value
        ?managerValue ?fullNameAttr ?value.
    }
    ```

        !!! example "Эквивалентная формула"

        ``` sql
        $Менеджер->ФИО
        ```

## Порядок обработки триплетов и конъюнкция {: #tutorial_n3_lesson_2_interpreter }

При составлении запросов на N3 следует учитывать следующее поведение интерпретатора:

- Триплеты вычисляются сверху вниз.
- Если один из триплетов вернёт `false`, обработка запроса полностью прерывается и выражение возвращает **пустой результат**.
- Между триплетами по умолчанию используется конъюнкция (логическое `И`). В строке после триплета имеется значение `True`, если все предыдущие триплеты внутри вернули `True`.

!!! warning "Бизнес-логика"

    Проиллюстрируем конъюнкцию триплетов: проверим, что в записи кандидата заполнены имя, фамилия и отчество. Для этого вычислим значение логического атрибута: `True`, если все данные кандидата указаны.

``` turtle
# Импортируем предикаты для работы с записями.
@prefix object: <http://comindware.com/ontology/object#>.
{
    # Получаем атрибуты "Фамилия", "Имя", "Отчество"
    # и помещаем их в переменные 
    # ?patronymicAttribute, ?firstNameAttribute, ?lastNameAttribute.
    ("Сотрудники" "Отчество") object:findProperty ?patronymicAttribute.
    ("Сотрудники" "Имя") object:findProperty ?firstNameAttribute.
    ("Сотрудники" "Фамилия") object:findProperty ?lastNameAttribute.  
  
    # Проверяем, что указана "Фамилия".
    ?item ?lastNameAttribute  ?.
    # Проверяем, что указано "Имя".
    ?item ?firstNameAttribute  ?.
    # Проверяем, что указано "Отчество".
    ?item ?patronymicAttribute ?.
    # Если для всех трёх атрибутов заданы значения,
    # возвращаем true.
    true -> ?value.
}
```

!!! example "Эквивалентная формула"

    ``` sql
    AND(NOT(EMPTY($Фамилия)), NOT(EMPTY($Имя)), NOT(EMPTY($Отчество)))
    ```

## Изменение хода обработки триплетов {: #tutorial_n3_lesson_2_interpreter }

Изменить ход обработки триплетов и предотвратить прерывание обработки запроса при пустом или ложном результате можно с помощью двух конструкций:

- `if {...} then {...} else {...}`
- `or {...} or {...}`

!!! warning "Бизнес-логика"

    Предыдущий пример возвращал пустой результат, если не были указаны фамилия, имя или отчество кандидата.
    
    Изменим его так, чтобы он не возвращал пустое значение, и разрешим оставлять отчество пустым. 
    
    Для этого вычислим значение логического атрибута: `True`, если указаны имя и фамилия, `False` во всех остальных случаях.

- Решение с использованием `if {...} then {...} else {...}`

    ``` turtle
    # Импортируем предикаты для работы с записями.
    @prefix object: <http://comindware.com/ontology/object#>.
    {
        # Получаем атрибуты "Фамилия", "Имя", "Отчество"
        # и помещаем их в переменные 
        # ?patronymicAttribute, ?firstNameAttribute, ?lastNameAttribute.
        ("Сотрудники" "Отчество") object:findProperty ?patronymicAttribute.
        ("Сотрудники" "Имя") object:findProperty ?firstNameAttribute.
        ("Сотрудники" "Фамилия") object:findProperty ?lastNameAttribute.  
    
        if {
            # Проверяем, что указана "Фамилия".
            ?item ?lastNameAttribute  ?.
            # Проверяем, что указано "Имя".
            ?item ?firstNameAttribute  ?.
        }
        then {
            # Если для заданы имя и фамилия,
            # возвращаем true.
            true -> ?value.
        }
        else {
            # Не прерываем обработку запроса, а возвращаем false, 
            # если какой-либо из предыдущих триплетов не вернул true.
            false -> ?value.
        }
    }
    ```

- Решение с использованием `or {...} or {...}`

    ``` turtle
    # Импортируем предикаты для работы с записями.
    @prefix object: <http://comindware.com/ontology/object#>.
    {
        # Получаем атрибуты "Фамилия", "Имя", "Отчество"
        # и помещаем их в переменные 
        # ?patronymicAttribute, ?firstNameAttribute, ?lastNameAttribute.
        ("Сотрудники" "Отчество") object:findProperty ?patronymicAttribute.
        ("Сотрудники" "Имя") object:findProperty ?firstNameAttribute.
        ("Сотрудники" "Фамилия") object:findProperty ?lastNameAttribute.  

        or {
            # Оба атрибута заданы — возвращаем true.
            ?item ?lastNameAttribute  ?.
            ?item ?firstNameAttribute  ?.
            true -> ?value.
        }
        or {
            # Не задан один из атрибутов заданы — возвращаем false.
            false -> ?value.
        }
    }
    ```

!!! example "Эквивалентная формула"

    ``` sql
    IF(AND(NOT(EMPTY($Фамилия)), NOT(EMPTY($Имя))), True, False)
    ```

## Типичные ошибки в выражениях на N3 {: #tutorial_n3_lesson_1_typical_errors }

- Проверяйте регистр всех имён: `?variable` и `?Variable` — это разные переменные.
- Проверяйте, что условные блоки кода заключены в фигурные скобки: `or {...} or {...}`, `if {...} then {...} else  {...}`.
- Не забывайте при ставить точки после фигурных скобок: `not {...}.`, `or {...}.`, когда блок кода представляет собой целостный факт. Все факты должны завершаться точкой.
- Выражение должно возвращать значение совместимого типа: строка в текстовый атрибут, число в числовой, список в таблицу и т.&nbsp;д.

## Практическое задание {: #tutorial_n3_lesson_2_practical_task }

Применим полученные в этом уроке знания, чтобы составить сложный запрос с использованием всех рассмотренных элементов синтаксиса N3.

!!! warning "Бизнес-логика"

    В шаблоне _«Кандидаты»_ требуется вычислить составить текстовую сводку по кандидату в следующем формате: _«ФИО: Бобров Б.Б. Стаж: 15 лет. Вакансия: монтажник. Подразделение: строительство (код подразделения). Нанимающий менеджер: Медведев М.М.»_.
    - Пустые поля сводки (кроме ФИО) необходимо заполнить заменителями _«Н.П.»_.
    - Если для кандидата не указаны имя, фамилия или отчество, то сводка должна должна заполняться имеющимися данными.

Для вывода строки воспользуйтесь `cmwstring:format`.

``` turtle
# Импортируем предикаты для работы с записями.
@prefix object: <http://comindware.com/ontology/object#>.
# Импортируем предикаты для работы со строками
@prefix cmwstring: <http://comindware.com/logics/string#>.
{
    # Атрибуты из шаблона "Кандидаты"
    ("Кандидаты" "Фамилия") object:findProperty ?lastNameAttr.
    ("Кандидаты" "Имя") object:findProperty ?firstNameAttr.
    ("Кандидаты" "Отчество") object:findProperty ?patronymicAttr.
    ("Кандидаты" "Стаж") object:findProperty ?experienceAttr.
    ("Кандидаты" "Вакансия") object:findProperty ?positionAttr.
    ("Кандидаты" "Менеджер") object:findProperty ?managerAttr.

    # Атрибуты из связанных шаблонов
    ("Вакансии" "Название") object:findProperty ?positionNameAttr.
    ("Вакансии" "Подразделение") object:findProperty ?positionDeptAttr.
    ("Подразделения" "Название") object:findProperty ?deptNameAttr.
    ("Подразделения" "Код") object:findProperty ?deptCodeAttr.
    ("Сотрудники" "ФИО") object:findProperty ?fioAttr.

    # --- ФИО кандидата: собираем из имеющихся частей ---
    or {
        ?item ?lastNameAttr ?ln.
    } or {
        "" -> ?ln.
    }.
    
    or {
        ?item ?firstNameAttr ?fn.
    } or {
        "" -> ?fn.
    }.
    
    or {
        ?item ?patronymicAttr ?pn.
    } or {
        "" -> ?pn.
    }.
    
    # Объединяем части ФИО через пробел, исключая пустые строки
    (" " ?ln ?fn ?pn) cmwstring:join ?fio.

    # --- Стаж ---
    if {
        ?item ?experienceAttr ?exp.
    }
    then {
        # Стаж указан - используем его
    }
    else {
        "Н.П." -> ?exp.
    }.

    # --- Вакансия (название) ---
    if {
        ?item ?positionAttr ?pos.
        ?pos ?positionNameAttr ?posName.
    }
    then {
        # Вакансия и её название есть - используем их
    }
    else {
        "Н.П." -> ?posName.
    }.

    # --- Подразделение вакансии (Название и Код) ---
    if {
        ?pos ?positionDeptAttr ?dept.
        ?dept ?deptNameAttr ?deptName.
        ?dept ?deptCodeAttr ?deptCode.
        ("{0} ({1})" ?deptName ?deptCode) cmwstring:format ?deptQualified.
    }
    then {
        # Подразделение и его данные есть - используем их
    }
    else {
        "Н.П." -> ?deptQualified.
    }.

    # --- Нанимающий менеджер (ФИО) ---
    if {
        ?item ?managerAttr ?m.
        ?m ?fioAttr ?managerFio.
    }
    then {
        # Менеджер и его ФИО есть - используем их
    }
    else {
        "Н.П." -> ?managerFio.
    }.

    # Итоговая строка сводки
    ("ФИО: {0}. Стаж: {1}. Вакансия: {2}. Подразделение: {3}. Нанимающий менеджер: {4}." ?fio ?exp ?posName ?deptQualified ?managerFio) cmwstring:format ?result.
    ?result -> ?value.
}
```

!!! example "Эквивалентная формула"

    
    ``` sql
    FORMAT("{0} — {1}", LIST($Менеджер->ФИО, $Менеджер->Подразделение->Название))
    ```

Проверьте работу выражения на нескольких записях.

## Итоги урока {: #tutorial_n3_lesson_2_summary }

Вы закрепили базовый синтаксис N3, проработали `?item`/`?value`, разобрали пять форм работы с триплетами, шорткаты и правила «гигиены» выражений. На практике вы построили несколько минимальных запросов и собрали результирующую строку для HR‑сценария.

В ходе [следующего урока][tutorial_n3_lesson_3] вы изучите префиксы, URI и поиск атрибутов, в том числе `object:findProperty` в глубину.

<div class="relatedTopics" markdown="block">

--8<-- "related_topics_heading.md"

- [Справочник по N3][n3_guide_reference]
- [Учебник по N3][n3_tutorial_original]
- [Дайджест примеров N3][n3_examples_digest]

</div>

{% include-markdown ".snippets/hyperlinks_mkdocs_to_kb_map.md" %}
