---
title: 'Урок 2. Синтаксис N3, переменные и формы запросов'
kbTitle: 'Урок 2. Синтаксис N3, переменные и формы запросов'
kbId: 
tags:
    # Common tutorial_n3 tags
    - ElasticData
    - N3
    - Notation3
    - RDF
    - Turtle
    - выражения
    - разработка
    - обучение
    - платформа
    - триплеты
    - тройки
    - уроки
    - учебник
    # Lesson-specific tags
    - синтаксис
    - переменные
    - формы-запросов
    - HR
hide: tags
---

# Урок 2. Синтаксис N3, переменные и формы запросов {: #tutorial_n3_lesson_2 }

## Введение {: #tutorial_n3_lesson_2_intro }

В этом уроке мы расширим понимание N3 на основе навыков из _[урока 1][tutorial_n3_lesson_1]:_ разберём правила именования переменных, типизацию входных и выходных данных, способы присвоения значений, поведение интерпретатора N3 (последовательность и конъюнкция), проверки пустоты и преобразование **формул** в **N3**.

**Предусловия:** пройден [урок 1 «Введение в графовую СУБД и язык N3»][tutorial_n3_lesson_1].

**Расчётная продолжительность:** 1 час.

!!! warning "Бизнес-логика"

    В этом уроке мы будем использовать контекст HR-процесса подбора кандидатов со следующей моделью данных:

    - Связи между сущностями:
        - Отдел → Должности
        - Должность → Кандидаты
        - Кандидат → Отдел
        - Кандидат → Должность
        - Кандидат → Руководитель
        - Кандидат → Статус
        - Сотрудник → Отдел
    - Атрибуты:
        - Шаблон _«Отделы»_
            - _Должности_ — **записи**, **связанный шаблон** _«Должности»_
            - _Название_, _Код_ — **текст**
        - Шаблон _«Должности»_
            - _Кандидаты_ — **записи**, **связанный шаблон** _«Кандидаты»_
        - Шаблон _«Кандидаты»_
            - _Отдел — **запись**, **связанный шаблон** _«Отделы»_
            - _Руководитель_ — **запись**, **связанный шаблон** _«Сотрудники»_
            - _Статус_ — **запись**, **связанный шаблон** _«Статусы кандидата»_
            - _Телефон_, _Сопроводительное письмо_, _Код должности_, _Название и код отдела_ — **текст**
            - Новый кандидат — **логический**
        - Шаблон _«Статусы кандидата»_
            - _Название_, _Код_ — **текст**

    Мы решим следующие бизнес-задачи:

    - получим название и код отдела кандидата по должности и руководителю;
    - проверим статус кандидата;
    - проверим, указан ли номер телефона кандидата;
    - сформируем строку визитки кандидата из его данных.

{% include-markdown ".snippets/tutorial_version_notice.md" %}

## Темы, навыки и задания урока {: #tutorial_n3_lesson_2_taxonomy }

### Темы {: #tutorial_n3_lesson_2_topics }

- Переменные
- Правила записи триплетов
- `?item` и `?value` в разных контекстах
- Пять форм/типов запросов и минимальные примеры
- Операторы равенства `=` и присвоения `->`
- Проверки пустоты и точного совпадения

### Навыки {: #tutorial_n3_lesson_2_skills }

- Корректно объявлять префиксы и переменные
- Составлять минимальные выражения для извлечения значений
- Применять пять форм присвоения и проверки совпадений
- Возвращать результат корректного типа через `-> ?value`

### Задания {: #tutorial_n3_lesson_2_tasks }

- Написать короткие выражения для навигации и получения значения
- Применить проверку на пустоту и точное совпадение
- Использовать платформенный `->` для возврата результата

<div class="admonition question" markdown="block">

## Определения {: .admonition-title #tutorial_n3_lesson_2_definitions}

- **Проверка точного совпадения** — триплет, где заданы субъект, предикат и объект; используется для проверки утверждения _«Есть ли именно такой факт?»_.
- **Операторы** — встроенные предикаты, записанные сокращённо, например `=` — проверка равенства, `->` присваивание.

</div>

## Именование переменных и типизация данных {: #tutorial_n3_lesson_2_core }

- Имена переменных должны обозначать соответствующую бизнес-сущность, например: `?candidate`, `?departmentCode`, а не `?c`, `?d`.
  - К именам переменных, хранящих атрибуты, рекомендуется добавлять суффикс `Attr` или `Attribute`,например: `?candidateAttr`.
  - К именам переменных, хранящих значения атрибутов, рекомендуется добавлять суффикс `Val` или `Value`, например: `?candidateValue`.
- Типы данных в переменных `?item` и `?value` зависят от контекста вычисления см. [урок 1][tutorial_n3_lesson_1] и [Справочник по N3][n3_guide_reference].
- Тип данных в `?value` должен совпадать с типом вычисляемого атрибута (текст, число, логический, запись).

!!! example "Вычисление значения текстового атрибута"

    В записи _кандидата_ вычислим значение **текстового** атрибута _«Код должности»_, получив его из связанного шаблона _«Должности»_.
    
    Этот пример иллюстрирует правила именования типизации переменных:

    ``` turtle
    # Импортируем предикаты для работы с записями.
    @prefix object: <http://comindware.com/ontology/object#>.
    {
        # Получаем атрибуты "Должность" и "Код"
        # по их системным именам в соответствующих шаблонов.
        # Помещаем атрибуты в переменные ?positionAttr и ?codeAttr.
        ("Кандидаты" "Должность") object:findProperty ?positionAttr.
        ("Должности" "Код") object:findProperty ?codeAttr.

        # В текущей записи ?item 
        # получаем ID связанной записи в шаблоне "Должности"
        # и помещаем его в переменную ?positionValue.
        ?item ?positionAttr ?positionValue.
        # Из записи должности получаем её код
        # в переменную ?codeValue.
        ?positionValue ?codeAttr ?codeValue.
        # Возвращаем текстовый код должности
        # в выходную переменную ?value.
        ?codeValue -> ?value.
    }
    ```

## Сравнение формул и языка N3 {: #tutorial_n3_lesson_2_formula_to_n3 }

Чтобы лучше понять логику и применимость выражений на N3, преобразуем приведённое выше выражение для вычисления значения **текстового** атрибута _«Код должности»_ в записи _кандидата_ в **формулу**:

``` sql
$Должность—>Код
```

!!! tip "Вывод"

    Формула получилась гораздо компактнее выражения на N3.

    Это подчёркивает, что необходимо понимать назначение языка N3 в **{{ productName }}**: запросы на N3 следует использовать в случаях, когда возможностей **формул** недостаточно.
    
    То есть сложность синтаксиса языка N3 компенсируется его расширенными возможностями.
    
    Области применения и преимущества формул и языка N3 мы рассмотрели в _[уроке 1][tutorial_n3_lesson_1_languages]_.

## Типы запросов и присвоения в N3 {: #tutorial_n3_lesson_2_query_forms }

Мы уже знаем, что любые выражения на N3 состоят из триплетов.

При этом в триплете могут быть определены (известны) не все элементы:

- субъект и объект могут быть не определены (то есть их значения неизвестны);
- предикат должен быть определён всегда.

Результат обработки триплета зависит от того, какие элементы определены.

Возможны следующие комбинации:

| Субъект      | Объект       | Операция                                                            |
| ------------ | ------------ | ------------------------------------------------------------------- |
| Определён    | Определён    | Проверка субъекта и объекта на полное совпадение                    |
| Субъект      | Не определён | Поиск объекта по предикату и субъекту                               |
| Не определён | Определён    | Поиск субъекта по предикату и объекту                               |
| Не определён | Не определён | Поиск субъекта и объекта по предикату                               |
| Не определён | `?.`         | Проверка наличия непустого значения (факта) по субъекту и предикату |

Рассмотрим примеры обработки этих форм триплетов.

- **Проверка субъекта и объекта на полное совпадение:** определены субъект и объект

    !!! warning "Бизнес-логика"

        Вычислим значение **логического** атрибута _«Новый кандидат»_ в записи _кандидата_: он должен принимать значение `True`, если _код статуса кандидата_ равен `new`.

    ``` turtle
    # Импортируем предикаты для работы с записями.
    @prefix object: <http://comindware.com/ontology/object#>.
    {
        # Получаем атрибут "Статус" из шаблона "Кандидаты"
        # и помещаем его в переменную ?statusAttr
        ("Кандидаты" "Статус") object:findProperty ?statusAttr.
        # Получаем атрибут "Код" из шаблона "Статусы кандидатов"
        # и помещаем его в переменную ?statusCodeAttr
        ("Статусы кандидатов" "Код") object:findProperty ?statusCodeAttr.

        # В текущей записи ?item
        # получаем ID связанной записи в шаблоне "Статус"
        # и помещаем его в переменную ?statusValue
        ?item ?statusAttr ?statusValue.
        # Проверяем, что код статуса равен "new",
        # точное совпадение: субъект и объект определены.
        ?statusValue ?statusCodeAttr "new".
        # Если все условия выполнены, возвращаем true
        true -> ?value.
    }
    ```

    !!! example "Эквивалентная формула"

        Чтобы лучше понять логику **N3**, составим **формулу** для такого же вычисления.

        ``` sql
        $Статус->Код == "new"
        ```

- **Поиск объекта по предикату и субъекту:** определён субъект, объект не определён

    !!! warning "Бизнес-логика"

        Вычислим значение **текстового** атрибута _«Название и код отдела»_ в записи _кандидата_.

        Значение _«Название и код отдела»_ должно иметь следующий вид: `Название отдела (код отдела)`, например `Бухгалтерия (Accounting)`.

    ``` turtle
    # Импортируем предикаты для работы с записями.
    @prefix object: <http://comindware.com/ontology/object#>.
    # Импортируем предикаты для обработки строк.
    @prefix cmwstring: <http://comindware.com/logics/string#>.
    {
        # Получаем атрибут "Отдел" из шаблона "Кандидаты"
        # (определённый субъект)
        # и помещаем его в переменную 
        # ?deptAttr — неопределённый объект.
        ("Кандидаты" "Отдел") object:findProperty ?deptAttr.
        # Получаем атрибуты "Код" и "Название" из шаблона "Отделы"
        # (определённые субъекты) 
        # и помещаем их в переменные
        # ?deptCodeAttr и ?deptNameAttr — неопределённые объекты.
        ("Отделы" "Код") object:findProperty ?deptCodeAttr.
        ("Отделы" "Название") object:findProperty ?deptNameAttr.

        # В текущей записи ?item (определённый субъект)
        # получаем ID связанной записи в шаблоне "Отдел"
        # и помещаем его в переменную 
        # ?deptVal — неопределённый объект.
        ?item ?deptAttr ?deptVal.
        # Из записи отдела (определённый субъект)
        # получаем его код и название и помещаем их в переменные 
        # ?deptCodeVal и ?deptNameVal — неопределённые объекты.
        ?deptVal ?deptCodeAttr ?deptCodeVal.
        ?deptVal ?deptCodeAttr ?deptNameVal.
        # С помощью предиката cmwstring:format соединяем
        # код и название отдела (определённые субъекты) в единую строку
        # и помещаем её в переменную 
        # ?deptQualifiedName — неопределённый объект.
        ("{0} ({1})" ?deptNameVal ?deptCodeVal) cmwstring:format ?deptQualifiedName.
        # Возвращаем название и код отдела в выходную переменную 
        # ?value — неопределённый объект.
        ?deptQualifiedName -> ?value.
    }
    ```

        !!! example "Эквивалентная формула"

            ``` sql
            FORMAT("{0} ({1})", LIST($Отдел->Название, $Отдел->Код))
            ```

- **Поиск субъекта по предикату и объекту:** определён объект, субъект не определён

    !!! warning "Бизнес-логика"

        Получим ID всех _отделов_ c кодом _«IT»_.

    ``` turtle
    # Импортируем предикаты для работы с записями.
    @prefix object: <http://comindware.com/ontology/object#>.
    {
        # Получаем атрибут "Код" из шаблона "Отделы"
        # и помещаем его в переменную ?deptCodeAttr
        ("Отделы" "Код") object:findProperty ?deptCodeAttr.
        # Находим ID всех отделов с кодом "IT" (определённый объект)
        # и помещаем его в переменную
        # ?deptId — неопределённый субъект.
        ?deptId ?deptCodeAttr "IT".
        # Возвращаем коллекцию ID в выходную переменную ?value.
        ?deptId -> ?value.
    }
    ```

    !!! example "Эквивалентная формула"

        ``` sql
        from a in db->Отделы where a->Код == "IT" select a->id
        ```

- **Поиск субъекта и объекта по предикату:** субъект и объект не определены

    !!! warning "Бизнес-логика"

        Найдём все связи между _кандидатами_ и _отделами_ для анализа распределения кандидатов по отделам.

    ``` turtle
    # Импортируем предикаты для работы с записями.
    @prefix object: <http://comindware.com/ontology/object#>.
    {
        # Получаем атрибут "Отдел" из шаблона "Кандидаты"
        # и помещаем его в переменную ?deptAttr
        ("Кандидаты" "Отдел") object:findProperty ?deptAttr.
        # Находим все пары "кандидат-отдел" (неопределённые субъект и объект)
        # и помещаем их в переменные ?candidate и ?department
        ?candidate ?deptAttr ?department.
        # Возвращаем коллекцию связей в выходную переменную ?value.
        # Результат будет содержать все ID кандидатов и их отделов
        (?candidate ?department) -> ?value.
    }
    ```

    !!! example "Эквивалентная формула"

        ``` sql
        from a in db->Кандидаты select (a->id, a->Отдел->id)
        ```

- **Проверка на пустоту значения:** субъект определён, объект задан оператором `?.`

    !!! warning "Бизнес-логика"

        Вычислим значение **логического** атрибута _«Имеется сопроводительное»_ в записи кандидата: `True`, если кандидат предоставил сопроводительное письмо.

    ``` turtle
    # Импортируем предикаты для работы с записями.
    @prefix object: <http://comindware.com/ontology/object#>.
    {
        # Получаем атрибут "Сопроводительное письмо" из шаблона "Кандидаты"
        # и помещаем его в переменную ?coverLetterAttr
        ("Кандидаты" "Сопроводительноеписьмо") object:findProperty ?coverLetterAttr.
        # Проверяем, что в текущей записи ?item
        # сопроводительное письмо не пустое.
        ?item ?coverLetterAttr ?.
        # Если телефон указан, возвращаем true
        true -> ?value.
    }
    ```

        !!! example "Эквивалентная формула"

        ``` sql
        NOT(EMPTY($Сопроводительноеписьмо))
        ```

## Получение значения атрибута связанного шаблона

    !!! warning "Бизнес-логика"

        Получим ФИО менеджера кандидата для отображения в вычисляемом поле.

    ``` turtle
    # Импортируем предикаты для работы с записями.
    @prefix object: <http://comindware.com/ontology/object#>.
    {
        # Получаем атрибут "Менеджер" из шаблона "Кандидаты"
        # и помещаем его в переменную ?managerAttr
        ("Кандидаты" "Менеджер") object:findProperty ?managerAttr.
        # Получаем атрибут "ФИО" из шаблона "Сотрудники"
        # и помещаем его в переменную ?fioAttr
        ("Сотрудники" "ФИО") object:findProperty ?fioAttr.

        # В текущей записи ?item получаем менеджера
        # и помещаем его в переменную ?m
        ?item ?managerAttr ?m.
        # Из записи менеджера получаем его ФИО
        # и помещаем его в переменную ?fio
        ?m ?fioAttr ?fio.
        # Возвращаем ФИО менеджера в выходную переменную ?value
        ?fio -> ?value.
    }
    ```

        !!! example "Эквивалентная формула"

        ``` sql
        $Менеджер->ФИО
        ```

## Сокращения и платформенные особенности {: #tutorial_n3_lesson_2_shorthands }

- `=` — связывание/равенство для сопоставления значений.

## Интерпретатор: порядок и конъюнкция (AND) {: #tutorial_n3_lesson_2_interpreter }

- Триплеты выполняются сверху вниз; при `false` текущая ветка отбрасывается.
- Между триплетами по умолчанию — конъюнкция (логическое И). Условие считается истинным, если все триплеты ветки истинны.

Мини‑пример: оба поля даты пусты (истина только при пустоте обоих):

!!! warning "Бизнес-логика"

    Проверим, что у заявки не назначены плановые даты — оба поля пусты.

``` turtle
# Импортируем предикаты для работы с записями.
@prefix object: <http://comindware.com/ontology/object#>.
{
    # Получаем атрибут "ПланНачало" из шаблона "Заявки"
    # и помещаем его в переменную ?start
    ("Заявки" "ПланНачало") object:findProperty ?start.
    # Получаем атрибут "ПланОкончание" из шаблона "Заявки"
    # и помещаем его в переменную ?end
    ("Заявки" "ПланОкончание") object:findProperty ?end.

    # Проверяем, что поле "ПланНачало" пустое
    not { ?item ?start ?. }.
    # Проверяем, что поле "ПланОкончание" пустое
    not { ?item ?end  ?. }.
    # Если оба поля пустые, возвращаем true
    true -> ?value.
}
```

!!! example "Эквивалентная формула"

    
    ``` sql
    AND(ISEMPTY($ПланНачало), ISEMPTY($ПланОкончание))
    ```

## Мини‑рефактор: Формула → N3 {: #tutorial_n3_lesson_2_formula_to_n3 }

Простая формула: `=$IssueTypeRef->Title` эквивалентна выражению N3:

``` turtle
# Импортируем предикаты для работы с записями.
@prefix object: <http://comindware.com/ontology/object#>.
{
    # Получаем атрибут "IssueType" из шаблона "Issue"
    # и помещаем его в переменную ?issueTypeAttr
    ("Issue" "IssueType") object:findProperty ?issueTypeAttr.
    # Получаем атрибут "Title" из шаблона "Type"
    # и помещаем его в переменную ?titleAttr
    ("Type"  "Title")     object:findProperty ?titleAttr.

    # В текущей записи ?item получаем тип задачи
    # и помещаем его в переменную ?t
    ?item ?issueTypeAttr ?t.
    # Из записи типа получаем его название
    # и помещаем его в выходную переменную ?value
    ?t    ?titleAttr     ?value.
}
```

!!! example "Эквивалентная формула"

    
    ``` sql
    $IssueTypeRef->Title
    ```

## Ошибки и гигиена синтаксиса {: #tutorial_n3_lesson_2_hygiene }

- Проверяйте регистр имён переменных.
- Возвращайте значение совместимого типа: строка в текстовый атрибут, число в числовой и т.д.
- Повторное использование переменных должно быть осознанным.

## Практическое задание {: #tutorial_n3_lesson_2_practical_task }

Задача: в шаблоне _«Кандидаты»_ вычислить текстовый атрибут _«Строка визитки»_ в формате «ФИО — Отдел».

Подсказка: используйте `not { … ?. }` и точное совпадение; результат должен быть логическим (`true`/`false`). Для вывода строки воспользуйтесь `cmwstring:format`.

``` turtle
# Импортируем предикаты для работы с записями.
@prefix object: <http://comindware.com/ontology/object#>.
# Импортируем предикаты для работы со строками
@prefix cmwstring: <http://comindware.com/logics/string#>.
{
    # Получаем атрибут "Менеджер" из шаблона "Кандидаты"
    # и помещаем его в переменную ?managerAttr
    ("Кандидаты" "Менеджер") object:findProperty ?managerAttr.
    # Получаем атрибут "ФИО" из шаблона "Сотрудники"
    # и помещаем его в переменную ?fioAttr
    ("Сотрудники" "ФИО") object:findProperty ?fioAttr.
    # Получаем атрибут "Отдел" из шаблона "Сотрудники"
    # и помещаем его в переменную ?deptAttr
    ("Сотрудники" "Отдел") object:findProperty ?deptAttr.
    # Получаем атрибут "Название" из шаблона "Отделы"
    # и помещаем его в переменную ?deptNameAttr
    ("Отделы" "Название") object:findProperty ?deptNameAttr.

    # В текущей записи ?item получаем менеджера
    # и помещаем его в переменную ?m
    ?item ?managerAttr ?m.
    # Из записи менеджера получаем его ФИО
    # и помещаем его в переменную ?fio
    ?m ?fioAttr ?fio.
    # Из записи менеджера получаем его отдел
    # и помещаем его в переменную ?d
    ?m ?deptAttr ?d.
    # Из записи отдела получаем его название
    # и помещаем его в переменную ?deptName
    ?d ?deptNameAttr ?deptName.

    # Форматируем строку визитки в формате "ФИО — Отдел"
    # и помещаем её в переменную ?result
    ("{0} — {1}" ?fio ?deptName) cmwstring:format ?result.
    # Возвращаем отформатированную строку в выходную переменную ?value
    ?result -> ?value.
}
```

!!! example "Эквивалентная формула"

    
    ``` sql
    FORMAT("{0} — {1}", LIST($Менеджер->ФИО, $Менеджер->Отдел->Название))
    ```

Проверьте работу выражения на нескольких записях.

## Итоги урока {: #tutorial_n3_lesson_2_summary }

Вы закрепили базовый синтаксис N3, проработали `?item`/`?value`, разобрали пять форм работы с триплетами, шорткаты и правила «гигиены» выражений. На практике вы построили несколько минимальных запросов и собрали результирующую строку для HR‑сценария.

В ходе [следующего урока][tutorial_n3_lesson_3] вы изучите префиксы, URI и поиск атрибутов, в том числе `object:findProperty` в глубину.

<div class="relatedTopics" markdown="block">

--8<-- "related_topics_heading.md"

- [Справочник по N3][n3_guide_reference]
- [Учебник по N3][n3_tutorial_original]
- [Дайджест примеров N3][n3_examples_digest]

</div>

{% include-markdown ".snippets/hyperlinks_mkdocs_to_kb_map.md" %}

<!-- 
!!! tip "Синтаксис отрицания"

        В выражении `not { ?item ?phoneAttr ?. }` используется:

        - **`not { }`** — оператор отрицания, проверяет отсутствие факта
        - **`?.`** — анонимная переменная (wildcard), означает "любое значение"
        - **`not { ?item ?phoneAttr ?. }`** — проверяет, что НЕТ факта "у записи ?item есть значение атрибута ?phoneAttr"

        Альтернативные способы записи:
        - `not { ?item ?phoneAttr ?anyValue }` — с именованной переменной
        - `not { ?item ?phoneAttr ?. }` — с анонимной переменной (короче) -->