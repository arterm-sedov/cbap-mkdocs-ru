---
title: Получение HTTP-запросов в сценарии с помощью C#
kbTitle: HTTP-запросы. Получение запроса и обработка данных в формате JSON из сценария с помощью C#-скрипта. Настройка подключения, пути передачи данных и сценария
kbId: 5142
tags:
    - C#
    - HTTP-запрос
    - JSON
    - интеграция
    - интеграции
    - получение запросов
    - подключения
    - сценарии
hide: tags
---

# HTTP-запросы. Получение JSON-данных в сценарии с помощью C# {: #http_receive_example_csharp }

## Введение {: #http_receive_example_csharp_intro }

**{{ productName }}** может получать и обрабатывать HTTP-запросы из внешних систем с помощью сценариев.

Здесь представлен пример настройки подключения, пути передачи данных и [сценария][scenarios] для получения и обработки HTTP-запроса в формате JSON с использованием C#-скриптов и записи данных в атрибуты шаблона записи.

Настройка для обработки данных в формате XML и простого текста будет аналогичной.

!!! warning "Внимание!"

    Модели данных классов в C#-скриптах и в пути передачи данных должны совпадать, в противном случае данные не будут сопоставлены и не будут передаваться.

{% include-markdown ".snippets/http_receive_logics.md" %}

{% include-markdown ".snippets/http_receive_authentication.md" %}

См. также _«[HTTP-запросы с составным содержимым. Получение файлов в сценарии][http_receive_file]»_

## Прикладная задача {: #http_receive_example_csharp_task .pageBreakBefore }

Требуется получить заказ из внешней системы, создать заказ с позициями в **{{ productName }}** и отправить ответ с датой создания заказа и массивом статусов позиций: `Принята` или `Отклонена`.

Рассмотрим настройку получения запросов от сервера и обработку данных с помощью C#-скрипта.

- Имеются шаблоны записей:
    - _«Заказы»_ с атрибутами:
        - _«Номер заказа»_ типа «**Текст**»;
        - _«Позиции»_ типа «**Запись**», ссылается на шаблон _«Позиции заказов»_ и **хранит несколько значений**.
    - _«Позиции заказов»_ с атрибутами:
        - _Товар_ типа «**Текст**»;
        - _Количество_ типа «**Число**».
- Внешний сервер отправляет в **{{ productName }}** HTTP-запросы с данными в формате JSON следующего вида:

    ``` json
    {
        "orderNumber": "string",
        "items": [
            {
                "product": "string",
                "quantity": "int"
            }
        ]
    }
    ```

- [Сценарий](#http_receive_example_csharp_scenario) выполняет следующие операции:
    - получает HTTP-запрос от внешнего сервера;
    - с помощью C#-скрипта обрабатывает полученные данные, создаёт позиции и заказ;
    - с помощью C#-скрипта формирует ответ для отправки обратно во внешнюю систему с массивом позиций и их статусами.
    - отправляет JSON-ответ следующего вида:

    ``` json
    {
        "date": "dateTime",
        "items": [
            {
                "product": "string",
                "status": "string"
            }
        ]
    }
    ```

!!! note "Примечание"

    Здесь не рассматривается проверка полученных данных на уникальность и совпадение с имеющимися в записях.

## Порядок настройки получения HTTP-запросов {: #http_receive_example_csharp_sequence .pageBreakBefore }

--8<-- "http_receive_configure_sequence.md"

[](){: #connection_configure }
## Настройка подключения {: #http_receive_example_csharp_connection }

1. На странице «**Администрирование**» выберите пункт «**Инфраструктура**» — «[**Подключения**][connections]» <i fal fa-exchange-alt></i>.
2. Откройте или создайте подключение типа «**Подключения REST и OData**» — «**Получение HTTP-запросов**».
3. Настройте подключение к **{{ productName }}** для внешних систем:

    - **Путь URI** — введите суффикс, соответствующий назначению подключения, например `orders`.

    При необходимости введите дополнительный **путь URI** на вкладке «**Интеграция**» в свойствах [пути передачи данных](#http_receive_example_csharp_route), например `place`.

    Укажите результирующий путь (**базовый путь получения HTTP-запросов** + **путь URI** из подключения + **путь URI** из пути передачи данных) на внешнем сервере в качестве получателя запросов, например:

        ```
        https://<hostname>/api/public/adapter/orders/place
        ```

    - **Формат данных** — выберите **JSON** для использования в данном примере.

4. Остальные параметры настройте согласно своим бизнес-требованиям.
5. Сохраните подключение.

_![Настройка подключения для получения HTTP-запросов с помощью сценариев](img/receive_http_example_csharp_connection_create.png)_

[](){: #communication_route_configure }
## Настройка пути передачи данных {: #http_receive_example_csharp_route .pageBreakBefore }

1. Откройте страницу «**Администрирование**» — «**Архитектура**» или страницу «**Администрирование**» приложения.
2. Выберите пункт «[**Пути передачи данных**][communication_routes]» <i class="fa-light fa-route " aria-hidden="true"></i>.
3. Откройте или создайте путь передачи данных типа «**Подключения REST и OData**» — «**Получение HTTP-запросов**».
4. Настройте свойства пути передачи данных на следующих вкладках:

    - [**Основные свойства**](#http_receive_example_csharp_route_main)
    - [**Атрибуты сообщений**](#http_receive_example_csharp_route_attributes)
    - [**Интеграция**](#http_receive_example_csharp_route_integration)

5. Сохраните путь передачи данных.

### Основные свойства {: #http_receive_example_csharp_route_main }

На вкладке «**Основные свойства**» настройте параметры использования пути передачи данных:

- **Подключение** — выберите [подключение для получения HTTP-запросов](#http_receive_example_csharp_connection).
- **Системное имя** — введите уникальное имя пути передачи данных.
- **Отключить** — установите этот флажок, если требуется временно деактивировать путь передачи данных.
- **Описание** — введите наглядное описание пути передачи данных, например _«Получение заказов по HTTP»_.
- **Номер шины данных** — выберите номер от 0 до 3, если требуется распределить потоки данных нескольких путей для повышения производительности.

_![Настройка основных свойств пути для получения HTTP-запросов](img/receive_http_example_csharp_route_general.png)_

### Атрибуты сообщений {: #http_receive_example_csharp_route_attributes }

!!! warning "Составление атрибута сообщения типа «Объект»"

    Чтобы составить **атрибут сообщения** типа «**Объект**» для хранения структурированных данных, необходимо создать структуру из родительского и дочерних атрибутов:

    --8<-- "communication_route_message_attribute_object.md"

1. Выберите **тип сообщения** «**Обработка HTTP-запросов**».
2. В таблице «**Запрос**» воссоздайте структуру JSON входящего запроса, добавив следующие атрибуты:

    - `orderNumber` типа «**Строка**» — номер заказа.
    - `items` типа «**Объект**»:
        - `items` типа «**Объект**»:
        - Установите флажок «**Массив**» — атрибут `items` будет содержать массив позиций.
        - Установите флажок слева от атрибута `items` и добавьте в него дочерние атрибуты:
            - `product` типа «**Строка**» — название товара.
            - `quantity` типа «**Число**» — количество товара.

    В эти атрибуты будут передаваться данные позиций для обработки.

    **Системные имена** этих атрибутов должны совпадать с именами соответствующих полей HTTP-запроса.

3. В таблице «**Ответ**» составьте структуру атрибутов для ответа в случае успешной обработки заказа:

    - `data` типа «**Дата/время**» — дата и время обработки заказа.
    - `items` типа «**Объект**»:
    - Установите флажок «**Массив**» — атрибут `items` будет содержать массив статусов позиций.
    - Установите флажок слева от атрибута `items` и добавьте в него дочерние атрибуты:
        - `product` типа «**Строка**» — название товара.
        - `status` типа «**Строка**» — статус позиции.

    _![Настройка атрибутов сообщения](img/receive_http_example_csharp_route_message_attributes.png)_

4. При необходимости настройте **ответ с ошибкой** — структуру атрибутов для ответа на запрос, при обработке которого произошла ошибка.

### Интеграция {: #http_receive_example_csharp_route_integration }

1. При необходимости укажите дополнительный суффикс в поле «**Путь URI**», например `place`. Этот суффикс будет добавлен к URL-адресу, настроеннjve в [подключении](#http_receive_example_csharp_connection).

    Укажите результирующий путь (**базовый путь получения HTTP-запросов** + **путь URI** из подключения + **путь URI** из пути передачи данных) на внешнем сервере в качестве получателя запросов, например:

    ```
    https://<hostname>/api/public/adapter/orders/place
    ```

2. **Укажите атрибуты для десериализации данных**. По умолчанию следует указать `$` в обоих столбцах, чтобы получить всю структуру JSON из запроса. Для поиска определенного атрибута используйте JSONPath.
3. При необходимости укажите **атрибут для заголовков**, в котором будут содержаться все атрибуты заголовков запроса, **атрибут для параметров запроса**, в котором будут содержаться все параметры запроса, и **атрибут для тела запроса**, в котором будет содержаться всё тело запроса.

    _![Настройка интеграции](img/receive_http_example_csharp_route_integration.png)_

[](){: #scenario_configure }
## Настройка сценария {: #http_receive_example_csharp_scenario .pageBreakBefore }

!!! warning "Логика работы сценария"

    - В сценарии используется один C#-скрипт и две переменные для обработки входящего сообщения и подготовки ответа:
        - `IncomingMessage` — переменная для хранения входящего сообщения;
        - `ReplyIncomingMessage` — переменная для хранения данных ответа.
    - HTTP-запрос обрабатывается автоматически при получении сообщения.
    - Ответ будет отправлен только после выполнения всего сценария, если C#-скрипт вернёт `true`.

1. Создайте новый [сценарий][scenarios] _«Обработка заказов»_.
2. У начального события измените тип на «**Получение сообщения**» и настройте его:

    - **Контекстный шаблон:** _Заказы_
    - **Подключение:** [подключение для получения HTTP-запросов](#http_receive_example_csharp_connection)
    - **Путь передачи данных:** [путь передачи данных для получения HTTP-запросов](#http_receive_example_csharp_route)
    - **Имя переменной:** _IncomingMessage_

    _![Настройка действия «Получение сообщения»](img/receive_http_example_csharp_scenario_receive_message.png)_

3. После события «**Получение сообщения**» добавьте действие «**Проверить результат скрипта**» для обработки входящего сообщения и подготовки ответа с помощью C#-скрипта:

    - **Сообщение об ошибке** — введите текст сообщения, которое будет отображено, если скрипт вернёт `false` (например, _«Ошибка»_).

        Скрипт должен возвращать `true`. Если скрипт вернёт `false`, сценарий будет остановлен.

    - **Выражение** — задайте C#-скрипт для обработки входящего сообщения по следующему образцу:

    <!-- Jinja raw marker (escape) to avoid interpolation of C# code -->
    {% raw %}
    ``` cs
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Comindware.Data.Entity;
    using Comindware.TeamNetwork.Api.Data.UserCommands;
    using Comindware.TeamNetwork.Api.Data;

    class Script
    {
        public static bool Main(Object o)
        {
            // Получаем входящее сообщение.
            // IncomingRootMessage – класс сообщения (структура данных)
            // Имя RawIncomingMessage состоит из двух частей:
            // 1. Raw – неизменный системный префикс
            // 2. IncomingMessage – имя переменной с сообщением, заданной в событии «Получение сообщения»
            var input = Api.Base.LocalVariablesService.Get<IncomingRootMessage>("RawIncomingMessage");
            
            // Объявляем списки для хранения идентификаторов созданных позиций и данных для ответа
            var newItems = new List<string>();
            var itemsStatus = new List<ItemStatus>();
            
            // Обрабатываем каждую позицию из входящего запроса
            foreach(var item in input.items)
            {
                // Создаём позицию в системе
                // ПозицииЗаказов – системное имя шаблона записи
                // Товар, Количество – системные имена атрибутов шаблона «Позиции заказов»
                var itemId = Api.TeamNetwork.ObjectService.CreateWithAlias("ПозицииЗаказов", new Dictionary<string,object>{{"Товар", item.product},{"Количество", item.quantity}});
                newItems.Add(itemId);
                
                // Формируем данные для ответа со статусом позиции
                itemsStatus.Add(new ItemStatus{product = item.product, status = "Принята"});
            }
            
            // Создаём заказ в системе
            // Заказы — системное имя шаблона записи
            // НомерЗаказа, Позиции — системные имена атрибутов шаблона «Заказы»
            Api.TeamNetwork.ObjectService.CreateWithAlias("Заказы", new Dictionary<string,object>{{"НомерЗаказа", input.orderNumber},{"Позиции", newItems}});
            
            // Формируем корневой объект ответа
            // OutgoingRootMessage – класс сообщения (структура данных)
            var outgoingMessage = new OutgoingRootMessage
            {
                data = DateTime.Now,
                items = itemsStatus
            };
            
            // Проставляем в локальную переменную значение для последующей отправки
            // Имя RawReplyIncomingMessage состоит из двух частей:
            // 1. Raw — неизменный системный префикс
            // 2. ReplyIncomingMessage — имя переменной, заданной в настройках события «Получение сообщения»
            // Ответ будет отправлен только после выполнения всего сценария
            Api.Base.LocalVariablesService.Set<OutgoingRootMessage>("RawReplyIncomingMessage", outgoingMessage);
            
            return true;
        }
    }

    public class IncomingRootMessage
    {
        public string orderNumber {get; set;}
        public List<Item> items {get; set;}
    }

    public class Item
    {
        public string product {get; set;}
        public int quantity {get; set;}
    }

    public class OutgoingRootMessage
    {
        public DateTime data {get; set;}
        public List<ItemStatus> items {get;set;}
    }

    public class ItemStatus
    {
        public string product {get;set;}
        public string status {get;set;}
    }
    ```
    {% endraw %}

4. Результирующий сценарий должен выглядеть, как показано на следующей иллюстрации.

    _![Сценарий для получения HTTP-запроса с использованием C#-скриптов](img/receive_http_example_csharp_scenario.png)_

5. Проверьте работу приложения.

[](){: #testing }
## Тестирование {: #http_receive_example_csharp_testing .pageBreakBefore }

Сценарий должен получать HTTP-запрос с данными заказов, обрабатывать их с помощью C#-скрипта, создавать позиции и заказ, а также формировать ответ с массивом позиций и их статусами.

1. С внешнего сервера отправьте в **{{ productName }}** запрос с данными заказов, например:

    ``` sh
    curl -X POST \
        -u username:password \
        -H "Content-Type: application/json" \
        -d '{
            "orderNumber": "Заказ №1",
            "items": [
                {
                    "product": "Бумага",
                    "quantity": 2
                },
                {
                    "product": "Картридж",
                    "quantity": 1
                }
            ]
        }' \
        https://<hostname>/api/public/adapter/orders/place
        -v
    ```

    Здесь:

    - `-X POST` — метод запроса;
    - `-u username:password` — базовая аутентификация c учётными данными аккаунта с разрешением на **вызовы API** **{{ productName }}**;
    - `-H "Content-Type: application/json"` — заголовок, указывающий на формат данных JSON;
    - `-d '...'` — тело запроса с JSON-структурой заказа;
    - `https://<hostname>/api/public/adapter/orders/place` — **базовый путь получения HTTP-запросов** + **путь URI** из подключения + **путь URI** из пути передачи данных;
    - `-v` — вывод отладочных данных (необязательный ключ).

2. Проверьте обработку запроса: должны быть созданы записи в шаблоне _«Заказы»_, соответствующие полученному запросу.

<div class="relatedTopics" markdown="block">

--8<-- "related_topics_heading.md"

- _[HTTP-запросы с составным содержимым. Получение файлов в сценарии][http_receive_file]_
- _[HTTP-запросы типа POST. Отправка составного содержимого и файлов][http_send_file]_
- _[Событие и действия сценария. Определения, типы, свойства, настройка][scenario_elements]_

</div>

{%
include-markdown ".snippets/hyperlinks_mkdocs_to_kb_map.md"
%}
