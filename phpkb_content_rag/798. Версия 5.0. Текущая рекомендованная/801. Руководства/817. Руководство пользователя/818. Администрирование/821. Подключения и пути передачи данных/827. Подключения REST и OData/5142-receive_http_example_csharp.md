---
title: 'HTTP-запросы. Получение JSON-данных с помощью C#-скрипта. Настройка подключения, пути передачи данных и сценария'
kbId: 5142
url: 'https://kb.comindware.ru/article.php?id=5142'
updated: '2025-12-26 12:34:06'
---

# HTTP-запросы. Получение JSON-данных с помощью C#-скрипта. Настройка подключения, пути передачи данных и сценария

## Введение

**Comindware Platform** может получать и обрабатывать HTTP-запросы из внешних систем с помощью сценариев.

Здесь представлен пример настройки подключения, пути передачи данных и [сценария](https://kb.comindware.ru/article.php?id=4717) для получения и обработки HTTP-запроса в формате JSON с использованием C#-скриптов и записи данных в атрибуты шаблона записи.

Настройка для обработки данных в формате XML и простого текста будет аналогичной.

Внимание!

Модели данных классов в C#-скриптах и в пути передачи данных должны совпадать, в противном случае данные не будут сопоставлены и не будут передаваться.

Логика обработки входящих HTTP-запросов

- Для получения HTTP-запросов из внешних систем **Comindware Platform** позволяет настроить конечные точки API вида:

  ```
  https://<instanceUrl>/api/public/adapter/<connectionUri>/<routeUri>

  ```

  Здесь:

  - `<instanceUrl>` — адрес экземпляра **Comindware Platform**;
  - `<connectionUri>` — путь URI, настроенный в свойствах подключения для получения HTTP-запросов;
  - `<routeUri>` — путь URI, настроенный в свойствах пути передачи данных для получения HTTP-запросов.
- При поступлении HTTP-запроса на настроенную конечную точку **Comindware Platform** запускает сценарий по событию «**Получение сообщения**» и передаёт в него данные запроса.

Аутентификация для доступа к Comindware Platform по HTTP

- Для базовой аутентификации при отправке HTTP-запросов в **Comindware Platform** следует использовать учётные данные аккаунта, который имеет разрешение на **вызовы API**. По умолчанию такое разрешение имеют аккаунты с **системной ролью** «**Системные администраторы**».

  При базовой аутентификации для безопасной обработки входящих HTTP-запросов рекомендуется:

  - создать специальный аккаунт для авторизации HTTP-запросов;
  - создать системную роль с разрешением на **вызовы API**;
  - добавить в данную системную роль аккаунт для HTTP-запросов.

  См. *[Аккаунты](https://kb.comindware.ru/article.php?id=4653)* и *[Системные роли](https://kb.comindware.ru/article.php?id=4662)*.
- Кроме того, можно использовать аутентификацию посредством ключей API. См. *[Ключи аутентификации API](https://kb.comindware.ru/article.php?id=4674)*.

См. также *«[HTTP-запросы с составным содержимым. Получение файлов в сценарии](https://kb.comindware.ru/article.php?id=5083)»*

## Прикладная задача

Требуется получить заказ из внешней системы, создать заказ с позициями в **Comindware Platform** и отправить ответ с датой создания заказа и массивом статусов позиций: `Принята` или `Отклонена`.

Рассмотрим настройку получения запросов от сервера и обработку данных с помощью C#-скрипта.

- Имеются шаблоны записей:
  - *«Заказы»* с атрибутами:
    - *«Номер заказа»* типа «**Текст**»;
    - *«Позиции»* типа «**Запись**», ссылается на шаблон *«Позиции заказов»* и **хранит несколько значений**.
  - *«Позиции заказов»* с атрибутами:
    - *Товар* типа «**Текст**»;
    - *Количество* типа «**Число**».
- Внешний сервер отправляет в **Comindware Platform** HTTP-запросы с данными в формате JSON следующего вида:

  ```
  {
      "orderNumber": "string",
      "items": [
          {
              "product": "string",
              "quantity": "int"
          }
      ]
  }

  ```
- [Сценарий](#http_receive_example_csharp_scenario) выполняет следующие операции:

  - получает HTTP-запрос от внешнего сервера;
  - с помощью C#-скрипта обрабатывает полученные данные, создаёт позиции и заказ;
  - с помощью C#-скрипта формирует ответ для отправки обратно во внешнюю систему с массивом позиций и их статусами.
  - отправляет JSON-ответ следующего вида:

  ```
  {
      "date": "dateTime",
      "items": [
          {
              "product": "string",
              "status": "string"
          }
      ]
  }

  ```

Примечание

Здесь не рассматривается проверка полученных данных на уникальность и совпадение с имеющимися в записях.

## Порядок настройки получения HTTP-запросов

1. Настройте [подключение](#connection_configure) для получения HTTP-запросов.
2. Настройте [путь передачи данных](#communication_route_configure) для получения HTTP-запросов.
3. Настройте [сценарий](#scenario_configure) для обработки входящих HTTP-запросов.
4. [Проверьте работоспособность](#testing) настроенной конфигурации.

## Настройка подключения

1. На странице «**Администрирование**» выберите пункт «**Инфраструктура**» — «[**Подключения**](https://kb.comindware.ru/article.php?id=4675)» .
2. Откройте или создайте подключение типа «**Подключения REST и OData**» — «**Получение HTTP-запросов**».
3. Настройте подключение к **Comindware Platform** для внешних систем:

   - **Путь URI** — введите суффикс, соответствующий назначению подключения, например `orders`.

   При необходимости введите дополнительный **путь URI** на вкладке «**Интеграция**» в свойствах [пути передачи данных](#http_receive_example_csharp_route), например `place`.

   Укажите результирующий путь (**базовый путь получения HTTP-запросов** + **путь URI** из подключения + **путь URI** из пути передачи данных) на внешнем сервере в качестве получателя запросов, например:

   ```
   ```
   https://<hostname>/api/public/adapter/orders/place
   ```

   ```

   - **Формат данных** — выберите **JSON** для использования в данном примере.
4. Остальные параметры настройте согласно своим бизнес-требованиям.
5. Сохраните подключение.

_![Настройка подключения для получения HTTP-запросов с помощью сценариев](/platform/v5.0/administration/connections_communication_routes/rest_odata_connections/img/receive_http_example_csharp_connection_create.png)_

## Настройка пути передачи данных

1. Откройте страницу «**Администрирование**» — «**Архитектура**» или страницу «**Администрирование**» приложения.
2. Выберите пункт «[**Пути передачи данных**](https://kb.comindware.ru/article.php?id=4676)» *‌*.
3. Откройте или создайте путь передачи данных типа «**Подключения REST и OData**» — «**Получение HTTP-запросов**».
4. Настройте свойства пути передачи данных на следующих вкладках:

   - [**Основные свойства**](#http_receive_example_csharp_route_main)
   - [**Атрибуты сообщений**](#http_receive_example_csharp_route_attributes)
   - [**Интеграция**](#http_receive_example_csharp_route_integration)
5. Сохраните путь передачи данных.

### Основные свойства

На вкладке «**Основные свойства**» настройте параметры использования пути передачи данных:

- **Подключение** — выберите [подключение для получения HTTP-запросов](#http_receive_example_csharp_connection).
- **Системное имя** — введите уникальное имя пути передачи данных.
- **Отключить** — установите этот флажок, если требуется временно деактивировать путь передачи данных.
- **Описание** — введите наглядное описание пути передачи данных, например *«Получение заказов по HTTP»*.
- **Номер шины данных** — выберите номер от 0 до 3, если требуется распределить потоки данных нескольких путей для повышения производительности.

_![Настройка основных свойств пути для получения HTTP-запросов](/platform/v5.0/administration/connections_communication_routes/rest_odata_connections/img/receive_http_example_csharp_route_general.png)_

### Атрибуты сообщений

Составление атрибута сообщения типа «Объект»

Чтобы составить **атрибут сообщения** типа «**Объект**» для хранения структурированных данных, необходимо создать структуру из родительского и дочерних атрибутов:

- Создайте атрибут типа «**Объект**», задайте его имя, но оставьте значение пустым.
- Установите флажок у имени родительского атрибута в таблице и нажмите кнопку «**Добавить**».
- Дважды нажмите значок *‌* рядом с родительским атрибутом.
- В таблице отобразится строка дочернего атрибута.
- Задайте системное имя и тип дочернего атрибута.

1. Выберите **тип сообщения** «**Обработка HTTP-запросов**».
2. В таблице «**Запрос**» воссоздайте структуру JSON входящего запроса, добавив следующие атрибуты:

   - `orderNumber` типа «**Строка**» — номер заказа.
   - `items` типа «**Объект**»:
     - `items` типа «**Объект**»:
     - Установите флажок «**Массив**» — атрибут `items` будет содержать массив позиций.
     - Установите флажок слева от атрибута `items` и добавьте в него дочерние атрибуты:
       - `product` типа «**Строка**» — название товара.
       - `quantity` типа «**Число**» — количество товара.

   В эти атрибуты будут передаваться данные позиций для обработки.

   **Системные имена** этих атрибутов должны совпадать с именами соответствующих полей HTTP-запроса.
3. В таблице «**Ответ**» составьте структуру атрибутов для ответа в случае успешной обработки заказа:

   - `data` типа «**Дата/время**» — дата и время обработки заказа.
   - `items` типа «**Объект**»:
   - Установите флажок «**Массив**» — атрибут `items` будет содержать массив статусов позиций.
   - Установите флажок слева от атрибута `items` и добавьте в него дочерние атрибуты:
     - `product` типа «**Строка**» — название товара.
     - `status` типа «**Строка**» — статус позиции.

   ![Настройка атрибутов сообщения](/platform/v5.0/administration/connections_communication_routes/rest_odata_connections/img/receive_http_example_csharp_route_message_attributes.png)

   Настройка атрибутов сообщения
4. При необходимости настройте **ответ с ошибкой** — структуру атрибутов для ответа на запрос, при обработке которого произошла ошибка.

### Интеграция

1. При необходимости укажите дополнительный суффикс в поле «**Путь URI**», например `place`. Этот суффикс будет добавлен к URL-адресу, настроеннjve в [подключении](#http_receive_example_csharp_connection).

   Укажите результирующий путь (**базовый путь получения HTTP-запросов** + **путь URI** из подключения + **путь URI** из пути передачи данных) на внешнем сервере в качестве получателя запросов, например:

   ```
   https://<hostname>/api/public/adapter/orders/place

   ```
2. **Укажите атрибуты для десериализации данных**. По умолчанию следует указать `$` в обоих столбцах, чтобы получить всю структуру JSON из запроса. Для поиска определенного атрибута используйте JSONPath.
3. При необходимости укажите **атрибут для заголовков**, в котором будут содержаться все атрибуты заголовков запроса, **атрибут для параметров запроса**, в котором будут содержаться все параметры запроса, и **атрибут для тела запроса**, в котором будет содержаться всё тело запроса.

   ![Настройка интеграции](/platform/v5.0/administration/connections_communication_routes/rest_odata_connections/img/receive_http_example_csharp_route_integration.png)

   Настройка интеграции

## Настройка сценария

Логика работы сценария

- В сценарии используется один C#-скрипт и две переменные для обработки входящего сообщения и подготовки ответа:
  - `IncomingMessage` — переменная для хранения входящего сообщения;
  - `ReplyIncomingMessage` — переменная для хранения данных ответа.
- HTTP-запрос обрабатывается автоматически при получении сообщения.
- Ответ будет отправлен только после выполнения всего сценария, если C#-скрипт вернёт `true`.

1. Создайте новый [сценарий](https://kb.comindware.ru/article.php?id=4717) *«Обработка заказов»*.
2. У начального события измените тип на «**Получение сообщения**» и настройте его:

   - **Контекстный шаблон:** *Заказы*
   - **Подключение:** [подключение для получения HTTP-запросов](#http_receive_example_csharp_connection)
   - **Путь передачи данных:** [путь передачи данных для получения HTTP-запросов](#http_receive_example_csharp_route)
   - **Имя переменной:** *IncomingMessage*

   ![Настройка действия «Получение сообщения»](/platform/v5.0/administration/connections_communication_routes/rest_odata_connections/img/receive_http_example_csharp_scenario_receive_message.png)

   Настройка действия «Получение сообщения»
3. После события «**Получение сообщения**» добавьте действие «**Проверить результат скрипта**» для обработки входящего сообщения и подготовки ответа с помощью C#-скрипта:

   - **Сообщение об ошибке** — введите текст сообщения, которое будет отображено, если скрипт вернёт `false` (например, *«Ошибка»*).

     Скрипт должен возвращать `true`. Если скрипт вернёт `false`, сценарий будет остановлен.
   - **Выражение** — задайте C#-скрипт для обработки входящего сообщения по следующему образцу:

   ```
   using System;
   using System.Collections.Generic;
   using System.Linq;
   using Comindware.Data.Entity;
   using Comindware.TeamNetwork.Api.Data.UserCommands;
   using Comindware.TeamNetwork.Api.Data;

   class Script
   {
       public static bool Main(Object o)
       {
           // Получаем входящее сообщение.
           // IncomingRootMessage – класс сообщения (структура данных)
           // Имя RawIncomingMessage состоит из двух частей:
           // 1. Raw – неизменный системный префикс
           // 2. IncomingMessage – имя переменной с сообщением, заданной в событии «Получение сообщения»
           var input = Api.Base.LocalVariablesService.Get<IncomingRootMessage>("RawIncomingMessage");

           // Объявляем списки для хранения идентификаторов созданных позиций и данных для ответа
           var newItems = new List<string>();
           var itemsStatus = new List<ItemStatus>();

           // Обрабатываем каждую позицию из входящего запроса
           foreach(var item in input.items)
           {
               // Создаём позицию в системе
               // ПозицииЗаказов – системное имя шаблона записи
               // Товар, Количество – системные имена атрибутов шаблона «Позиции заказов»
               var itemId = Api.TeamNetwork.ObjectService.CreateWithAlias("ПозицииЗаказов", new Dictionary<string,object>{{"Товар", item.product},{"Количество", item.quantity}});
               newItems.Add(itemId);

               // Формируем данные для ответа со статусом позиции
               itemsStatus.Add(new ItemStatus{product = item.product, status = "Принята"});
           }

           // Создаём заказ в системе
           // Заказы — системное имя шаблона записи
           // НомерЗаказа, Позиции — системные имена атрибутов шаблона «Заказы»
           Api.TeamNetwork.ObjectService.CreateWithAlias("Заказы", new Dictionary<string,object>{{"НомерЗаказа", input.orderNumber},{"Позиции", newItems}});

           // Формируем корневой объект ответа
           // OutgoingRootMessage – класс сообщения (структура данных)
           var outgoingMessage = new OutgoingRootMessage
           {
               data = DateTime.Now,
               items = itemsStatus
           };

           // Проставляем в локальную переменную значение для последующей отправки
           // Имя RawReplyIncomingMessage состоит из двух частей:
           // 1. Raw — неизменный системный префикс
           // 2. ReplyIncomingMessage — имя переменной, заданной в настройках события «Получение сообщения»
           // Ответ будет отправлен только после выполнения всего сценария
           Api.Base.LocalVariablesService.Set<OutgoingRootMessage>("RawReplyIncomingMessage", outgoingMessage);

           return true;
       }
   }

   public class IncomingRootMessage
   {
       public string orderNumber {get; set;}
       public List<Item> items {get; set;}
   }

   public class Item
   {
       public string product {get; set;}
       public int quantity {get; set;}
   }

   public class OutgoingRootMessage
   {
       public DateTime data {get; set;}
       public List<ItemStatus> items {get;set;}
   }

   public class ItemStatus
   {
       public string product {get;set;}
       public string status {get;set;}
   }

   ```
4. Результирующий сценарий должен выглядеть, как показано на следующей иллюстрации.

   ![Сценарий для получения HTTP-запроса с использованием C#-скриптов](/platform/v5.0/administration/connections_communication_routes/rest_odata_connections/img/receive_http_example_csharp_scenario.png)

   Сценарий для получения HTTP-запроса с использованием C#-скриптов
5. Проверьте работу приложения.

## Тестирование

Сценарий должен получать HTTP-запрос с данными заказов, обрабатывать их с помощью C#-скрипта, создавать позиции и заказ, а также формировать ответ с массивом позиций и их статусами.

1. С внешнего сервера отправьте в **Comindware Platform** запрос с данными заказов, например:

   ```
   curl -X POST \\
       -u username:password \\
       -H "Content-Type: application/json" \\
       -d '{
           "orderNumber": "Заказ №1",
           "items": [
               {
                   "product": "Бумага",
                   "quantity": 2
               },
               {
                   "product": "Картридж",
                   "quantity": 1
               }
           ]
       }' \\
       https://<hostname>/api/public/adapter/orders/place
       -v

   ```

   Здесь:

   - `-X POST` — метод запроса;
   - `-u username:password` — базовая аутентификация c учётными данными аккаунта с разрешением на **вызовы API** **Comindware Platform**;
   - `-H "Content-Type: application/json"` — заголовок, указывающий на формат данных JSON;
   - `-d '...'` — тело запроса с JSON-структурой заказа;
   - `https://<hostname>/api/public/adapter/orders/place` — **базовый путь получения HTTP-запросов** + **путь URI** из подключения + **путь URI** из пути передачи данных;
   - `-v` — вывод отладочных данных (необязательный ключ).
2. Проверьте обработку запроса: должны быть созданы записи в шаблоне *«Заказы»*, соответствующие полученному запросу.

## Связанные статьи

- *[HTTP-запросы с составным содержимым. Получение файлов в сценарии](https://kb.comindware.ru/article.php?id=5083)*
- *[HTTP-запросы типа POST. Отправка составного содержимого и файлов](https://kb.comindware.ru/article.php?id=5066)*
- *[Событие и действия сценария. Определения, типы, свойства, настройка](https://kb.comindware.ru/article.php?id=4718)*